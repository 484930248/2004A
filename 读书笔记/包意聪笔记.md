# 1.什么是JavaScript

```
     1995年，JavaScript问世,那时候主要是代替Perl等服务端语言处理输入验证,网景公司希望通过在其Navigator浏览器中加入JavaScript来改变这个局面,JavaScript逐渐成为市面上所有主流浏览器的标配。如今，JavaScript的应用也不再局限于据验证，而是渗透到浏览器窗口及其内容的方方面面。JavaScript已被公认为主流的编程语言，能够实现复杂的计算与交互，括闭包、匿名（lambda）函数，甚至元编程等特性。不仅是桌面浏览器，手机浏览器和屏幕阅读器也支持JavaScript，其重要性可见一斑。就连拥有自家客户端脚本语言VBScript的微软公司，也在其Internet Explorer（以下简称IE）浏览器最初的版本中包含了自己的JavaScript实现。
    javascript实现包含以下几个部分:  核心(ECMAScript)  文档对象模型(DOM)  浏览器对象模型(BOM)
    JavaScript是一门用来与网页交互的脚本语言，包含以下三个组成部分。ECMAScript:由ECMA-262定义并提供核心功能。文档对象模型（DOM）：提供与网页内容交互的方法和接口。浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。
    JavaScript的这三个部分得到了五大Web浏览器（IE、Firefox、Chrome、Safari和Opera）不同程度的支持。所有浏览器基本上对ES5（ECMAScript 5）提供了完善的支持，而对ES6（ECMAScript 6）和ES7（ECMAScript 7）的支持度也在不断提升。这些浏览器对DOM的支持各不相同，但对Level 3的支持日益趋于规范。HTML5中收录的BOM会因浏览器而异，不过开发者仍然可以假定存在很大一部分公共特性。
```

### <script> 元素

```
将JavaScript插入HTML的主要方法是使用 <script> 元素。这个元素是由网景公司创造出来，并最早在Netscape Navigator 2中实现的。后来，这个元素被正式加入到HTML规范。 <script> 元素有下列8个属性:
     1.async ：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。
     2.charset ：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。
     3.crossorigin ：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。crossorigin="anonymous" 配置文件请求不必设置凭据标志。crossorigin="use-credentials" 设置凭据标志，意味着出站请求会包含凭据。
	4.defer ：可选。表示在文档解析和显示完成后再执行脚本是没有问题的。只对外部脚本文件有效。在IE7及更早的版本中，对行内脚本也可以指定这个属性。
	5.integrity ：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource Intergrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。
	6.language ：废弃。最初用于表示代码块中的脚本语言（如 "JavaScript" 、 "JavaScript1.2" 或 "VBScript" ）。大多数浏览器都会忽略这个属性，不应该再使用它。
	7.src ：可选。表示包含要执行的代码的外部文件。
	8.type ：可选。代替 language ，表示代码块中脚本语言的内容类型（也称MIME类型）。按照惯例，这个值始终都是 "text/javascript" ，尽管 "text/javascript" 和 "text/ecmascript" 都已经废弃。
```



```
   JavaScript是通过<script>元素插入到HTML页面中的。这个元素可用于把JavaScript代码嵌入到HTML页面中，跟其他标记混合在一起，也可用于引入保存在外部文件中的JavaScript。
   本章的重点可以总结如下。要包含外部JavaScript文件，必须将src属性设置为要包含文件的URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。所有<script>元素会依照它们在网页中出现的次序被解释。在不使用defer和async属性的情况下，包含在<script>元素中的代码必须严格按次序解释。对不推迟执行的脚本，浏览器必须解释完位于<script>元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常应该把<script>元素放到页面末尾，介于主内容之后及</body>标签之前。
   可以使用defer属性把脚本推迟到文档渲染完毕后再执行。推迟的脚本总是按照它们被列出的次序执行。可以使用async属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。
   通过使用<noscript>元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则<noscript>元素中的任何内容都不会被渲染。
```

```
	JavaScript的核心语言特性在ECMA-262中以伪语言ECMAScript的形式来定义。ECMAScript包含所有基本语法、操作符、数据类型和对象，能完成基本的计算任务，但没有提供获得输入和产生输出的机制。理解ECMAScript及其复杂的细节是完全理解浏览器中JavaScript的关键。
	下面总结一下ECMAScript中的基本元素。ECMAScript中的基本数据类型包括Undefined、Null、Boolean、Number、String和Symbol。与其他语言不同，ECMAScript不区分整数和浮点值，只有Number一种数值数据类型。Object是一种复杂数据类型，它是这门语言中所有对象的基类。严格模式为这门语言中某些容易出错的部分施加了限制。
	ECMAScript提供了C语言和类C语言中常见的很多基本操作符，包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值操作符等。这门语言中的流控制语句大多是从其他语言中借鉴而来的，比如if语句、for语句和switch语句等。			ECMAScript中的函数与其他语言中的函数不一样。不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。不指定返回值的函数实际上会返回特殊值undefined。
```

### 区分大小写：

```
首先要知道的是，ECMAScript中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。换句话说，变量test和变量Test是两个不同的变量。类似地，typeof不能作为函数名，因为它是一个关键字（后面会介绍）。但Typeof是一个完全有效的函数名。
```

### 标识符：

```
  	所谓标识符，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：第一个字符必须是一个字母、下划线（_）或美元符号（$）；剩下的其他字符可以是字母、下划线、美元符号或数字。
注意关键字、保留字、true、false和null不能作为标识符。
```

### 注释：

```
单行注释：块注释以一个斜杠和一个星号（/*）开头，以它们的反向组合（*/）结尾
多行注释：/*这是多行注释*/
```

### 严格模式：

```
	严格模式是一种不同的JavaScript解析和执行模型，ECMAScript 3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行："usestrict"; 
	所有现代浏览器都支持严格模式。
```

### 语句：

```
ECMAScript中的语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾
	if之类的控制语句只在执行多条语句时要求必须有代码块。不过，最佳实践是始终在控制语句中使用代码块，即使要执行的只有一条语句
	在控制语句中使用代码块可以让内容更清晰，在需要修改代码时也可以减少出错的可能性。
```

### 变量：

```
	每个变量只不过是一个用于保存任意值的命名占位符。有3个关键字可以声明变量：var、const和let。其中，var在ECMAScript的所有版本中都可以使用，而const和let只能在ECMAScript 6及更晚的版本中使用。
	
var关键字：
	要定义变量，可以使用var操作符（注意var是一个关键字），后跟变量名（即标识符，如前所述）：varmessage;
	var声明作用域：使用var操作符定义的变量会成为包含它的函数的局部变量。比如，使用var在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁
	在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出ReferenceError。
	 var声明提升：使用var时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部
	---------------------------------------------------------------
let声明：
	let跟var的作用差不多，但有着非常重要的区别。最明显的区别是，let声明的范围是块作用域，而var声明的范围是函数作用域。let也不允许同一个块作用域中出现冗余声明。这样会导致报错
对声明冗余报错不会因混用let和var而受影响。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。
====================================================
	暂时性死区let与var的另一个重要的区别，就是let声明的变量不会在作用域中被提升。
====================================================
	全局声明与var关键字不同，使用let在全局作用域中声明的变量不会成为window对象的属性（var声明的变量则会）。
	let声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。
	
	 条件声明在使用var声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。因为let的作用域是块，所以不可能检查前面是否已经使用let声明过同名变量，同时也就不可能在没有声明的情况下声明它。
	 使用try/catch语句或typeof操作符也不能解决，因为条件块中let声明的作用域仅限于该块。
------------------------------------------------------------------	 
	 for循环中的let声明在let出现之前，for循环定义的迭代变量会渗透到循环体外部
------------------------------------------------------------------ 
	 const声明：
	 const的行为与let基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改const声明的变量会导致运行时错误。
	 const声明的限制只适用于它指向的变量的引用。换句话说，如果const变量引用的是一个对象，那么修改这个对象内部的属性并不违反const的限制。
	 即使JavaScript引擎会为for循环中的let声明分别创建独立的变量实例，而且const变量跟let变量很相似，也不能用const来声明迭代变量（因为迭代变量会自增）

总结：1. 不使用var有了let和const，大多数开发者会发现自己不再需要var了。限制自己只使用let和const有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。2. const优先，let次之使用const声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用const来声明变量，只在提前知道未来会有修改时，再使用let。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。
```

# 2.数据类型：

```
ECMAScript有6种简单数据类型（也称为原始类型）
	Undefined、Null、Boolean、Number、String和Symbol。Symbol（符号）是ECMAScript 6新增的。
	还有一种复杂数据类型叫Object（对象）。Object是一种无序名值对的集合。因为在ECMAScript中不能定义自己的数据类型，所有值都可以用
```

### typeof操作符：

```
	因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。typeof操作符就是为此而生的。对一个值使用typeof操作符会返回下列字符串之一
	"undefined"表示值未定义；"boolean"表示值为布尔值；"string"表示值为字符串；"number"表示值为数值；"object"表示值为对象（而不是函数）或null；"function"表示值为函数；"symbol"表示值为符号。
	注意typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用typeofnull返回的是"object"。这是因为特殊值null被认为是一个对空对象的引用。
	函数在ECMAScript中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过typeof操作符来区分函数和其他对象。
```

### 操作符：

```
	描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。
	一元操作符只操作一个值的操作符叫一元操作符（unary operator）。一元操作符是ECMAScript中最简单的操作符。
	递增/递减操作符递增和递减操作符直接照搬自C语言，但有两个版本：前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。前缀递增操作符会给数值加1，把两个加号（++）放到变量前头即可
	================================
	一元加和减一元加和减操作符对大多数开发者来说并不陌生，它们在ECMAScript中跟在高中数学中的用途一样。一元加由一个加号（+）表示，放在变量前头，对数值没有任何影响：如果将一元减应用到非数值，则会执行与使用Number()转型函数一样的类型转换：布尔值false和true转换为0和1，字符串根据特殊规则进行解析，对象会调用它们的valueOf()和/或toString()方法以得到可以转换的值。
```

### if语句：

```
		这里的条件（condition）可以是任何表达式，并且求值结果不一定是布尔值。ECMAScript会自动调用Boolean()函数将这个表达式的值转换为布尔值。如果条件求值为true，则执行语句statement1；如果条件求值为false，则执行语句statement2。这里的语句可能是一行代码，也可能是一个代码块（即包含在一对花括号中的多行代码）。
```

### do-while语句：

```
do-while语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。
```

### while语句：

```
	while语句是一种先测试：循环语句，即先检测退出条件，再执行循环体内的代码。因此，while循环体内的代码有可能不会执行。
```

### for语句：

```
	for语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式
```

### for-in语句：

```
	for-in语句是一种严格的迭代语句，用于枚举对象中的非符号键属性			ECMAScript中对象的属性是无序的，因此for-in语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。如果for-in循环要迭代的变量是null或undefined，则不执行循环体。
```

### for-of语句：

```
for-of语句是一种严格的迭代语句，用于遍历可迭代对象的元素
for-of循环会按照可迭代对象的next()方法产生值的顺序迭代元素。关于可迭代对象
```

### 标签语句：

```
	标签语句用于给语句加标签，语法如下：label:statement下面是一个例子：start:for(leti=0;i<count;i++){console.log(i);}在这个例子中，start是一个标签，可以在后面通过break或continue语句引用。标签语句的典型应用场景是嵌套循环。
```

### break和continue语句：

```
	break和continue语句为执行循环代码提供了更严格的控制手段。其中，break语句用于立即退出循环，强制执行循环后的下一条语句。而continue语句也用于立即退出循环，但会再次从循环顶部开始执行。
	outermost标签标识的是第一个for语句。正常情况下，每个循环执行10次，意味着num++语句会执行100次，而循环结束时console.log的结果应该是100。但是，break语句带来了一个变数，即要退出到的标签。添加标签不仅让break退出（使用变量j的）内部循环，也会退出（使用变量i）的外部循环。当执行到i和j都等于5时，循环停止执行，此时num的值是55。continue语句也可以使用标签
	
	组合使用标签语句和break、continue能实现复杂的逻辑，但也容易出错。注意标签要使用描述性强的文本，而嵌套也不要太深。
```

### with语句：

```
	ith语句的用途是将代码作用域设置为特定的对象，其语法是：with(expression)statement;使用with语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利
	with语句用于连接location对象。这意味着在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索location对象，看它是否有一个同名的属性。如果有，则该变量会被求值为location对象的属性。
	
	严格模式不允许使用with语句，否则会抛出错误。
```

### switch语句：

```
	switch语句是与if语句紧密相关的一种流控制语句，从其他语言借鉴而来。ECMAScript中switch语句跟C语言中switch语句的语法非常相似
	switch(expression){casevalue1:statementbreak;casevalue2:statementbreak;casevalue3:statementbreak;casevalue4:statementbreak;default:statement}
	
	为避免不必要的条件判断，最好给每个条件后面都加上break语句。如果确实需要连续匹配几个条件，那么推荐写个注释表明是故意忽略了break
```

### 函数：

```
	函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript中的函数使用function关键字声明，后跟一组参数，然后是函数体。
	
	基本语法：functionfunctionName(arg0,arg1,...,argN){statements}
	
	可以通过函数名来调用函数，要传给函数的参数放在括号里（如果有多个参数，则用逗号隔开）。
	ECMAScript中的函数不需要指定是否返回值。任何函数在任何时间都可以使用return语句来返回函数的值，用法是后跟要返回的值。
	要注意的是，只要碰到return语句，函数就会立即停止执行并退出。因此，return语句后面的代码不会被执行。
	
	严格模式对函数也有一些限制：函数不能以eval或arguments作为名称；函数的参数不能叫eval或arguments；两个函数的参数不能叫同一个名称。如果违反上述规则，则会导致语法错误，代码也不会执行。
```

### 小结：

```
	JavaScript的核心语言特性在ECMA-262中以伪语言ECMAScript的形式来定义。ECMAScript包含所有基本语法、操作符、数据类型和对象，能完成基本的计算任务，但没有提供获得输入和产生输出的机制。理解ECMAScript及其复杂的细节是完全理解浏览器中JavaScript的关键。下面总结一下ECMAScript中的基本元素。ECMAScript中的基本数据类型包括Undefined、Null、Boolean、Number、String和Symbol。
	与其他语言不同，ECMAScript不区分整数和浮点值，只有Number一种数值数据类型。Object是一种复杂数据类型，它是这门语言中所有对象的基类。严格模式为这门语言中某些容易出错的部分施加了限制。ECMAScript提供了C语言和类C语言中常见的很多基本操作符，包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值操作符等。这门语言中的流控制语句大多是从其他语言中借鉴而来的，比如if语句、for语句和switch语句等。ECMAScript中的函数与其他语言中的函数不一样。不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。不指定返回值的函数实际上会返回特殊值undefined。
```

# 3.变量、作用域与内存：

### 原始值与引用值：

```
	变量可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是最简单的数据，引用值（referencevalue）则是由多个值构成的对象。
	引用值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。
	只有引用值可以动态添加后面可以使用的属性。
	原始类型的初始化可以只使用原始字面量形式。如果使用的是new关键字，则JavaScript会创建一个Object类型的实例，但其行为类似原始值。
```

### 复制值：

```
	把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来
```

### 传递参数：

```
	ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。
	ECMAScript中函数的参数就是局部变量。
```

### 确定类型：

```
	typeof操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或undefined的最好方式。如果值是对象或null，那么typeof返回"object"，
	-------------------------------------------------------------------------------------------------
	typeof虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript提供了instanceof操作符
				result=variableinstanceofconstructor
-------------------------------------------------------------------------------------
	typeof操作符在用于检测函数时也会返回"function"。当在Safari（直到Safari 5）和Chrome（直到Chrome 7）中用于检测正则表达式时，由于实现细节的原因，typeof也会返回"function"。ECMA-262规定，任何实现内部[[Call]]方法的对象都应该在typeof检测时返回"function"。因为上述浏览器中的正则表达式实现了这个方法，所以typeof对正则表达式也返回"function"。在IE和Firefox中，typeof对正则表达式返回"object"。
```

### 执行上下文与作用域：

```
	执行上下文（以下简称“上下文”）的概念在JavaScript中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object）
	每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。
	上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。
	代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activationobject）用作变量对象。
	函数changeColor()的作用域链包含两个对象：一个是它自己的变量对象（就是定义arguments对象的那个），另一个是全局上下文的变量对象。这个函数内部之所以能够访问变量color，就是因为可以在作用域链中找到它。
	函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。
```

# 第5章基本引用类型

```
理解对象:引用值或对象是某个特定引用类型的实例，在ECMASscipt中，引用类型是吧数据和功能组织到一起的结构，经常被人错误的称作为“类”。引用类型虽然有点像类，但跟类并不是一个概念。
```

### Date：

```
	第一点要创建日期对象，就使用new操作符来调用Date构造函数，
	第二点在不给Date构造函数传参数的情况下，创建的对象将保存当前日期和时间。
	Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。
	Date.parse()应该支持的日期格式，填充了第3版遗留的空白。所有实现都必须支持下列日期格式
	注意：ISO 8601扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如2019-05-23T00:00:00（只适用于兼容ES5的实现）。
	如果传给Date.parse()的字符串并不表示日期，则该方法会返回NaN。如果直接把表示日期的字符串传给Date构造函数，那么Date会在后台调用Date.parse()。
	
	继承的方法：
	Date类型的toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间。
```

### 日期格式化方法：

```
Date类型有几个专门用于格式化日期的方法，它们都会返回字符串:
toDateString()显示日期中的周几、月、日、年（格式特定于实现）；
toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）；
toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）；
toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现）；
toUTCString()显示完整的UTC日期（格式特定于实现）。
------------------------
还有一个方法叫toGMTString()，这个方法跟toUTCString()是一样的，目的是为了向后兼容。不过，规范建议新代码使用toUTCString()。
```

#### 获取日期对象的方法

   -    getFullYear()	从 Date 对象以四位数字返回年份。
        - getMonth()	从 Date 对象返回月份 (0 ~ 11)。
        - getDate()	从 Date 对象返回一个月中的某一天 (1 ~ 31)。
        - getDay()	从 Date 对象返回一周中的某一天 (0 ~ 6)。 
        - getHours()	返回 Date 对象的小时 (0 ~ 23)。
        - getMinutes()	返回 Date 对象的分钟 (0 ~ 59)。
        - getSeconds()	返回 Date 对象的秒数 (0 ~ 59)。 
        - getMilliseconds()	返回 Date 对象的毫秒(0 ~ 999)。 煤勒赛啃滋
        - getTime()	 返回 1970 年 1 月 1 日 至今的毫秒数。

​     

#### 设置日期对象的方法

   - setFullYear()	设置 Date 对象中的年份（四位数字）。
   - setMonth()	设置 Date 对象中月份 (0 ~ 11)。
   - setDate()	设置 Date 对象中月的某一天 (1 ~ 31)。
   - setHours()	设置 Date 对象中的小时 (0 ~ 23)。
   - setMinutes()	设置 Date 对象中的分钟 (0 ~ 59)。
   - setSeconds()	设置 Date 对象中的秒钟 (0 ~ 59)。
   - setMilliseconds()	设置 Date 对象中的毫秒 (0 ~ 999)。
   - setTime() 方法以毫秒设置 Date 对象。

#### 日期对象转换为字符串的方法

   - toLocaleString()	   据本地时间格式，把 Date 对象转换为字符串。
   - toString()	          把 Date 对象转换为字符串。

#### 定时器 

```
setInterval()  //间歇调用；就是每隔一段时间调用一次-间隙性计时器
   // 按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。
<<<<<<< HEAD

    setTimeout()   //延迟调用；指定的时间后调用一次，只调用一次   在指定的毫秒数后调用函数或计算表达式。一次性计时器    
    
    清除计时器的方法
        clearInterval("要清除的定时器名")
        clearTimeout("要清除的定时器名")

    语法：setInterval(code,millisec,lang)     
		 setTimeout(code,millisec,lang)
   code	    //必需。要调用的函数或要执行的代码串。
   millisec	//必须。周期性执行或调用 code 之间的时间间隔，以毫秒计。
   lang	    //可选。 JScript | VBScript | JavaScript
```



### 正则：

#### -- 基本概念

- 字符串匹配，查询，替换的一种模式，外表风骚，内功强大。
- 表达式的结构
- 正则表达式结构/修饰符` 比如 `/\d{12}/g`
- g 全局匹配 global  hello world
- i 忽略大小写 ignore

### -- 正则的创建方法

字面量方式 

```
var rep = /^1[34578]\d{9}$/
```

构造函数形式

```
 var rep = new RegExp("表达式","修饰符")
 //比如下面匹配一个手机号
 var rep = new RegExp("^1[34578]\d{9}$");
```

JS 字符串中可以使用正则表达式的三个函数

```js
 string.replace("正则表达式","要替换的对象")
 string.match("正则表达式")
 string.search("正则表达式")
```

test方法（用来验证）

```js
  var rep = /正则表达式/g
  rep.test(要验证的字符串); //结构返回true或者false
```

exec方法（用来验证）

```js
var rep = /正则表达式/g
rep.test(要验证的字符串) //结构返回true或false
```

常用的元字符：

```js
 [abc] //匹配方框号中的任意一个字符
            [^abc] //除了abc以外的所有的字符
            [0-9] //匹配0-9之间数字
            [a-z] //匹配所有的大写字母
            [0-9a-zA-Z] //匹配大小写字母和数字
            [A-z] //匹配所有的大小写字母  [A-Za-z]
            (红色|蓝色|绿色)  //匹配红色，蓝色绿色
            [\u4e00-\u9fa5] //中文汉字
             
            .  //匹配任意字符
            \w //匹配任意字母数字下划线 或 [A-Za-z0-9_]
            \W //匹配非字母数字下划线
            \d //匹配所有数字  [0-9]
            \D //匹配非数字
            \s //匹配空格字符
            \S //匹配非空格字符
```

常用的(写好的)

```js
   1.只能是中文 长度为2-7位
		 /^([\u4e00-\u9fa5]){2,7}$/
        2.长度为8到18位的小写大写字母或数字或下划线 【重要】
            /^[a-zA-Z0-9_]{8,18}$/
        3.正确的邮箱格式 【重要】
            /^\w+@[a-z0-9]{2,5}\.(com|cn|net|org)$/
            /^[A-z0-9_-]+@[a-z0-9]{2,5}\.[a-z]{2,3}$/
        4.正确的手机号【重要】
            /^1(3|4|5|7|8)\d{9}$/
        5.正确的身份证号:
            /^\d{15}|\d{17}([0-9]|x)/
            /^[1-9][0-9]{16}[0-9x]$/
        6.正确的qq号
            /[1-9][0-9]{4,}/
        7.正确的电话号码格式 【重要】
            /^0[0-9]{2}-[0-9]{8}|0[0-9]{3}-[0-9]{7}$/
            
        8. 过滤空白 /\s+/g
        9. 过滤首尾空格  str.trim()
        10. 匹配任意8-18之间的大小写字母数字构成的密码
            /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,18}$/
```

# 第六章

## 1.1 Object
<<<<<<< HEAD

### 1.1.1 new操作符

=======

### 1.1.1 new操作符

>>>>>>> remotes/teachter/master
``` js
let person = new Object(); 
person.name = "Nicholas"; 
person.age = 29;
<<<<<<< HEAD
```

### 1.1.2 对象字面量

对象字面量是对象定义的简写形式，目的是为了简化包含大量属性的对象的创建。

``` js
let person = { 
    name: "Nicholas", 
    age: 29 
};
```

也可以使用字符串、数字、bool类型来定义。

``` js
let person = { 
    "name": "Nicholas", 
    "age": 29, 
    5: true,
	true: 123,
    false: 321
};
person[5];	//true
person[true];	//123
person[false];	//321
```

但要注意此类情况（后值覆盖前值）：

``` js
let person = { 
    "name": "Nicholas", 
    "age": 29, 
    5: true,
	true: 123,
    true: 555,
    name: 'jack'
};
// 最后person变为
{
    5: true, 
    name: "jack", 
    age: 29, 
    true: 555
}
```

**思考：**

``` js
let person = {
    5:15,
    true: 'yes',
    false: 'no'
};
person.5;	// ?
person.true;	// ?
person.false;	// ?

person.__proto__ === ?;
person.__proto__.constructor === ?;

let person = new Object();
person.__proto__ === ?;
person.__proto__.constructor === ?;
```

### 1.1.3 访问/设置方式

> **点语法**

``` js 
let person = { 
	"name": "Nicholas", 
	"age": 29, 
	5: true,
	true: 123
};
person.name;	//"Nicholas"
person.age;		//29
person.name = 'jack';
person.age = 30;
person.true;	//对吗？
person.5;	//对吗？
```

> **中括号**

``` js
let person = { 
	"name": "Nicholas", 
	"age": 29, 
	5: true,
	true: 123
};
person['name'];	//"Nicholas"
person['age'];		//29
person['name'] = 'jack';
person['age'] = 30;
person[true];	//对吗？
person[5];	//对吗？
```

**思考：可以这样定义吗？如果可以，那么怎么访问name属性值呢？**

``` js
let name = {
    firstName: '张',
    lastName: '三'
};
let person = {
    [name]: '张三'
}
```

## 1.2 Array

### 1.2.1 Array构造函数

``` js
let colors = new Array();	//表示创建一个空数组
colors.length;	//0

let colors = new Array(5);	//表示创建一个长度为5的空数组
colors.length;	//5
colors[0];	//undefined
let colors = Array(5); //不用new也可以

let colors = new Array("red", "blue", "green");	//表示创建一个数组，并传入三个值
colors.length;	//3
colors[0];	//"red"
let names = Array("Greg"); //不用new也可以
```

**思考：**

``` js
let colors = new Array(3);
colors[0];	//？
colors.length;	//？
```

### 1.2.2 数组字面量

``` js
let colors = ["red", "blue", "green"]; // 创建一个包含3个元素的数组
let names = []; // 创建一个空数组
let values = [1,2,]; // 创建一个包含2个元素的数组
let ages = [,,,];	//创建一个包含3个三个空元素的数组
colors.length = 2;	//改变数组长度
colors[2];	//undefined
```

**思考：**

``` js
let cars = [1,2,,,];
cars.length;	//?

let cats = [1,2,,,5];
cats.length;	//?
cats[cats.length - 1];	//?

let dogs = [1,2,3];
dogs.length = 5;
dogs.length;	//?
dogs[dogs.length - 1];	//?
```

### 1.2.3 Array.from

第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性和可索引元素的结构。

``` js
// 字符串会被拆分为单字符数组 
console.log(Array.from("Matt")); // ["M", "a", "t", "t"]

// 可以使用from()将集合和映射转换为一个新数组
const s = new Set().add(1).add(2).add(3).add(4);
console.log(Array.from(s)); // [1, 2, 3, 4]

// Array.from()对现有数组执行浅复制
const a1 = [1, 2, 3, 4]; 
const a2 = Array.from(a1);
console.log(a1); // [1, 2, 3, 4]
a1 === a2; // false
a2.push(5);
a1.length;	//?

// arguments对象可以被轻松地转换为数组
function getArgsArray() { 
    return Array.from(arguments); 
}
console.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4]

// from()也能转换带有必要属性的自定义对象
const arrayLikeObject = { 0: 1, 1: 2, 2: 3, 3: 4, length: 4 };
console.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4]

//没有length的对象不行，因为会将0,1,2,3当做对象的key，而不当做是下标
const arrayLikeObject = { 0: 1, 1: 2, 2: 3, 3: 4 };
console.log(Array.from(arrayLikeObject)); // []
```

**思考：**

``` js
const arrayLikeObject = { 3: 1, 1: 2, 2: 3, 0: 4,length:4 };	//下标打乱顺序
console.log(Array.from(arrayLikeObject)); //?

const arrayLikeObject = { 3: 1, 1: 2, 2: 3, 0: 4,length:6 };	//长度多了2
console.log(Array.from(arrayLikeObject)); //?

const arrayLikeObject = { 3: 1, 1: 2, 2: 3, 0: 4,length:2 };	//长度只有2
console.log(Array.from(arrayLikeObject)); //?

//转换一个没有length的对象
const arrayLikeObject = { a:1, b:2 };
console.log(Array.from(arrayLikeObject)); //?

//转换一个有length的对象
const arrayLikeObject = { a:1, b:2, length:3 };
console.log(Array.from(arrayLikeObject)); //?
```

### 1.2.4 Array.of

`Array.of() `可以把一组参数转换为数组。这个方法用于替代在ES6之前常用的`Array.prototype.slice.call(arguments)`。

``` js
console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4] 
console.log(Array.of(undefined)); // [undefined]
```

### 1.2.5 检测数组

``` js
[] instanceof Array;	// true
Array.isArray([]);	//true
```

思考：

``` js
(new Array() instanceof Array);	//?
(Array.isArray(new Array()));	//?
```

### 1.2.6 fill

使用`fill()`方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。

[^负值索引]: 负值索引从数组末尾开始计算，也可以将负索引想象成数组长度加上它得到的一个正索引（如果长度减去负索引还是得到负数，索引则从0开始）。

``` js
const zeroes = [0, 0, 0, 0, 0]; // 用5填充整个数组
zeroes.fill(5);
console.log(zeroes); // [5, 5, 5, 5, 5]

// 用6填充索引大于等于3的元素
zeroes.fill(0); // 重置
zeroes.fill(6, 3); 
console.log(zeroes); // [0, 0, 0, 6, 6]

// 用7填充索引大于等于1且小于3的元素
zeroes.fill(0); // 重置
zeroes.fill(7, 1, 3);
console.log(zeroes); // [0, 7, 7, 0, 0];

// 用8填充索引大于等于1且小于4的元素
// (-4 + zeroes.length = 1)
// (-1 + zeroes.length = 4)
zeroes.fill(8, -4, -1); 
console.log(zeroes); // [0, 8, 8, 8, 0];
```

> **`fill()`静默忽略超出数组边界、零长度及方向相反的索引范围**

[^fill()]: 注解如下：

``` js
const zeroes = [0, 0, 0, 0, 0]; 
zeroes.fill(1, -10, -6);	// 索引过低，忽略
console.log(zeroes); // [0, 0, 0, 0, 0] 
zeroes.fill(1, 10, 15);		// 索引过高，忽略
console.log(zeroes);	// [0, 0, 0, 0, 0] 
zeroes.fill(2, 4, 2);	// 索引反向，忽略
console.log(zeroes); // [0, 0, 0, 0, 0]
zeroes.fill(4, 3, 10);	// 索引部分可用，填充可用部分 
console.log(zeroes); 	// [0, 0, 0, 4, 4]
```

**思考：**

``` js
const zeroes = [0, 0, 0, 0, 0]; 
zeroes.fill(1, -10, -1);
console.log(zeroes);	//?

const zeroes = [0, 0, 0, 0, 0]; 
zeroes.fill(1, -10, 20);
console.log(zeroes);	//?
```

### 1.2.7 copyWithin

`copyWithin()`会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与`fill()`使用同样的计算方法。

``` js
let ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
// 从ints中复制索引0开始的内容，插入到索引5开始的位置
// 在源索引或目标索引到达数组边界时停止
ints.copyWithin(5); 
console.log(ints); // [0, 1, 2, 3, 4, 0, 1, 2, 3,4]

let ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
// 从ints中复制索引5开始的内容，插入到索引0开始的位置
ints.copyWithin(0, 5); 
console.log(ints); // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]

let ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
// 从ints中复制索引大于0并且小于3的内容
// 插入到索引4开始的位置
ints.copyWithin(4, 0, 3); 
console.log(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]

let ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
ints.copyWithin(2, 0, 6); 
console.log(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]

// 支持负索引值，与fill()相对于数组末尾计算正向索引的过程是一样的
let ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
ints.copyWithin(-4, -7, -3); 
console.log(ints); // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]
```

> **静默忽略超出数组边界、零长度及方向相反的索引范围（同[^fill()]方法一样）**

### 1.2.8 reverse

严格意义上来讲，`reverse`不是排序方法，它只是数组颠倒方法，可以将数组的顺序颠倒过来。

``` js
// 书中的例子，只是作为反向排序讲解，不够全面
let values = [1, 2, 3, 4, 5]; 
values.reverse();
console.log(values); // [5,4,3,2,1]

let numbers = [5,1,2,6,3];
numbers.reverse();
console.log(numbers); // [3, 6, 2, 1, 5]

let chars = ['c','b','d','a','w'];
chars.reverse();
console.log(chars); // ["w", "a", "d", "b", "c"]

let objs = [{a:1}, {a:5}, {a:3}];
objs.reverse();
console.log(objs);	// [{a:3},{a:5},{a:1}]
```

### 1.2.9 sort

`sort()`方法可以接收一个比较函数，用于判断哪个值应该排在前面。比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回0；如果第一个参数应该排在第二个参数后面，就返回正值。

``` js
let values = [0, 1, 5, 10, 15];
values.sort();	// 不传比较函数出来的结果是不正常的
console.log(values); // 0,1,10,15,5

let values = [15, 1, 10, 5, 0];
values.sort(function (value1, value2) {
    if (value1 < value2) {
        return -1;
    }
    else if (value1 > value2) {
        return 1;
    }
    return 0;
});
console.log(values); // 0,1,5,10,15

//使用箭头函数简写
let values = [15, 1, 10, 5, 0];
values.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
console.log(values); // 0,1,5,10,15

//最简单的方法
let values = [15, 1, 10, 5, 0];
values.sort((a, b) => a - b);
console.log(values); // 0,1,5,10,15
```

**思考：**

``` js
let values = [15, 1, 10, 5, 0];
//使用function的方式写一个反向排序方法

//使用箭头函数简写
let values = [15, 1, 10, 5, 0];
//使用箭头函数简写的方式写一个反向排序方法

//最简单的方法
let values = [15, 1, 10, 5, 0];
//使用最简单的方法写一个反向排序方法
```

### 1.2.10 concat

`concat()`方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。

``` js
let colors = ["red", "green", "blue"]; 
let colors2 = colors.concat("yellow", ["black", "brown"]); 
console.log(colors); // ["red", "green","blue"]
console.log(colors2); // ["red", "green", "blue", "yellow", "black", "brown"]

//不能添加第二层的数据
let colors = ["red", "green", "blue"]; 
let colors2 = colors.concat("yellow", ["black", "brown"],"aaa",["bbb",'ccc', ['a','b',['c']]]);
console.log(colors2);	//["red", "green", "blue", "yellow", "black", "brown", "aaa", "bbb", "ccc", Array(3)]
```

### 1.2.11 slice

`slice()`用于创建一个包含原有数组中一个或多个元素的新数组。`slice()`方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则 `slice()`会返回该索引到数组末尾的所有元素。如果有两个参数，则`slice()` 返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。

``` js
let colors = ["red", "green", "blue", "yellow", "purple"]; 
let colors2 = colors.slice(1); 
let colors3 = colors.slice(1, 4);
console.log(colors2);	// ["green", "blue", "yellow", "purple"
console.log(colors3);	// ["green", "blue", "yellow"]
console.log(colors);	// ["red", "green", "blue", "yellow", "purple"]
```

> - `slice()`的[^负值索引]跟`fill()`负值索引计算方式一样。
>
> - 静默忽略超出数组边界、零长度及方向相反的索引范围也跟[^fill()]方法的一样。

**思考：**

``` js
let numbers = [1,2,3,4,5];
console.log(numbers.slice(-5));		//?
console.log(numbers.slice(-5,-1));	//?
console.log(numbers.slice(-30));	//?
console.log(numbers.slice(-3,-5));	//?
```

### 1.2.12 splice

`splice()`是个非常强大的方法，可删除，替换，增加（**需非常熟悉**）。

- **删除**

  需要给 `splice()` 传2个参数：要删除的第一个元素的位置和要删除的元素数量。从原数组中删除任意多个元素，并返回一个数组，返回的数组包含删除的项。比如`splice(0, 2)` 会删除原数组前两个元素，并返回一个数组，数组中包含前两个已删除的项。

  ``` js
  let colors = ["red", "green", "blue"]; 
  let removed = colors.splice(0,1); // 删除第一项，并将第一项返回
  console.log(colors);	// ["green", "blue"]
  console.log(removed);	// ["red"]
  
  let colors = ["red", "green", "blue"]; 
  let removed = colors.splice(-3);
  console.log(colors);	// []
  console.log(removed);	// ["red", "green", "blue"]
  
  let colors = ["red", "green", "blue"]; 
  let removed = colors.splice(-3,2);
  console.log(colors);	// ["blue"]
  console.log(removed);	// ["red", "green"]
  ```

- **插入**

  需要给 `splice()` 传3个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。比如，`splice(2, 0, "red", "green")` 会从数组位置2开始插入字符串 "red" 和 "green" 。

  ``` js
  let colors = ["red", "green", "blue"]; 
  let removed = colors.splice(1, 0, "yellow", "orange"); // 在位置1插入两个元素
  console.log(colors);	// ["red", "yellow", "orange", "green", "blue"]
  console.log(removed);	// []
  ```

- **替换**

  `splice()` 在删除元素的同时可以在指定位置插入新元素，样要传入3个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。比如，`splice(2, 1, "red", "green")` 会在位置2删除一个元素，然后从该位置开始向数组中插入 "red" 和 "green"。

  ``` js
  let colors = ["red", "green", "blue"]; 
  let removed = colors.splice(1, 1, "red", "purple"); // 插入两个值，删除一个元素
  console.log(colors);	// ["red", "red", "purple", "blue"]
  console.log(removed);	// ["green"]
  ```

  **思考：**

  ```   js
  let colors = ["red", "green", "blue"];
  //写一个方法将colors所有的内容清空并替换为["yellow", "white"]
  ```

### 1.2.13 寻找下标

- **indexOf**

  从左到右搜索第一个===的下标。

  ``` js
  [1,2,3].indexOf(1);	// 0
  [1,2,3].indexOf('1');	// -1，因为不全等，找不到就返回-1
  [1,2,3,1,5,6].indexOf(1, 2);	// 3，第二个参数是从x下标开始搜索
  ```

- **lastIndexOf**

  从右往左搜索第一个===的下标。

  ``` js
  [1,2,3,1,5,7].lastIndexOf(1);	// 3
  [1,2,3,1,5,7,1,5].lastIndexOf(1, 100);	// 6 第二个参数是从x下标开始搜索
  [1,2,3,1,5,7,1,5].lastIndexOf(1, 5);	// 3
  ```

**思考：**

``` js
[1,2,3,1,5,6].indexOf(1, -2);	// ?
[1,2,3,1,5,6].indexOf(1, -3);	// ?   
[1,2,3,1,5,7,1,5].lastIndexOf(1, -7);	// ?
[1,2,3,1,5,7,1,5].lastIndexOf(1, -5);	// ? 3
```

### 1.2.14 includes

判断数组内是否有===的项。

``` js
[1,2,3,4,5,6].includes(1);	// true
[1,2,3,4,5,6].includes('1');	// false，因为不全等
[1,2,3,4,5,6].includes(8);	// false
```

### 1.2.15 find

根据条件查找数组内的单个项，根据条件查找项，只要返回true那就证明找到了，如果为false的话，那就继续遍历查找。

``` js
[1,2,3].find(c=> c === 1);	// 1
[1,2,3].find(c=> c == '1');	// 1
[1,2,3].find(c=> c === 5);	// undefined
[1,2,3].find(c=> c > 1);	// 2

const people = [{
    name: "Matt",
    age: 27
},
{
    name: "Nicholas",
    age: 29
}];
//三个参数分别是：当前遍历的项、当前下标、原始数组。
let p = people.find((element, index, array) => {
    console.log(element, index, array);
    return element.age > 28;
});
console.log(p);		// {name: "Nicholas", age: 29}
```

### 1.2.16 findIndex

根据条件查找数组内匹配项的下标。

``` js
[1,2,3].findIndex(c=> c === 3);	// 2
[1,2,3].findIndex(c=> c === 5);	// -1
[1,2,3].findIndex(c=> c > 1);	// 1
```

### 1.2.17 every

验证数组内每一个项是否匹配。

``` js
[1,2,3].every(c=> c === 3);	// false
[1,2,3].every(c=> c > 0);	// true
[1,2,3].every(c=> c < 10);	// true
[1,1,1].every(c=> c === 1);	// true
[1, 2, 3, 4, 5, 4, 3, 2, 1].every((item, index, array) => item > 2);    // false
```

### 1.2.18 some

验证数组内某一个项是否匹配。

``` js
[1,2,3].some(c=> c === 3);	// true
[1,2,3].some(c=> c > 0);	// true
[1,2,3].some(c=> c < 10);	// true
[1,1,1].some(c=> c === 1);	// true
[1,2,3].some(c=> c === 5);	// false
[1, 2, 3, 4, 5, 4, 3, 2, 1].some((item, index, array) => item > 2);     // true
```

### 1.2.19 filter

创建一个新数组，根据条件将搜索匹配的项放入至新数组内，并将此数组返回。

``` js
[1,2,3].filter(c=> c > 1);	// [2,3]
[1,2,3].filter(c=> c > 5);	// []
[1,2,3].filter(c=> c === 3);	// [3]
[1, 2, 3, 4, 5, 4, 3, 2, 1].filter((item, index, array) => item > 2);	//[3, 4, 5, 4, 3]
```

### 1.2.20 forEach

遍历每一个数组，传入回调函数，可对每一个项进行操作（用`return`无法停止，会遍历完所有的项）。

``` js
[1, 2, 3].forEach(c => {
    console.log(c * 2);
});
// 2 4 6

[1, 2, 3].forEach((item, index, array) => {
    console.log(item * index);
});
// 0 2 6
```

**思考：**

``` js
let numbers = [{ a: 1 }, { a: 2 }, { a: 3 }];
numbers.forEach((item, index, array) => {
    if (item.a > 1) {
        item.a = index;
    }
});
console.log(numbers);	// ?
```

### 1.2.21 flat

将多维数组扁平化，并返回一个新数组。方法接受一个数值，表示要扁平化的数组维度。

``` js
let ary = [1, [2, [3, [4, 5]]], 6];
console.log(ary.flat(1));	// [1, 2, Array(2), 6]
console.log(ary.flat());	// [1, 2, Array(2), 6]，不传参默认为1
console.log(ary.flat(2));	// [1, 2, 3, Array(2), 6]
console.log(ary.flat(3));	// [1, 2, 3, 4, 5, 6]
console.log(ary.flat(100));	// [1, 2, 3, 4, 5, 6]，可以超过维度深度，超过则会扁平化所有维度
console.log(ary.flat(Infinity));	//无限大的层数，表示可以扁平化所有维度
console.log(ary);	// [1, Array(2), 6]
```

### 1.2.22 map

遍历数组，针对每一个项返回一个新值，将新值放进新数组里，最后将新数组返回。

``` js
[1, 2, 3].map(c => {
    return c * 2;
});	// [2,4,6]

[1, 2, 3].map(c => {
    return 2;
});	// [2,2,2]

[1, 2, 3].map((item, index, array) => {
    return item * index;
});	// [0,2,6]

[{ a: 1 }, { a: 2 }, { a: 3 }, { a: 4 }, { a: 5 }].map(c => c.a);	// [1, 2, 3, 4, 5]
```

**思考：**

``` js
[1, 2, 3].map((item, index, array) => {
    return index;
});	// ?

[1, 2, 3].map((item, index, array) => {
    return index * array.length;
});	// ?

let numbers =[{ a: 1 }, { a: 2 }, { a: 3 }, { a: 4 }, { a: 5 }];
//请使用map方法将numbers数据变为[3,6,9,12,15]

//请使用map方法将numbers数据变为[3,6,9,8,10]

let numbers = [{ a: 1, b: 10 }, { a: 2, b: 10 }, { a: 3, b: 10 }, { a: 4, b: 10 }, { a: 5, b: 10 }];
//请使用map方法将numbers数据变为[9,8,7,6,5]
```

### 1.2.23 join

数组拼接成字符串方法，方法传入拼接关键字。

``` js
[1,2,3].join(',');	// '1,2,3'
```

**思考：**

``` js
[{ a: 1 }, { a: 2 }].join(',');	// ?

let persons = [{ age: 50 }, { age: 12 }, { age: 30 }];
//请写一个方法将persons变为 '12,30,50'
```

### 1.2.24 pop

从原数组取出最后一个项。

``` js
let numbers = [1,2,3,4,5];
numbers.pop();	// 5
console.log(numbers);   // [1,2,3,4]

let empty = [];
empty.pop();	// undefined
console.log(empty);	// []
```

### 1.2.25 shift

从原数组取出第一个项。

``` js
let numbers = [1,2,3,4,5];
numbers.shift();    // 1
console.log(numbers);   // [2,3,4,5]
```

### 1.2.26 unshift

在原数组的头部添加随意数量的项，并返回添加后数组的长度。

``` js
let numbers = [1, 2, 3, 4, 5];
let length = numbers.unshift(7, 8, 9);
console.log(length);    // 8
console.log(numbers);   // [7, 8, 9, 1, 2, 3, 4, 5]
```

## 1.3 Set

Set是一个无法添加重复值的集合。

``` js
const set = new Set();	//创建一个空集合

const s1 = new Set(["val1", "val2", "val3"]);	// 使用数组初始化集合
console.log(s1.size);		// 3,长度访问跟数组的length不一样
s1.add("Matt").add("Frisbie");	//可以链式添加
s1.has('Matt');	// true，是否存在指定的项
console.log(s1);	// Set(5) {"val1", "val2", "val3", "Matt", "Frisbie"}
s1.add("Matt");
console.log(s1);	// Set(5) {"val1", "val2", "val3", "Matt", "Frisbie"}，无法添加重复项

let deleted = s1.delete('Matt');	// delete方法返回删除结果
console.log(deleted);   // true
console.log(s1);    // Set(4) {"val1", "val2", "val3", "Frisbie"}

deleted = s1.delete('Matt');
console.log(deleted);   // false，无法重复删除

//可通过for of访问每个项
for (let item of s1) {
    console.log(item);
}
//val1 val2  val3 Frisbie

//也可通过forEach方法访问
s1.forEach(item => console.log(item));
```

> **Set的经典应用-去重**

``` js
let numbers = [1, 2, 3, 5, 6, 1, 2, 3];
numbers = Array.from(new Set(numbers));
console.log(numbers);   // [1, 2, 3, 5, 6]
```

**思考：**

``` js
let chars = ['a', 'b', 'c', 'a', 'c', 'd'];
// 将chars去重
```

**作业：**

``` js
let objs = [{ count: 20 }, { count: 66 }, { count: 16 }, { count: 30 }, { count: 5 }, { count: 20 }, { count: 66 }];
//使用objs打印 "5,16,20,30,66"

//使用objs打印 "20,30,66"
```

# 第八章

## 第8章对象、类与面向对象编程

本章内容:

```
1理解对象
2理解对象创建过程
3理解继承
4理解类
```

### 理解对象

```
	举个栗子，比如一台笔记本电脑，我们将它视为一个对象无非是为了能够更加抽象地描述它，这在编程的过程中很重要，来看看它有哪些需要抽象出来的特性吧~
    在生活中大家应该很熟悉，当你在买一台新的笔记本电脑时，主要考虑的是什么？———笔记本电脑的屏幕大小、屏幕形状、机身总重量、硬盘空间、CPU频率、操作系统……这些都是“笔记本电脑”这个对象所固有的一些性能或制造的参数，这些可以标识出这台笔记本电脑是否受到顾客的欢迎。
    但是，对于现实世界中的一台洗衣机，要考虑的特性就完全不是上面的那些参数和特性了，更多的是会去关注它的容积、耗电量、噪音大小等。还有，对于一架航天飞机，它要考虑的特性会更多，对于一支钢笔，一把伞，针对它们要考虑的就会相对要少一些……从这些例子来看，世间万物的复杂程度不同，我们对它们的关心方面就不同，相应地从它们这些具体事物中抽象出的对象也会各有差别。
```

### 创建对象：

```js
	虽然使用Object构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：创建具有同样接口的多个对象需要重复编写很多代码。
	
1、 new 操作符 + Object 创建对象
var person = new Object();
    person.name = "lisi";
    person.age = 21;
    person.family = ["lida","lier","wangwu"];
    person.say = function(){
        alert(this.name);
    }

2、字面式创建对象
var person ={
        name: "lisi",
        age: 21,
        family: ["lida","lier","wangwu"],
        say: function(){
            alert(this.name);
        }
    };

3、工厂模式
function createPerson(name,age,family) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.family = family;
    o.say = function(){
        alert(this.name);
    }
    return o;
}

var person1 =  createPerson("lisi",21,["lida","lier","wangwu"]);   //instanceof无法判断它是谁的实例，只能判断他是对象，构造函数都可以判断出
var person2 =  createPerson("wangwu",18,["lida","lier","lisi"]);
console.log(person1 instanceof Object);                           //true

4、构造函数模式
function Person(name,age,family) {
    this.name = name;
    this.age = age;
    this.family = family;
    this.say = function(){
        alert(this.name);
    }
}
var person1 = new Person("lisi",21,["lida","lier","wangwu"]);
var person2 = new Person("lisi",21,["lida","lier","lisi"]);
console.log(person1 instanceof Object); //true
console.log(person1 instanceof Person); //true
console.log(person2 instanceof Object); //true
console.log(person2 instanceof Person); //true
console.log(person1.constructor);      //constructor 属性返回对创建此对象的数组、函数的引用

5、原型模式
function Person() {
}

Person.prototype.name = "lisi";
Person.prototype.age = 21;
Person.prototype.family = ["lida","lier","wangwu"];
Person.prototype.say = function(){
    alert(this.name);
};
console.log(Person.prototype);   //Object{name: 'lisi', age: 21, family: Array[3]}

var person1 = new Person();        //创建一个实例person1
console.log(person1.name);        //lisi

var person2 = new Person();        //创建实例person2
person2.name = "wangwu";
person2.family = ["lida","lier","lisi"];
console.log(person2);            //Person {name: "wangwu", family: Array[3]}
// console.log(person2.prototype.name);         //报错
console.log(person2.age);              //21

6、混合模式（构造函数模式+原型模式）
function Person(name,age,family){
    this.name = name;
    this.age = age;
    this.family = family;
}

Person.prototype = {
    constructor: Person,  //每个函数都有prototype属性，指向该函数原型对象，原型对象都有constructor属性，这是一个指向prototype属性所在函数的指针
    say: function(){
        alert(this.name);
    }
}

var person1 = new Person("lisi",21,["lida","lier","wangwu"]);
console.log(person1);
var person2 = new Person("wangwu",21,["lida","lier","lisi"]);
console.log(person2);
```

### 继承

```
　一、原型链继承
　重点：让新实例的原型等于父类的实例。
　　　　特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）
　　　　缺点：1、新实例无法向父类构造函数传参。
　　　　　　　2、继承单一。
　　　　　　　3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）
　　　　　　　
　二、借用构造函数继承　
　　重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））
　　　　特点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。
　　　　　　　2、解决了原型链继承缺点1、2、3。
　　　　　　　3、可以继承多个构造函数属性（call多个）。
　　　　　　　4、在子实例中可向父实例传参。
　　　　缺点：1、只能继承父类构造函数的属性。
　　　　　　　2、无法实现构造函数的复用。（每次用每次都要重新调用）
　　　　　　　3、每个新实例都有父类构造函数的副本，臃肿。
　　　　　　　
　三、组合继承（组合原型链继承和借用构造函数继承）（常用）
　重点：结合了两种模式的优点，传参和复用
　　　　特点：1、可以继承父类原型上的属性，可以传参，可复用。
　　　　　　　2、每个新实例引入的构造函数属性是私有的。
　　　　缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。
　　　　
　四、原型式继承
　　重点：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。
　　　　特点：类似于复制一个对象，用函数来包装。
　　　　缺点：1、所有实例都会继承原型上的属性。
　　　　　　　2、无法实现复用。（新实例属性都是后面添加的）
　　　　　　　
　五、寄生式继承
　　重点：就是给原型式继承外面套了个壳子。
　　　　优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。
　　　　缺点：没用到原型，无法复用。
　
　六、寄生组合式继承（常用）
　寄生：在函数内返回对象然后调用
　　　　组合：1、函数的原型等于另一个实例。2、在函数中用apply或者call引入另一个构造函数，可传参　
　　　　　重点：修复了组合继承的问题

　　　　继承这些知识点与其说是对象的继承，更像是函数的功能用法，如何用函数做到复用，组合，这些和使用继承的思考是一样的。上述几个继承的方法都可以手动修复他们的缺点，但就是多了这个手动修复就变成了另一种继承模式。
　　　　这些继承模式的学习重点是学它们的思想，不然你会在coding书本上的例子的时候，会觉得明明可以直接继承为什么还要搞这么麻烦。就像原型式继承它用函数复制了内部对象的一个副本，这样不仅可以继承内部对象的属性，还能把函数（对象，来源内部对象的返回）随意调用，给它们添加属性，改个参数就可以改变原型对象，而这些新增的属性也不会相互影响。
```

### 类

```js
类声明:
定义类有2中方式，类声明和类表达式：
// 类声明
class Student {}
// 类表达式
const Student = class {}

为什么说它是语法糖
因为类实际上它是一个function，区别在于构造函数是函数作用域，类是块级作用域，类中的方法，都是定义在类的prototype上面，所以文章开头说它还是构造函数和原型的概念

类包含的属性和方法
类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。

类的构造函数
类的构造函数关键字是constructor，它同等于原型中的prototype.constructor。
如果没有写constructor函数，那么会默认有一个空的constructor函数。
```

### 5.2 作用域链

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

函数有一个内部属性`[scope]`，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解`[scope]`就是所有父变量对象的层级链。

```js
function foo() {
    function bar() {
        //更多代码
    }
}
```

函数创建时，各自的`[scope]`为：

```js
foo.[scope] = [
  globalContext.VO
];

bar.[scope] = [
    fooContext.AO,
    globalContext.VO
];
```

子作用域可以访问父作用域的变量，父作用域不能访问子作用域的变量（只能自下往上查找，不能自上往下查找）。

```js
function parent() {
    var a = 1;
    function child() {
        var b = 2;
        console.log(a); //可以访问到parent中的a
    }
    console.log(b);     //报错，因为访问不到child中的b
}
```

## 5.3 this

前面已经提到`javascript`采用的是静态作用域，但是`this`算是模仿了动态作用域，`this`是在执行阶段时确定的。

### 5.3.1 默认绑定

不带任何修饰的函数进行调用的，只能采用默认绑定，`this`指向全局。严格模式下不能将全局对象用于默认绑定，因此`this`会绑定到`undefined`。

```js
function foo () {
    console.log(this);	//window
    console.log(this.a);
}
var a = 12;
foo();  //12
```

```js
function a() {
    console.log('a', this);	//'a' window
}
function b() {
    a();
    console.log('b', this);	//'b' window
}
function c() {
    b();
    console.log('c', this);	//'c' window
}
c();
```

### 5.3.2 隐式绑定

对象内部包含一个指向函数的属性，并通过这个属性间接引用这个函数，从而把`this`间接（隐式）绑定到这个对象上。

+ 无论是直接在`obj`中定义还是再添加为引用属性，这个函数严格来说都不属于`obj`对象。

```js
function foo() {
    console.log(this);	//{a: 2, foo: ƒ}
    console.log(this.a);	//2
}

var obj = {
    a: 2,
    foo: foo
}
obj.foo();

var obj = {
    a: 2,
    foo: function() {
        console.log(this);	//{a: 2, foo: ƒ}
        console.log(this.a);	//2
    }
}
obj.foo();
```

+ 调用位置会使用`obj`上下文来引用函数，因此你可以说函数被调用时`obj`对象“拥有”或者“包含”函数引用。当`foo()`被调用时，它的前面确实加上了对`obj`的引用，当函数引用有上下文对象时，隐式绑定规则会把函数调用中的`this`绑定到这个上下文对象。因此调用`foo()`时`this`被绑定到`obj`，因此在函数中执行`this.a`和`obj.a`是一样的。
+ 对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。

```js
function foo() {
    console.log(this.a);
}

var obj2 = {
    a: 1,
    foo: foo
}

var obj1 = {
    a: 2,
    obj2: obj2
}
obj1.obj2.foo();    //1

var obj3 = {
    a: 3,
    obj1: obj1
}
obj3.obj1.obj2.foo();	//1
```

### 5.3.3 显示绑定

`call`,`apply`,`bind`都属于显式绑定一类，显示绑定后`this`便无法再修改。

```js
function foo() {
    console.log(this);	//{a: 2}
    console.log(this.a);  //2
}
var obj = {
    a: 2
}
foo.call(obj);
```

### 5.3.4 new绑定

实例化一个新对象后，会将实例对象绑定到函数调用中的`this`上。

```js
function foo(a) {
    console.log(this);	//foo {}
    this.a = a;
    console.log(this.a);	//2
}
var bar = new foo(2);
console.log(bar.a); //2
console.log(a);	//Uncaught ReferenceError: a is not defined
```

### 5.3.5 箭头函数

`es6`新增的`()=>`箭头函数中，`this`在分析阶段时就确定了（跟函数中的`this`在执行阶段时确定相反），绑定的是父作用域中的`this`，指向永远不变。其实总结起来就两点：

+ 外层有函数：外层函数的`this`就是箭头函数的`this`。

```js
function ab() {
    var b = () => {
        console.log(this);
    };
    b();
}
ab();   //window，因为外层函数的this采用了默认绑定规则
```

```js
var obj = {
    a: 1,
    foo() {
        var fn = () => {
            console.log(this.a);
        };
        fn();
    }
}
obj.foo();  //1，外层函数的this采用了隐式绑定规则
```

外层没有函数：箭头函数的`this`就是`window`。

```js
var a = 123;
var obj = {
    a: 1,
    foo: () => {
        console.log(this.a);
    }
}
obj.foo();  //123
```

### 2.1 对象属性的类型

### 2.1.1 configurable（可配置）

表示属性是否可以通过`delete`删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 `true`。

``` js
let person = {};
Object.defineProperty(person, "name", {
    configurable: false,
    value: undefined
});
console.log(person);    //{name: undefined}
delete person.name;  //false
console.log(person);    //{name: undefined}
```

``` js
let person = {};
Object.defineProperty(person, "name", {
    configurable: true,
    value: undefined
});
console.log(person);    //{name: undefined}
delete person.name;  //true
console.log(person);    //{}
```

``` js
let person = {};
Object.defineProperty(person,
    "name", {
    configurable: false,
    value: "Nicholas"
});
//Uncaught TypeError: Cannot redefine property: name
Object.defineProperty(person, "name", {
    configurable: true,
    value: "Nicholas"
});
```

### 2.1.2 enumerable

表示属性是否可以通过`for-in`循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是`true`。 

``` js
let person = {};
Object.defineProperties(person, {
    name: {
        enumerable: false
    },
    sex: {
        enumerable: true
    },
    age: {
        enumerable: true
    }
});
for (let key in person) {
    console.log(key);
}
// sex
// age
```

### 2.1.3 writable

表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是`true`。

``` js
var obj = {};
Object.defineProperties(obj, {
    sex: {
        value: '男',
        writable: true
    },
    name: {
        value: '张三',
        writable: false
    }
});
obj.name = '李四';
obj.sex = '女';
console.log(obj);   //{sex: "女", name: "张三"}
```

### 2.1.4 value

包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为`undefined`。

``` js
let person = {};
Object.defineProperty(person, "name", {
    value: "Nicholas"
});
console.log(person.name);   //Nicholas
```

### 2.1.5 get

获取函数，在读取属性时调用。默认值为`undefined`。

``` js
let book = {
    year_: 2017, 
    edition: 1
};
Object.defineProperty(book, "year", {
    get() {
        return this.year_;
    }
});
console.log(book.year); // 2017
console.log(book.edition); // 1
```

### 2.1.6 set

设置函数，在写入属性时调用。默认值为`undefined`。

``` js
let book = {
    year_: 2017, 
    edition: 1
};
Object.defineProperty(book, "year", {
    get() {
        return this.year_;
    },
    set(newValue) {
        if (newValue > 2017) {
            this.year_ = newValue;
            this.edition += newValue - 2017;
        }
    }
});
book.year = 2018;
console.log(book.year); // 2018
console.log(book.edition); // 2
```

## 2.2 getOwnPropertyDescriptor

获取指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含属性的类型。

``` js
let book = { name: '张三' };
console.log(Object.getOwnPropertyDescriptor(book, 'name'));	//{value: "张三", writable: true, enumerable: true, configurable: true}
```

## 2.2 getOwnPropertyDescriptors

方法用来获取一个对象的所有自身属性的描述符。

``` js
let book = { name: '张三', age: 12 };
console.log(Object.getOwnPropertyDescriptors(book));
/**
{
    age: { value: 12, writable: true, enumerable: true, configurable: true }
    name: { value: "张三", writable: true, enumerable: true, configurable: true }
}
*/
```

## 2.3 合并对象

在`es6`之前，通常会封装一个方法，可参考`jqeury`的[`extend`](https://www.runoob.com/jquery/misc-extend.html)方法。

``` js
var obj = {
    a: 1,
    b: 2
}
var obj1 = {
    c: 3,
    a: 5
}
{
    a: 5,
    b: 2,
    c: 3
}
```

``` js
//一个特别简单的浅拷贝
function extend(target, source) {
    target = target || {};
    if (typeof target !== 'object') {
        throw new Error('target不是对象');
    }
    if (!source) {
        throw new Error('source不能为空');
    }
    if (typeof source !== 'object') {
        throw new Error('source不是对象');
    }
    for (let key in source) {
        target[key] = source[key];  //然后将源对象的值赋值到target中
    }
    return target;  //最后返回target
}

var obj = extend({
    a: 1,
    b: 2
}, {
    c: 3,
    a: 5
})
/**
{
    a: 5,
    b: 2,
    c: 3
}
*/
```

> **Object.assign**

用于对象的合并，将源对象`（source）`的所有可枚举属性，复制到目标对象`（target）`。源对象可以是多个，后者替换前者。

``` js
let obj = Object.assign({ a: 1 }, { b: 2 }, { c: 3 }, { a: 5 }, { b: 6 });
//{a: 5, b: 6, c: 3}
```

**出现的问题：**

以上方法都是**浅拷贝**，如果拷贝属性是对象，那么拷贝的只是引用。

``` js
var obj = {
    a: 1,
    b: 'fff'
}
var obj1 = {
    a: 2,
    c: {
        name: '李四',
        age: 20
    }
}
var obj2 = Object.assign({}, obj, obj1);
obj1.a = 3;
obj1.c.name = '王五';
obj1.c.age = 30;
console.log(obj2);	//obj2.c会跟着obj1.c的改变而改变
```

> **深拷贝**

``` js
//深拷贝
function deepClone(target, source) {
    if (typeof target !== 'object' || !target) {
        return source || target;
    }
    if (typeof source !== 'object' || !source) {
        return source;
    }
    for (let key in source) {
        var item = source[key];
        if (typeof item === 'object' && item) {
            target[key] = deepClone(Array.isArray(item) ? [] : {}, item);
        } else {
            target[key] = item;
        }
    }
    return target;
}

var obj = {
    a: 1,
    b: 'fff'
}
var obj1 = {
    a: 2,
    c: {
        name: '李四',
        age: 20
    }
}
var obj2 = deepClone(obj, obj1);
obj1.a = 3;
obj1.c.name = '王五';
obj1.c.age = 30;
console.log(obj2);	//obj2.c不会跟着obj1.c的改变而改变
```

## 2.4 解构

``` js
// 使用对象解构
let person = { name: 'Matt', age: 27 };
//可以使用别名 personAge
//相当于 let name = person.name;
//相当于 let personAge = person.age;
let { name, age: personAge } = person;
console.log(name, personAge);	//Matt   27
```

``` js
let person = { name: 'Matt', age: 27 };
let { job } = person;	//不存在的也可以解构，其实就相当于   let job = person.job;
console.log(job);	//undefined
```

``` js
let person = { name: 'Matt', age: 27, sex: null };
//也可以设置一个默认值，如果获取的值为undefined的话
//注：如果获取的值为null则不会取默认值，而是直接设置为null
let { name, job='Software engineer', sex = '男' } = person; 
console.log(name); // Matt 
console.log(sex);	//null
console.log(job); // Software engineer
```

``` js
//无法解构null和undefined
let { _ } = null; // TypeError
let { _ } = undefined; // TypeError
```

``` js
const [n1, n2, { a }] = [1, 2, { a: 3 }];	//解构数组
console.log(n1, n2, a); // 1 2 3
```

**思考：**

``` js
const data = [
    {
        name: '张三',
        age: 50,
        sex: '男',
        children: [
            {
                name: '张琳',
                sex: '女',
                age: 20
            }
        ]
    },
    {
        name: '王五',
        age: 25,
        sex: undefined
    }
];
//把每个人的 name,age,sex解构出来，没有sex的设置默认值：男，重名的设置别名
```

## 2.5 创建对象

**思考：**假如现在有个需求，要创建5个人物对象，需要有名字、年龄、工作，大家会怎么写？

**千万不要一个一个对象的去定义，不要重复相同的劳动，毫无意义！！！**

### 2.5.1 简单工厂模式

简单理解工厂就是有一条标准化的流水线，只要输入参数就能按照标准流程生产出需要的产品。

``` js
function createPerson(name, age, job) {
    let o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function () {
        console.log(this.name);
    };
    return o;
}
let person1 = createPerson("Nicholas", 29, "Software Engineer");
let person2 = createPerson("Greg", 27, "Doctor");
```

### 2.5.2 构造函数模式

``` js
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function () {
        console.log(this.name);
    };
}

let person1 = new Person("Nicholas", 29, "Software Engineer"); 
let person2 = new Person("Greg", 27, "Doctor"); 
person1.sayName(); // Nicholas 
person2.sayName(); // Greg
console.log(person1.constructor == Person); // true 
console.log(person2.constructor == Person); // true

console.log(person2 instanceof Object); // true 
console.log(person2 instanceof Person); // true
```

``` js
//写成函数表达式也行
let Person = function (name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function () {
        console.log(this.name);
    };
}

let person1 = new Person("Nicholas", 29, "Software Engineer"); 
let person2 = new Person("Greg", 27, "Doctor"); 
person1.sayName(); // Nicholas 
person2.sayName(); // Greg
console.log(person1.constructor == Person); // true 
console.log(person2.constructor == Person); // true

console.log(person2 instanceof Object); // true 
console.log(person2 instanceof Person); // true
```

**缺陷：**每次`sayName`方法都要重新定义一次，其实这个方法只需定义一次即可。

### 2.5.3 原型模式

``` js
function Person() { }
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function () {
    console.log(this.name);
};
```

**缺陷：** 1. 原型上的对象数据会被共享，一个对象改了，其他对象也会跟着变。2. 创建对象不方便。

> **改良**

``` js
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
}
//将无需重复定义/共享的定义在原型上
Person.prototype.sayName = function () {
    console.log(this.name);
};

let person1 = new Person("Nicholas", 29, "Software Engineer"); 
let person2 = new Person("Greg", 27, "Doctor"); 
person1.sayName(); // Nicholas 
person2.sayName(); // Greg
```

## 2.6 hasOwnProperty

`hasOwnProperty()`方法用于确定某个属性是在实例上还是在原型对象上。

``` js
function Person() { }
Person.prototype.age = 12;
let person1 = new Person;
person1.age = 20;
console.log(person1.age);	//20
console.log(person1.hasOwnProperty("age"));	//true	来自实例
delete person1.age;
console.log(person1.age);	//12
console.log(person1.hasOwnProperty("age"));	//false	来自原型
```

> **in**

`in`操作符会在可以通过对象访问指定属性时返回`true`，无论该属性是在实例上还是在原型上。

``` js
function Person() { }
Person.prototype.age = 12;
let person1 = new Person;
person1.age = 20;
console.log(person1.age);	//20
console.log(person1.hasOwnProperty("age"));	//true	来自实例
'age' in person1;	//true
delete person1.age;
console.log(person1.age);	//12
console.log(person1.hasOwnProperty("age"));	//false	来自原型
'age' in person1;	//true
```

**思考**：

如何判断一个属性是来自原型而不是来自实例呢？

## 2.7 keys

`Object.keys()`方法接收一个对象作为参数，返回包含该对象所有可枚举的实例属性名称的字符串数组。

``` js
Object.keys({ a: 1, b: 2, c: 3 });  //["a", "b", "c"]
```

## 2.8 getOwnPropertyNames

`Object.getOwnPropertyNames()`方法可以获取所有实例属性，无论是否可以枚举。

``` js
function Person() {
    this.sex = '男';
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function () {
    console.log(this.name);
};
var p = new Person();
console.log(Object.getOwnPropertyNames(p)); //?
```

## 2.9 values

 `Object.values()`返回对象值的数组。

``` js
const o = {
    foo: 'bar',
    baz: 1,
    qux: {}
};
console.log(Object.values(o)); // ["bar", 1, {}]
```

## 2.10 entries

 `Object.entries()` 接收一个对象，返回键/值对的数组。

``` js
const o = {
    foo: 'bar',
    baz: 1,
    qux: {}
};
console.log(Object.entries(o));	// [["foo", "bar"], ["baz", 1], ["qux", {}]]
```

**思考：**

``` js
const o = {
    foo: 'bar',
    baz: 1,
    qux: {}
};
Object.entries(o);	//用解构将所有的key和value解构出来
```

## 2.11 原型

 每个对象都有一个特殊的属性叫作`原型（prototype）`，在原型上定义的属性和方法会被每一个实例对象共享。

``` js
function Person() { }
Person.prototype.name = "无名";
Person.prototype.children = [];
Person.prototype.sayName = function () {
    console.log(`我的名字叫：${this.name}`);
}

let zhangsan = new Person();
let lisi = new Person();
console.log(zhangsan.name);
console.log(lisi.name);
console.log(zhangsan.hasOwnProperty('name'));
zhangsan.name = '张三';
console.log(zhangsan.hasOwnProperty('name'));
console.log(lisi.name);
Person.prototype.name = '有名';
console.log(lisi.name);
console.log(zhangsan.name);
delete zhangsan.name;
console.log(zhangsan.name);

lisi.name = '李四';
console.log(zhangsan.sayName());
console.log(lisi.sayName());
console.log(zhangsan.sayName === lisi.sayName);

zhangsan.children.push('张欣');
console.log(zhangsan.children);
console.log(lisi.children);
console.log(zhangsan.hasOwnProperty('children'));
console.log(zhangsan.children === lisi.children);
//?
```

## 2.12 原型链

每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个内部指针指向另一个构造函数的原型对象，这样就在实例和原型之间构造了一条原型链。

```` js
function Person() { }
Person.prototype.constructor === ?;
Person.prototype.constructor.prototype === ?;
Person.prototype.__proto__ === ?

let zhangsan = new Person;
zhangsan.constructor === Person;
zhangsan.__proto__ === ?;
zhangsan.__proto__.__proto__ === ?
````

``` js
let obj = new Object();
obj.__proto__ === ?;
obj.__proto__.__proto__ === ?
```

## 2.13 面向过程

现在有个需求：创建一个人，张三、男、20岁。

``` js
let zhangsan = new Object;
zhangsan.name = '张三';
zhangsan.age = 20;
zhangsan.sex = '男';
```

又新来了一个需求：创建一个人，李四、男、30岁。

``` js
let lisi = new Object;
lisi.name = '李四';
lisi.age = 30;
lisi.sex = '男';
```

随着需求的不断增加，已经添加了1000个人。

``` js
let zhangsan = new Object;
zhangsan.name = '张三';
zhangsan.age = 20;
zhangsan.sex = '男';

let lisi = new Object;
lisi.name = '李四';
lisi.age = 30;
lisi.sex = '男';
//...........剩下的3992行代码
```

然后突然有一天新增了一个需求：将所有年龄>=20的标记为青年，<20的标记为少年。

``` js
let zhangsan = new Object;
zhangsan.name = '张三';
zhangsan.age = 20;
zhangsan.sex = '男';
zhangsan.type = '青年';

let lisi = new Object;
lisi.name = '李四';
lisi.age = 30;
lisi.sex = '男';
zhangsan.type = '青年';
//...........剩下的4990行代码
```

突然有一天，又要为每个人新增一个行为：能自我介绍。

...........更多的需求

**思考：**面向过程的痛点是什么？怎么去解决它？

## 2.14 面向对象

将任何事物都想象成一个对象，并提炼出这个对象的属性、行为等，然后封装起来。

需求：创建一个人，张三、男、20岁。

此刻，首先需将人想象为一个对象，目前给出的三个属性是姓名、性别、年龄，将封装思想用起来。

``` js
function Person(name, age, sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
}

let zhangsan = new Person('张三', 20, '男');
```

又新来了一个需求：创建一个人，李四、男、30岁。

``` js
let lisi = new Person('李四', 30, '男');
```

随着需求的不断增加，已经添加了1000个人。

``` js
function Person(name, age, sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
}

let zhangsan = new Person('张三', 20, '男');
let lisi = new Person('李四', 30, '男');
//...   剩下的998行代码
```

然后突然有一天新增了一个需求：将所有年龄>=20的标记为青年，<20的标记为少年。

``` js
function Person(name, age, sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
    //只需在构造函数里新增一个判断即可，其他每个实例都不用动
    if (this.age >= 20) {
        this.type = '青年';
    }
    else {
        this.type = '少年';
    }
}
```

突然有一天，又要为每个人新增一个行为：能自我介绍。

``` js
function Person(name, age, sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
    if (this.age >= 20) {
        this.type = '青年';
    }
    else {
        this.type = '少年';
    }
}

Person.prototype.say = function () {
    console.log(`我是${this.name}，我今年${this.age}岁了，我是个${this.sex}人，算是${this.type}了`);
}

let zhangsan = new Person('张三', 20, '男');
let lisi = new Person('李四', 30, '男');
//...  剩下的998行代码
console.log(zhangsan.say());
console.log(lisi.say());
```

##  2.15 继承

继承就是子继承父的所有属性和方法，如：父亲的基因被儿子继承，所以通过DNA（原型链）可追溯某人的向上继承关系。从技术上来讲就是继承父对象的所有属性和方法。

``` js
function Father() {
    this.money = 10000000000;   //百亿家产
    this.houses = 10;   //10栋别墅
    this.cars = 100;    //100辆车
}

function Son() {
    Father.call(this);  //继承父亲的家产
}

let son = new Son;
console.log(son.money, son.houses, son.cars);   //10000000000 10 100
```

### 2.15.1 原型式继承

``` js
function superType() {
    this.name = '张三';
    this.children = ['张欣', '张宇'];
}
superType.prototype.age = 12;
function sub() {
}
sub.prototype = new superType();
var s = new sub();
console.log(s.name, s.age);    //张三 12
console.log(s.hasOwnProperty('name'));  //false
console.log(s.hasOwnProperty('children'));  //false

var s1 = new sub();
s1.children.push('李四');
console.log(s1.children);
console.log(s.children);

console.log(s.constructor === superType);   //true
console.log(s instanceof sub);  //true
console.log(s instanceof superType);    //true
```

### 2.15.2 盗用构造函数

``` js
function superType() {
    this.name = '张三';
    this.children = ['张欣', '张宇'];
}
superType.prototype.age = 12;
function sub() {
    superType.call(this);
}

var s = new sub();	//从sub派生出来的，继承自sub
console.log(s.name);    //张三
console.log(s.hasOwnProperty('name'));  //true
console.log(s.hasOwnProperty('children'));  //true

<<<<<<< HEAD
总结：
	虽然使用哪种方式创建Object实例都可以，但实际上开发者更倾向于使用对象字面量表示法。这是因为对象字面量代码更少，看起来也更有封装所有相关数据的感觉。
<<<<<<< HEAD
<<<<<<< HEAD
```

### Array

```
	数组一般是由中括号包裹，元素之间使用逗号分隔，数组的长度也就是数组中元素的个数使用length获取，数组中具有索引下标，它们是
  从0开始的，通过对应的索引下标可以取到元素中对应的值。
  数组中的元素可以是js中任意数据类型的值
  当数组对象指定长度时，我们也可以存储多余这个长度的元素
```

数组的创建方式：
=======

    setTimeout()   //延迟调用；指定的时间后调用一次，只调用一次   在指定的毫秒数后调用函数或计算表达式。一次性计时器    
    
    清除计时器的方法
        clearInterval("要清除的定时器名")
        clearTimeout("要清除的定时器名")
    
    语法：setInterval(code,millisec,lang)     
    	 setTimeout(code,millisec,lang)
   code	    //必需。要调用的函数或要执行的代码串。
   millisec	//必须。周期性执行或调用 code 之间的时间间隔，以毫秒计。
   lang	    //可选。 JScript | VBScript | JavaScript
```



## 正则：

#### -- 基本概念

- 字符串匹配，查询，替换的一种模式，外表风骚，内功强大。
- 表达式的结构
- 正则表达式结构/修饰符` 比如 `/\d{12}/g`
- g 全局匹配 global  hello world
- i 忽略大小写 ignore

### -- 正则的创建方法

字面量方式 
>>>>>>> 5ad182241fc33c1ce1717de2e86146cd9b52fb0d

​```js
1. 使用字面量的方式创建  
 var arr = [10,20.30,true,"Hello",new Date(),function(){},[12,12,34],Math.random(),null,undefined]
 2. 使用new关键字来创建一个对象   
  var arr = new Array(12,34,"hello")                           var arr = new Array(5);
```
<<<<<<< HEAD

```js
 数组定义的两种方式
     var  arr = [1,2,3];
     var  arr1 = new Array(1,2,3);

数组的属性：length 设置或返回数组中元素的数目；
max-最大的  min-最小的  average-平均  sort-排序(从左往右-从小到大) 
#### 访问数组
  - 数组名[下标]
  - 关于下标： 下标从0开始，到arr.length-1
  - 读取数组中的元素  console.log(arr[下标])
  - 修改数组中的元素  arr[下标] = 'xxxx';
#### 数组的属性 length
长度  返回数组中元素的个数   - 具体有几个元素
max-最大的  min-最小的  average-平均  sort-排序(从左往右-从小到大) 
```

```js
数组的遍历:
-----for    
for (var i = 0; i < arr.length; i++) 
     {
       console.log(arr[i]) 
     }

-----for/in   
 for(var i in arr)
       { 
          console.log(arr[i]) 
       
       }
```

```js
   向数组中添加和删除的方法：
    
    push()向数组的末尾添加一个或更多元素，并返回新的数组长度。
    unshift()向数组的开头添加一个或更多元素，并返回新的长度
    shift()删除并返回数组的第一个元素。  //无参数    
    pop()删除数组的最后一个元素并返回删除的元素。 // 无参数
    splice()从数组中添加或删除元素 或者替换元素
           参数1： 下标    
           参数2： 数量
           参数3...4...5 添加的元素
           // 返回的是删除的元素---数组
    注意：添加和删除的方法，改变了原数组的长度和元素
    
    
concat()拼接一个或多个数组;返回拼接后的数组    
join()根据指定的分隔符（seperator）进行切割，返回一个字符串,参数缺省以逗号作为分隔符 (数组连接成字符串)
slice()选取数组的的一部分，并返回一个新数组 获取数组中部分元素并返回：  不会影响原数组(截取)

  // 以上三个方法不会影响原数组


与索引相关的方法： 
indexOf()匹配要查找的元素在数组中第一次出现的索引位置 ,array.indexOf(item,start)
lastIndexOf()  匹配要查找的元素在数组中最后一次出现的索引位置 
   注意：以上两个方法去查找元素，如果找不到，返回-1
   //  第二个参数默认省略, 如果有，下标
includes()  包含 数组中是否包含某个值   true   false

//不会影响原数组
reverse() 反转数组的元素顺序 ; 改变了原数组的顺序  (原来的数组发生变化)
sort()//排序 ---  影响原数组   默认升序


1. instanceof   arr instanceof Array
2. isArray()    Array.isArray(arr)   //// 如果是数组返回结果是true ,否则false 
=======
=======
>>>>>>> 5ad182241fc33c1ce1717de2e86146cd9b52fb0d
=======
var rep = /^1[34578]\d{9}$/
```

构造函数形式

```
 var rep = new RegExp("表达式","修饰符")
 //比如下面匹配一个手机号
 var rep = new RegExp("^1[34578]\d{9}$");
```

JS 字符串中可以使用正则表达式的三个函数

```js
 string.replace("正则表达式","要替换的对象")
 string.match("正则表达式")
 string.search("正则表达式")
```

test方法（用来验证）

```js
  var rep = /正则表达式/g
  rep.test(要验证的字符串); //结构返回true或者false
```

exec方法（用来验证）

```js
var rep = /正则表达式/g
rep.test(要验证的字符串) //结构返回true或false
```

常用的元字符：

```js
 [abc] //匹配方框号中的任意一个字符
            [^abc] //除了abc以外的所有的字符
            [0-9] //匹配0-9之间数字
            [a-z] //匹配所有的大写字母
            [0-9a-zA-Z] //匹配大小写字母和数字
            [A-z] //匹配所有的大小写字母  [A-Za-z]
            (红色|蓝色|绿色)  //匹配红色，蓝色绿色
            [\u4e00-\u9fa5] //中文汉字
             
            .  //匹配任意字符
            \w //匹配任意字母数字下划线 或 [A-Za-z0-9_]
            \W //匹配非字母数字下划线
            \d //匹配所有数字  [0-9]
            \D //匹配非数字
            \s //匹配空格字符
            \S //匹配非空格字符
```

常用的(写好的)

```js
   1.只能是中文 长度为2-7位
		 /^([\u4e00-\u9fa5]){2,7}$/
        2.长度为8到18位的小写大写字母或数字或下划线 【重要】
            /^[a-zA-Z0-9_]{8,18}$/
        3.正确的邮箱格式 【重要】
            /^\w+@[a-z0-9]{2,5}\.(com|cn|net|org)$/
            /^[A-z0-9_-]+@[a-z0-9]{2,5}\.[a-z]{2,3}$/
        4.正确的手机号【重要】
            /^1(3|4|5|7|8)\d{9}$/
        5.正确的身份证号:
            /^\d{15}|\d{17}([0-9]|x)/
            /^[1-9][0-9]{16}[0-9x]$/
        6.正确的qq号
            /[1-9][0-9]{4,}/
        7.正确的电话号码格式 【重要】
            /^0[0-9]{2}-[0-9]{8}|0[0-9]{3}-[0-9]{7}$/
            
        8. 过滤空白 /\s+/g
        9. 过滤首尾空格  str.trim()
        10. 匹配任意8-18之间的大小写字母数字构成的密码
            /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,18}$/
```

## 第6章集合引用类型

### 本章内容

```
##### 对象

##### 数组与定型数组

##### Map、WeakMap、Set以及WeakSet类型
```

### Object

```js
	显式地创建Object的实例有两种方式。第一种是使用new操作符和Object构造函数
letperson=newObject();
person.name="Nicholas";
person.age=29;
	另一种方式是使用对象字面量（object literal）表示法:
letperson={name:"Nicholas",age:29};数值属性会自动转换为字符串。
	对象字面量表示法来定义一个只有默认属性和方法的对象，只要使用一对大括号，中间留空就行了：
    letperson={};//与newObject()相同person.name="Nicholas";person.age=29;

总结：
	虽然使用哪种方式创建Object实例都可以，但实际上开发者更倾向于使用对象字面量表示法。这是因为对象字面量代码更少，看起来也更有封装所有相关数据的感觉。
>>>>>>> 5ad182241fc33c1ce1717de2e86146cd9b52fb0d
=======
var s1 = new sub();
s1.children.push('李四');
console.log(s1.children);
console.log(s.children);

console.log(s.constructor === sub);   //true
console.log(s instanceof sub);  //true
console.log(s instanceof superType);    //false
//目前为止一切看起来都正常了
console.log(s.age, s1.age);
>>>>>>> 30a980fb6d9d9242d67dd702cf719b316b44bc5d
```

### 2.15.3 组合继承

组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。

``` js
function superType() {
    console.log('superType执行了一次');
    this.name = '张三';
    this.children = ['张欣', '张宇'];
}
superType.prototype.age = 12;
function sub() {
    superType.call(this);
}

//直接继承原型，不用再次实例化父类构造函数，防止再次执行父类构造函数
//sub.prototype = Object.create(superType.prototype, { constructor:{ value:sub, enumerable:false } });

//跟上面的一样，只是最后自己手动修改一下构造函数的指向
sub.prototype = Object.create(superType.prototype)
sub.prototype.constructor = sub;

//使用浅拷贝的方式将自身的构造函数替换掉父类原型的构造函数
//sub.prototype = Object.assign(Object.create(superType.prototype), { constructor: sub });

var s = new sub();
console.log(s.name);    //张三
console.log(s.hasOwnProperty('name'));  //true
console.log(s.hasOwnProperty('children'));  //true

var s1 = new sub();
s1.children.push('李四');
console.log(s1.children);
console.log(s.children);

console.log(s.constructor === sub);   //true
console.log(s instanceof sub);  //true
console.log(s instanceof superType);    //true
console.log(s.age, s1.age);     //12 12
```

## 2.16 class类

与函数类型相似，定义类也有两种主要方式：类声明和类表达式。这两种方式都使用`class`关键字加大括号。类其实就是语法糖。

``` js
// 类声明
class Person {} 
// 类表达式
const Animal = class {};
```

函数可以提升，但是类不能提升。

``` js
console.log(ClassDeclaration); //ReferenceError: ClassDeclaration is not defined
class ClassDeclaration {}

//同样也受到块级作用域的限制
{ 
    function FunctionDeclaration() {} 
	class ClassDeclaration {} 
}
console.log(FunctionDeclaration);	//FunctionDeclaration() {} 
console.log(ClassDeclaration);	//ReferenceError: ClassDeclaration is not defined
```

### 2.16.1 类的构成

类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。默认情况下，**类定义中的代码都在严格模式下执行**。

``` js
// 空类定义，有效
class Foo {} 
// 有构造函数的类，有效
class Bar { 
    constructor() {} 
}
// 有获取函数的类，有效
class Baz { 
    get myBaz() {} 
}
// 有静态方法的类，有效
class Qux { 
    static myQux() {} 
}
```

``` js
class Person {
    constructor() {}

    name = '张三';
    _age = 17;
    children = [];

    say() {
        console.log(`我的名字叫：${this.name}`);
    }

    static isPerson(person) {
        return person instanceof Person;
    }

    get type() {
        if (this._age > 18) {
            return '青年';
        }
        return '少年';
    }

    get age() {
        return this._age;
    }

    set age(value) {
        if (value > 0 && value < 120) {
            this._age = value;
        }
    }
}

let person = new Person();
console.log(person.age, person.type);
person.age = 0;
console.log(person.age);
person.age = 20;
console.log(person.type);
console.log(Person.isPerson(person), Person.isPerson(new Object()));
console.log(person.hasOwnProperty('name'), person.hasOwnProperty('children'));
```

### 2.16.2 类构造函数

`constructor`关键字用于在类定义块内部创建类的构造函数。方法名`constructor`会告诉解释器在使用`new`操作符创建类的新实例时，应该调用这个函数。

``` js
class Animal { }
class Person {
    constructor() {
        console.log('person ctor');
    }
}
class Vegetable {
    constructor(color) {
        this.color = color;
    }
}
let a = new Animal();
let p = new Person(); // person ctor 
let v = new Vegetable('orange');
console.log(v.color); // orange
```

``` js
//和下面代码等价
function Person() {
    console.log('person ctor');
}
function Vegetable(color) {
    this.color = color;
}
let p = new Person(); // person ctor 
let v = new Vegetable('orange');
console.log(v.color); // orange
```

> **super**

=======
```

### 1.1.2 对象字面量

对象字面量是对象定义的简写形式，目的是为了简化包含大量属性的对象的创建。

​``` js
let person = { 
    name: "Nicholas", 
    age: 29 
};
```

也可以使用字符串、数字、bool类型来定义。

``` js
let person = { 
    "name": "Nicholas", 
    "age": 29, 
    5: true,
	true: 123,
    false: 321
};
person[5];	//true
person[true];	//123
person[false];	//321
```

但要注意此类情况（后值覆盖前值）：

``` js
let person = { 
    "name": "Nicholas", 
    "age": 29, 
    5: true,
	true: 123,
    true: 555,
    name: 'jack'
};
// 最后person变为
{
    5: true, 
    name: "jack", 
    age: 29, 
    true: 555
}
```

**思考：**

``` js
let person = {
    5:15,
    true: 'yes',
    false: 'no'
};
person.5;	// ?
person.true;	// ?
person.false;	// ?

person.__proto__ === ?;
person.__proto__.constructor === ?;

let person = new Object();
person.__proto__ === ?;
person.__proto__.constructor === ?;
```

### 1.1.3 访问/设置方式

> **点语法**

``` js 
let person = { 
	"name": "Nicholas", 
	"age": 29, 
	5: true,
	true: 123
};
person.name;	//"Nicholas"
person.age;		//29
person.name = 'jack';
person.age = 30;
person.true;	//对吗？
person.5;	//对吗？
```

> **中括号**

``` js
let person = { 
	"name": "Nicholas", 
	"age": 29, 
	5: true,
	true: 123
};
person['name'];	//"Nicholas"
person['age'];		//29
person['name'] = 'jack';
person['age'] = 30;
person[true];	//对吗？
person[5];	//对吗？
```

**思考：可以这样定义吗？如果可以，那么怎么访问name属性值呢？**

``` js
let name = {
    firstName: '张',
    lastName: '三'
};
let person = {
    [name]: '张三'
}
```

## 1.2 Array

### 1.2.1 Array构造函数

``` js
let colors = new Array();	//表示创建一个空数组
colors.length;	//0

let colors = new Array(5);	//表示创建一个长度为5的空数组
colors.length;	//5
colors[0];	//undefined
let colors = Array(5); //不用new也可以

let colors = new Array("red", "blue", "green");	//表示创建一个数组，并传入三个值
colors.length;	//3
colors[0];	//"red"
let names = Array("Greg"); //不用new也可以
```

**思考：**

``` js
let colors = new Array(3);
colors[0];	//？
colors.length;	//？
```

### 1.2.2 数组字面量

``` js
let colors = ["red", "blue", "green"]; // 创建一个包含3个元素的数组
let names = []; // 创建一个空数组
let values = [1,2,]; // 创建一个包含2个元素的数组
let ages = [,,,];	//创建一个包含3个三个空元素的数组
colors.length = 2;	//改变数组长度
colors[2];	//undefined
```

**思考：**

``` js
let cars = [1,2,,,];
cars.length;	//?

let cats = [1,2,,,5];
cats.length;	//?
cats[cats.length - 1];	//?

let dogs = [1,2,3];
dogs.length = 5;
dogs.length;	//?
dogs[dogs.length - 1];	//?
```

### 1.2.3 Array.from

第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性和可索引元素的结构。

``` js
// 字符串会被拆分为单字符数组 
console.log(Array.from("Matt")); // ["M", "a", "t", "t"]

// 可以使用from()将集合和映射转换为一个新数组
const s = new Set().add(1).add(2).add(3).add(4);
console.log(Array.from(s)); // [1, 2, 3, 4]

// Array.from()对现有数组执行浅复制
const a1 = [1, 2, 3, 4]; 
const a2 = Array.from(a1);
console.log(a1); // [1, 2, 3, 4]
a1 === a2; // false
a2.push(5);
a1.length;	//?

// arguments对象可以被轻松地转换为数组
function getArgsArray() { 
    return Array.from(arguments); 
}
console.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4]

// from()也能转换带有必要属性的自定义对象
const arrayLikeObject = { 0: 1, 1: 2, 2: 3, 3: 4, length: 4 };
console.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4]

//没有length的对象不行，因为会将0,1,2,3当做对象的key，而不当做是下标
const arrayLikeObject = { 0: 1, 1: 2, 2: 3, 3: 4 };
console.log(Array.from(arrayLikeObject)); // []
```

**思考：**

``` js
const arrayLikeObject = { 3: 1, 1: 2, 2: 3, 0: 4,length:4 };	//下标打乱顺序
console.log(Array.from(arrayLikeObject)); //?

const arrayLikeObject = { 3: 1, 1: 2, 2: 3, 0: 4,length:6 };	//长度多了2
console.log(Array.from(arrayLikeObject)); //?

const arrayLikeObject = { 3: 1, 1: 2, 2: 3, 0: 4,length:2 };	//长度只有2
console.log(Array.from(arrayLikeObject)); //?

//转换一个没有length的对象
const arrayLikeObject = { a:1, b:2 };
console.log(Array.from(arrayLikeObject)); //?

//转换一个有length的对象
const arrayLikeObject = { a:1, b:2, length:3 };
console.log(Array.from(arrayLikeObject)); //?
```

### 1.2.4 Array.of

`Array.of() `可以把一组参数转换为数组。这个方法用于替代在ES6之前常用的`Array.prototype.slice.call(arguments)`。

``` js
console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4] 
console.log(Array.of(undefined)); // [undefined]
```

### 1.2.5 检测数组

``` js
[] instanceof Array;	// true
Array.isArray([]);	//true
```

思考：

``` js
(new Array() instanceof Array);	//?
(Array.isArray(new Array()));	//?
```

### 1.2.6 fill

使用`fill()`方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。

[^负值索引]: 负值索引从数组末尾开始计算，也可以将负索引想象成数组长度加上它得到的一个正索引（如果长度减去负索引还是得到负数，索引则从0开始）。

``` js
const zeroes = [0, 0, 0, 0, 0]; // 用5填充整个数组
zeroes.fill(5);
console.log(zeroes); // [5, 5, 5, 5, 5]

// 用6填充索引大于等于3的元素
zeroes.fill(0); // 重置
zeroes.fill(6, 3); 
console.log(zeroes); // [0, 0, 0, 6, 6]

// 用7填充索引大于等于1且小于3的元素
zeroes.fill(0); // 重置
zeroes.fill(7, 1, 3);
console.log(zeroes); // [0, 7, 7, 0, 0];

// 用8填充索引大于等于1且小于4的元素
// (-4 + zeroes.length = 1)
// (-1 + zeroes.length = 4)
zeroes.fill(8, -4, -1); 
console.log(zeroes); // [0, 8, 8, 8, 0];
```

> **`fill()`静默忽略超出数组边界、零长度及方向相反的索引范围**

[^fill()]: 注解如下：

``` js
const zeroes = [0, 0, 0, 0, 0]; 
zeroes.fill(1, -10, -6);	// 索引过低，忽略
console.log(zeroes); // [0, 0, 0, 0, 0] 
zeroes.fill(1, 10, 15);		// 索引过高，忽略
console.log(zeroes);	// [0, 0, 0, 0, 0] 
zeroes.fill(2, 4, 2);	// 索引反向，忽略
console.log(zeroes); // [0, 0, 0, 0, 0]
zeroes.fill(4, 3, 10);	// 索引部分可用，填充可用部分 
console.log(zeroes); 	// [0, 0, 0, 4, 4]
```

**思考：**

``` js
const zeroes = [0, 0, 0, 0, 0]; 
zeroes.fill(1, -10, -1);
console.log(zeroes);	//?

const zeroes = [0, 0, 0, 0, 0]; 
zeroes.fill(1, -10, 20);
console.log(zeroes);	//?
```

### 1.2.7 copyWithin

`copyWithin()`会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与`fill()`使用同样的计算方法。

``` js
let ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
// 从ints中复制索引0开始的内容，插入到索引5开始的位置
// 在源索引或目标索引到达数组边界时停止
ints.copyWithin(5); 
console.log(ints); // [0, 1, 2, 3, 4, 0, 1, 2, 3,4]

let ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
// 从ints中复制索引5开始的内容，插入到索引0开始的位置
ints.copyWithin(0, 5); 
console.log(ints); // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]

let ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
// 从ints中复制索引大于0并且小于3的内容
// 插入到索引4开始的位置
ints.copyWithin(4, 0, 3); 
console.log(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]

let ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
ints.copyWithin(2, 0, 6); 
console.log(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]

// 支持负索引值，与fill()相对于数组末尾计算正向索引的过程是一样的
let ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
ints.copyWithin(-4, -7, -3); 
console.log(ints); // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]
```

> **静默忽略超出数组边界、零长度及方向相反的索引范围（同[^fill()]方法一样）**

### 1.2.8 reverse

严格意义上来讲，`reverse`不是排序方法，它只是数组颠倒方法，可以将数组的顺序颠倒过来。

``` js
// 书中的例子，只是作为反向排序讲解，不够全面
let values = [1, 2, 3, 4, 5]; 
values.reverse();
console.log(values); // [5,4,3,2,1]

let numbers = [5,1,2,6,3];
numbers.reverse();
console.log(numbers); // [3, 6, 2, 1, 5]

let chars = ['c','b','d','a','w'];
chars.reverse();
console.log(chars); // ["w", "a", "d", "b", "c"]

let objs = [{a:1}, {a:5}, {a:3}];
objs.reverse();
console.log(objs);	// [{a:3},{a:5},{a:1}]
```

### 1.2.9 sort

`sort()`方法可以接收一个比较函数，用于判断哪个值应该排在前面。比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回0；如果第一个参数应该排在第二个参数后面，就返回正值。

``` js
let values = [0, 1, 5, 10, 15];
values.sort();	// 不传比较函数出来的结果是不正常的
console.log(values); // 0,1,10,15,5

let values = [15, 1, 10, 5, 0];
values.sort(function (value1, value2) {
    if (value1 < value2) {
        return -1;
    }
    else if (value1 > value2) {
        return 1;
    }
    return 0;
});
console.log(values); // 0,1,5,10,15

//使用箭头函数简写
let values = [15, 1, 10, 5, 0];
values.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
console.log(values); // 0,1,5,10,15

//最简单的方法
let values = [15, 1, 10, 5, 0];
values.sort((a, b) => a - b);
console.log(values); // 0,1,5,10,15
```

**思考：**

``` js
let values = [15, 1, 10, 5, 0];
//使用function的方式写一个反向排序方法

//使用箭头函数简写
let values = [15, 1, 10, 5, 0];
//使用箭头函数简写的方式写一个反向排序方法

//最简单的方法
let values = [15, 1, 10, 5, 0];
//使用最简单的方法写一个反向排序方法
```

### 1.2.10 concat

`concat()`方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。

``` js
let colors = ["red", "green", "blue"]; 
let colors2 = colors.concat("yellow", ["black", "brown"]); 
console.log(colors); // ["red", "green","blue"]
console.log(colors2); // ["red", "green", "blue", "yellow", "black", "brown"]

//不能添加第二层的数据
let colors = ["red", "green", "blue"]; 
let colors2 = colors.concat("yellow", ["black", "brown"],"aaa",["bbb",'ccc', ['a','b',['c']]]);
console.log(colors2);	//["red", "green", "blue", "yellow", "black", "brown", "aaa", "bbb", "ccc", Array(3)]
```

### 1.2.11 slice

`slice()`用于创建一个包含原有数组中一个或多个元素的新数组。`slice()`方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则 `slice()`会返回该索引到数组末尾的所有元素。如果有两个参数，则`slice()` 返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。

``` js
let colors = ["red", "green", "blue", "yellow", "purple"]; 
let colors2 = colors.slice(1); 
let colors3 = colors.slice(1, 4);
console.log(colors2);	// ["green", "blue", "yellow", "purple"
console.log(colors3);	// ["green", "blue", "yellow"]
console.log(colors);	// ["red", "green", "blue", "yellow", "purple"]
```

> - `slice()`的[^负值索引]跟`fill()`负值索引计算方式一样。
>
> - 静默忽略超出数组边界、零长度及方向相反的索引范围也跟[^fill()]方法的一样。

**思考：**

``` js
let numbers = [1,2,3,4,5];
console.log(numbers.slice(-5));		//?
console.log(numbers.slice(-5,-1));	//?
console.log(numbers.slice(-30));	//?
console.log(numbers.slice(-3,-5));	//?
```

### 1.2.12 splice

`splice()`是个非常强大的方法，可删除，替换，增加（**需非常熟悉**）。

- **删除**

  需要给 `splice()` 传2个参数：要删除的第一个元素的位置和要删除的元素数量。从原数组中删除任意多个元素，并返回一个数组，返回的数组包含删除的项。比如`splice(0, 2)` 会删除原数组前两个元素，并返回一个数组，数组中包含前两个已删除的项。

  ``` js
  let colors = ["red", "green", "blue"]; 
  let removed = colors.splice(0,1); // 删除第一项，并将第一项返回
  console.log(colors);	// ["green", "blue"]
  console.log(removed);	// ["red"]
  
  let colors = ["red", "green", "blue"]; 
  let removed = colors.splice(-3);
  console.log(colors);	// []
  console.log(removed);	// ["red", "green", "blue"]
  
  let colors = ["red", "green", "blue"]; 
  let removed = colors.splice(-3,2);
  console.log(colors);	// ["blue"]
  console.log(removed);	// ["red", "green"]
  ```

- **插入**

  需要给 `splice()` 传3个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。比如，`splice(2, 0, "red", "green")` 会从数组位置2开始插入字符串 "red" 和 "green" 。

  ``` js
  let colors = ["red", "green", "blue"]; 
  let removed = colors.splice(1, 0, "yellow", "orange"); // 在位置1插入两个元素
  console.log(colors);	// ["red", "yellow", "orange", "green", "blue"]
  console.log(removed);	// []
  ```

- **替换**

  `splice()` 在删除元素的同时可以在指定位置插入新元素，样要传入3个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。比如，`splice(2, 1, "red", "green")` 会在位置2删除一个元素，然后从该位置开始向数组中插入 "red" 和 "green"。

  ``` js
  let colors = ["red", "green", "blue"]; 
  let removed = colors.splice(1, 1, "red", "purple"); // 插入两个值，删除一个元素
  console.log(colors);	// ["red", "red", "purple", "blue"]
  console.log(removed);	// ["green"]
  ```

  **思考：**

  ```   js
  let colors = ["red", "green", "blue"];
  //写一个方法将colors所有的内容清空并替换为["yellow", "white"]
  ```

### 1.2.13 寻找下标

- **indexOf**

  从左到右搜索第一个===的下标。

  ``` js
  [1,2,3].indexOf(1);	// 0
  [1,2,3].indexOf('1');	// -1，因为不全等，找不到就返回-1
  [1,2,3,1,5,6].indexOf(1, 2);	// 3，第二个参数是从x下标开始搜索
  ```

- **lastIndexOf**

  从右往左搜索第一个===的下标。

  ``` js
  [1,2,3,1,5,7].lastIndexOf(1);	// 3
  [1,2,3,1,5,7,1,5].lastIndexOf(1, 100);	// 6 第二个参数是从x下标开始搜索
  [1,2,3,1,5,7,1,5].lastIndexOf(1, 5);	// 3
  ```

**思考：**

``` js
[1,2,3,1,5,6].indexOf(1, -2);	// ?
[1,2,3,1,5,6].indexOf(1, -3);	// ?   
[1,2,3,1,5,7,1,5].lastIndexOf(1, -7);	// ?
[1,2,3,1,5,7,1,5].lastIndexOf(1, -5);	// ? 3
```

### 1.2.14 includes

判断数组内是否有===的项。

``` js
[1,2,3,4,5,6].includes(1);	// true
[1,2,3,4,5,6].includes('1');	// false，因为不全等
[1,2,3,4,5,6].includes(8);	// false
```

### 1.2.15 find

根据条件查找数组内的单个项，根据条件查找项，只要返回true那就证明找到了，如果为false的话，那就继续遍历查找。

``` js
[1,2,3].find(c=> c === 1);	// 1
[1,2,3].find(c=> c == '1');	// 1
[1,2,3].find(c=> c === 5);	// undefined
[1,2,3].find(c=> c > 1);	// 2

const people = [{
    name: "Matt",
    age: 27
},
{
    name: "Nicholas",
    age: 29
}];
//三个参数分别是：当前遍历的项、当前下标、原始数组。
let p = people.find((element, index, array) => {
    console.log(element, index, array);
    return element.age > 28;
});
console.log(p);		// {name: "Nicholas", age: 29}
```

### 1.2.16 findIndex

根据条件查找数组内匹配项的下标。

``` js
[1,2,3].findIndex(c=> c === 3);	// 2
[1,2,3].findIndex(c=> c === 5);	// -1
[1,2,3].findIndex(c=> c > 1);	// 1
```

### 1.2.17 every

验证数组内每一个项是否匹配。

``` js
[1,2,3].every(c=> c === 3);	// false
[1,2,3].every(c=> c > 0);	// true
[1,2,3].every(c=> c < 10);	// true
[1,1,1].every(c=> c === 1);	// true
[1, 2, 3, 4, 5, 4, 3, 2, 1].every((item, index, array) => item > 2);    // false
```

### 1.2.18 some

验证数组内某一个项是否匹配。

``` js
[1,2,3].some(c=> c === 3);	// true
[1,2,3].some(c=> c > 0);	// true
[1,2,3].some(c=> c < 10);	// true
[1,1,1].some(c=> c === 1);	// true
[1,2,3].some(c=> c === 5);	// false
[1, 2, 3, 4, 5, 4, 3, 2, 1].some((item, index, array) => item > 2);     // true
```

### 1.2.19 filter

创建一个新数组，根据条件将搜索匹配的项放入至新数组内，并将此数组返回。

``` js
[1,2,3].filter(c=> c > 1);	// [2,3]
[1,2,3].filter(c=> c > 5);	// []
[1,2,3].filter(c=> c === 3);	// [3]
[1, 2, 3, 4, 5, 4, 3, 2, 1].filter((item, index, array) => item > 2);	//[3, 4, 5, 4, 3]
```

### 1.2.20 forEach

遍历每一个数组，传入回调函数，可对每一个项进行操作（用`return`无法停止，会遍历完所有的项）。

``` js
[1, 2, 3].forEach(c => {
    console.log(c * 2);
});
// 2 4 6

[1, 2, 3].forEach((item, index, array) => {
    console.log(item * index);
});
// 0 2 6
```

**思考：**

``` js
let numbers = [{ a: 1 }, { a: 2 }, { a: 3 }];
numbers.forEach((item, index, array) => {
    if (item.a > 1) {
        item.a = index;
    }
});
console.log(numbers);	// ?
```

### 1.2.21 flat

将多维数组扁平化，并返回一个新数组。方法接受一个数值，表示要扁平化的数组维度。

``` js
let ary = [1, [2, [3, [4, 5]]], 6];
console.log(ary.flat(1));	// [1, 2, Array(2), 6]
console.log(ary.flat());	// [1, 2, Array(2), 6]，不传参默认为1
console.log(ary.flat(2));	// [1, 2, 3, Array(2), 6]
console.log(ary.flat(3));	// [1, 2, 3, 4, 5, 6]
console.log(ary.flat(100));	// [1, 2, 3, 4, 5, 6]，可以超过维度深度，超过则会扁平化所有维度
console.log(ary.flat(Infinity));	//无限大的层数，表示可以扁平化所有维度
console.log(ary);	// [1, Array(2), 6]
```

### 1.2.22 map

遍历数组，针对每一个项返回一个新值，将新值放进新数组里，最后将新数组返回。

``` js
[1, 2, 3].map(c => {
    return c * 2;
});	// [2,4,6]

[1, 2, 3].map(c => {
    return 2;
});	// [2,2,2]

[1, 2, 3].map((item, index, array) => {
    return item * index;
});	// [0,2,6]

[{ a: 1 }, { a: 2 }, { a: 3 }, { a: 4 }, { a: 5 }].map(c => c.a);	// [1, 2, 3, 4, 5]
```

**思考：**

``` js
[1, 2, 3].map((item, index, array) => {
    return index;
});	// ?

[1, 2, 3].map((item, index, array) => {
    return index * array.length;
});	// ?

let numbers =[{ a: 1 }, { a: 2 }, { a: 3 }, { a: 4 }, { a: 5 }];
//请使用map方法将numbers数据变为[3,6,9,12,15]

//请使用map方法将numbers数据变为[3,6,9,8,10]

let numbers = [{ a: 1, b: 10 }, { a: 2, b: 10 }, { a: 3, b: 10 }, { a: 4, b: 10 }, { a: 5, b: 10 }];
//请使用map方法将numbers数据变为[9,8,7,6,5]
```

### 1.2.23 join

数组拼接成字符串方法，方法传入拼接关键字。

``` js
[1,2,3].join(',');	// '1,2,3'
```

**思考：**

``` js
[{ a: 1 }, { a: 2 }].join(',');	// ?

let persons = [{ age: 50 }, { age: 12 }, { age: 30 }];
//请写一个方法将persons变为 '12,30,50'
```

### 1.2.24 pop

从原数组取出最后一个项。

``` js
let numbers = [1,2,3,4,5];
numbers.pop();	// 5
console.log(numbers);   // [1,2,3,4]

let empty = [];
empty.pop();	// undefined
console.log(empty);	// []
```

### 1.2.25 shift

从原数组取出第一个项。

``` js
let numbers = [1,2,3,4,5];
numbers.shift();    // 1
console.log(numbers);   // [2,3,4,5]
```

### 1.2.26 unshift

在原数组的头部添加随意数量的项，并返回添加后数组的长度。

``` js
let numbers = [1, 2, 3, 4, 5];
let length = numbers.unshift(7, 8, 9);
console.log(length);    // 8
console.log(numbers);   // [7, 8, 9, 1, 2, 3, 4, 5]
```

## 1.3 Set

Set是一个无法添加重复值的集合。

``` js
const set = new Set();	//创建一个空集合

const s1 = new Set(["val1", "val2", "val3"]);	// 使用数组初始化集合
console.log(s1.size);		// 3,长度访问跟数组的length不一样
s1.add("Matt").add("Frisbie");	//可以链式添加
s1.has('Matt');	// true，是否存在指定的项
console.log(s1);	// Set(5) {"val1", "val2", "val3", "Matt", "Frisbie"}
s1.add("Matt");
console.log(s1);	// Set(5) {"val1", "val2", "val3", "Matt", "Frisbie"}，无法添加重复项

let deleted = s1.delete('Matt');	// delete方法返回删除结果
console.log(deleted);   // true
console.log(s1);    // Set(4) {"val1", "val2", "val3", "Frisbie"}

deleted = s1.delete('Matt');
console.log(deleted);   // false，无法重复删除

//可通过for of访问每个项
for (let item of s1) {
    console.log(item);
}
//val1 val2  val3 Frisbie

//也可通过forEach方法访问
s1.forEach(item => console.log(item));
```

> **Set的经典应用-去重**

``` js
let numbers = [1, 2, 3, 5, 6, 1, 2, 3];
numbers = Array.from(new Set(numbers));
console.log(numbers);   // [1, 2, 3, 5, 6]
```

**思考：**

``` js
let chars = ['a', 'b', 'c', 'a', 'c', 'd'];
// 将chars去重
```

**作业：**

``` js
let objs = [{ count: 20 }, { count: 66 }, { count: 16 }, { count: 30 }, { count: 5 }, { count: 20 }, { count: 66 }];
//使用objs打印 "5,16,20,30,66"

//使用objs打印 "20,30,66"
```

# 第八章

## 第8章对象、类与面向对象编程

本章内容:

```
1理解对象
2理解对象创建过程
3理解继承
4理解类
```

### 理解对象

```
	举个栗子，比如一台笔记本电脑，我们将它视为一个对象无非是为了能够更加抽象地描述它，这在编程的过程中很重要，来看看它有哪些需要抽象出来的特性吧~
    在生活中大家应该很熟悉，当你在买一台新的笔记本电脑时，主要考虑的是什么？———笔记本电脑的屏幕大小、屏幕形状、机身总重量、硬盘空间、CPU频率、操作系统……这些都是“笔记本电脑”这个对象所固有的一些性能或制造的参数，这些可以标识出这台笔记本电脑是否受到顾客的欢迎。
    但是，对于现实世界中的一台洗衣机，要考虑的特性就完全不是上面的那些参数和特性了，更多的是会去关注它的容积、耗电量、噪音大小等。还有，对于一架航天飞机，它要考虑的特性会更多，对于一支钢笔，一把伞，针对它们要考虑的就会相对要少一些……从这些例子来看，世间万物的复杂程度不同，我们对它们的关心方面就不同，相应地从它们这些具体事物中抽象出的对象也会各有差别。
```

### 创建对象：

```js
	虽然使用Object构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：创建具有同样接口的多个对象需要重复编写很多代码。
	
1、 new 操作符 + Object 创建对象
var person = new Object();
    person.name = "lisi";
    person.age = 21;
    person.family = ["lida","lier","wangwu"];
    person.say = function(){
        alert(this.name);
    }

2、字面式创建对象
var person ={
        name: "lisi",
        age: 21,
        family: ["lida","lier","wangwu"],
        say: function(){
            alert(this.name);
        }
    };

3、工厂模式
function createPerson(name,age,family) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.family = family;
    o.say = function(){
        alert(this.name);
    }
    return o;
}

var person1 =  createPerson("lisi",21,["lida","lier","wangwu"]);   //instanceof无法判断它是谁的实例，只能判断他是对象，构造函数都可以判断出
var person2 =  createPerson("wangwu",18,["lida","lier","lisi"]);
console.log(person1 instanceof Object);                           //true

4、构造函数模式
function Person(name,age,family) {
    this.name = name;
    this.age = age;
    this.family = family;
    this.say = function(){
        alert(this.name);
    }
}
var person1 = new Person("lisi",21,["lida","lier","wangwu"]);
var person2 = new Person("lisi",21,["lida","lier","lisi"]);
console.log(person1 instanceof Object); //true
console.log(person1 instanceof Person); //true
console.log(person2 instanceof Object); //true
console.log(person2 instanceof Person); //true
console.log(person1.constructor);      //constructor 属性返回对创建此对象的数组、函数的引用

5、原型模式
function Person() {
}

Person.prototype.name = "lisi";
Person.prototype.age = 21;
Person.prototype.family = ["lida","lier","wangwu"];
Person.prototype.say = function(){
    alert(this.name);
};
console.log(Person.prototype);   //Object{name: 'lisi', age: 21, family: Array[3]}

var person1 = new Person();        //创建一个实例person1
console.log(person1.name);        //lisi

var person2 = new Person();        //创建实例person2
person2.name = "wangwu";
person2.family = ["lida","lier","lisi"];
console.log(person2);            //Person {name: "wangwu", family: Array[3]}
// console.log(person2.prototype.name);         //报错
console.log(person2.age);              //21

6、混合模式（构造函数模式+原型模式）
function Person(name,age,family){
    this.name = name;
    this.age = age;
    this.family = family;
}

Person.prototype = {
    constructor: Person,  //每个函数都有prototype属性，指向该函数原型对象，原型对象都有constructor属性，这是一个指向prototype属性所在函数的指针
    say: function(){
        alert(this.name);
    }
}

var person1 = new Person("lisi",21,["lida","lier","wangwu"]);
console.log(person1);
var person2 = new Person("wangwu",21,["lida","lier","lisi"]);
console.log(person2);
```

### 继承

```
　一、原型链继承
　重点：让新实例的原型等于父类的实例。
　　　　特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）
　　　　缺点：1、新实例无法向父类构造函数传参。
　　　　　　　2、继承单一。
　　　　　　　3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）
　　　　　　　
　二、借用构造函数继承　
　　重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））
　　　　特点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。
　　　　　　　2、解决了原型链继承缺点1、2、3。
　　　　　　　3、可以继承多个构造函数属性（call多个）。
　　　　　　　4、在子实例中可向父实例传参。
　　　　缺点：1、只能继承父类构造函数的属性。
　　　　　　　2、无法实现构造函数的复用。（每次用每次都要重新调用）
　　　　　　　3、每个新实例都有父类构造函数的副本，臃肿。
　　　　　　　
　三、组合继承（组合原型链继承和借用构造函数继承）（常用）
　重点：结合了两种模式的优点，传参和复用
　　　　特点：1、可以继承父类原型上的属性，可以传参，可复用。
　　　　　　　2、每个新实例引入的构造函数属性是私有的。
　　　　缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。
　　　　
　四、原型式继承
　　重点：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。
　　　　特点：类似于复制一个对象，用函数来包装。
　　　　缺点：1、所有实例都会继承原型上的属性。
　　　　　　　2、无法实现复用。（新实例属性都是后面添加的）
　　　　　　　
　五、寄生式继承
　　重点：就是给原型式继承外面套了个壳子。
　　　　优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。
　　　　缺点：没用到原型，无法复用。
　
　六、寄生组合式继承（常用）
　寄生：在函数内返回对象然后调用
　　　　组合：1、函数的原型等于另一个实例。2、在函数中用apply或者call引入另一个构造函数，可传参　
　　　　　重点：修复了组合继承的问题

　　　　继承这些知识点与其说是对象的继承，更像是函数的功能用法，如何用函数做到复用，组合，这些和使用继承的思考是一样的。上述几个继承的方法都可以手动修复他们的缺点，但就是多了这个手动修复就变成了另一种继承模式。
　　　　这些继承模式的学习重点是学它们的思想，不然你会在coding书本上的例子的时候，会觉得明明可以直接继承为什么还要搞这么麻烦。就像原型式继承它用函数复制了内部对象的一个副本，这样不仅可以继承内部对象的属性，还能把函数（对象，来源内部对象的返回）随意调用，给它们添加属性，改个参数就可以改变原型对象，而这些新增的属性也不会相互影响。
```

### 类

```js
类声明:
定义类有2中方式，类声明和类表达式：
// 类声明
class Student {}
// 类表达式
const Student = class {}

为什么说它是语法糖
因为类实际上它是一个function，区别在于构造函数是函数作用域，类是块级作用域，类中的方法，都是定义在类的prototype上面，所以文章开头说它还是构造函数和原型的概念

类包含的属性和方法
类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。

类的构造函数
类的构造函数关键字是constructor，它同等于原型中的prototype.constructor。
如果没有写constructor函数，那么会默认有一个空的constructor函数。
```

### 5.2 作用域链

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

函数有一个内部属性`[scope]`，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解`[scope]`就是所有父变量对象的层级链。

```js
function foo() {
    function bar() {
        //更多代码
    }
}
```

函数创建时，各自的`[scope]`为：

```js
foo.[scope] = [
  globalContext.VO
];

bar.[scope] = [
    fooContext.AO,
    globalContext.VO
];
```

子作用域可以访问父作用域的变量，父作用域不能访问子作用域的变量（只能自下往上查找，不能自上往下查找）。

```js
function parent() {
    var a = 1;
    function child() {
        var b = 2;
        console.log(a); //可以访问到parent中的a
    }
    console.log(b);     //报错，因为访问不到child中的b
}
```

## 5.3 this

前面已经提到`javascript`采用的是静态作用域，但是`this`算是模仿了动态作用域，`this`是在执行阶段时确定的。

### 5.3.1 默认绑定

不带任何修饰的函数进行调用的，只能采用默认绑定，`this`指向全局。严格模式下不能将全局对象用于默认绑定，因此`this`会绑定到`undefined`。

```js
function foo () {
    console.log(this);	//window
    console.log(this.a);
}
var a = 12;
foo();  //12
```

```js
function a() {
    console.log('a', this);	//'a' window
}
function b() {
    a();
    console.log('b', this);	//'b' window
}
function c() {
    b();
    console.log('c', this);	//'c' window
}
c();
```

### 5.3.2 隐式绑定

对象内部包含一个指向函数的属性，并通过这个属性间接引用这个函数，从而把`this`间接（隐式）绑定到这个对象上。

+ 无论是直接在`obj`中定义还是再添加为引用属性，这个函数严格来说都不属于`obj`对象。

```js
function foo() {
    console.log(this);	//{a: 2, foo: ƒ}
    console.log(this.a);	//2
}

var obj = {
    a: 2,
    foo: foo
}
obj.foo();

var obj = {
    a: 2,
    foo: function() {
        console.log(this);	//{a: 2, foo: ƒ}
        console.log(this.a);	//2
    }
}
obj.foo();
```

+ 调用位置会使用`obj`上下文来引用函数，因此你可以说函数被调用时`obj`对象“拥有”或者“包含”函数引用。当`foo()`被调用时，它的前面确实加上了对`obj`的引用，当函数引用有上下文对象时，隐式绑定规则会把函数调用中的`this`绑定到这个上下文对象。因此调用`foo()`时`this`被绑定到`obj`，因此在函数中执行`this.a`和`obj.a`是一样的。
+ 对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。

```js
function foo() {
    console.log(this.a);
}

var obj2 = {
    a: 1,
    foo: foo
}

var obj1 = {
    a: 2,
    obj2: obj2
}
obj1.obj2.foo();    //1

var obj3 = {
    a: 3,
    obj1: obj1
}
obj3.obj1.obj2.foo();	//1
```

### 5.3.3 显示绑定

`call`,`apply`,`bind`都属于显式绑定一类，显示绑定后`this`便无法再修改。

```js
function foo() {
    console.log(this);	//{a: 2}
    console.log(this.a);  //2
}
var obj = {
    a: 2
}
foo.call(obj);
```

### 5.3.4 new绑定

实例化一个新对象后，会将实例对象绑定到函数调用中的`this`上。

```js
function foo(a) {
    console.log(this);	//foo {}
    this.a = a;
    console.log(this.a);	//2
}
var bar = new foo(2);
console.log(bar.a); //2
console.log(a);	//Uncaught ReferenceError: a is not defined
```

### 5.3.5 箭头函数

`es6`新增的`()=>`箭头函数中，`this`在分析阶段时就确定了（跟函数中的`this`在执行阶段时确定相反），绑定的是父作用域中的`this`，指向永远不变。其实总结起来就两点：

+ 外层有函数：外层函数的`this`就是箭头函数的`this`。

```js
function ab() {
    var b = () => {
        console.log(this);
    };
    b();
}
ab();   //window，因为外层函数的this采用了默认绑定规则
```

```js
var obj = {
    a: 1,
    foo() {
        var fn = () => {
            console.log(this.a);
        };
        fn();
    }
}
obj.foo();  //1，外层函数的this采用了隐式绑定规则
```

外层没有函数：箭头函数的`this`就是`window`。

```js
var a = 123;
var obj = {
    a: 1,
    foo: () => {
        console.log(this.a);
    }
}
obj.foo();  //123
```

### 2.1 对象属性的类型

### 2.1.1 configurable（可配置）

表示属性是否可以通过`delete`删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 `true`。

``` js
let person = {};
Object.defineProperty(person, "name", {
    configurable: false,
    value: undefined
});
console.log(person);    //{name: undefined}
delete person.name;  //false
console.log(person);    //{name: undefined}
```

``` js
let person = {};
Object.defineProperty(person, "name", {
    configurable: true,
    value: undefined
});
console.log(person);    //{name: undefined}
delete person.name;  //true
console.log(person);    //{}
```

``` js
let person = {};
Object.defineProperty(person,
    "name", {
    configurable: false,
    value: "Nicholas"
});
//Uncaught TypeError: Cannot redefine property: name
Object.defineProperty(person, "name", {
    configurable: true,
    value: "Nicholas"
});
```

### 2.1.2 enumerable

表示属性是否可以通过`for-in`循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是`true`。 

``` js
let person = {};
Object.defineProperties(person, {
    name: {
        enumerable: false
    },
    sex: {
        enumerable: true
    },
    age: {
        enumerable: true
    }
});
for (let key in person) {
    console.log(key);
}
// sex
// age
```

### 2.1.3 writable

表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是`true`。

``` js
var obj = {};
Object.defineProperties(obj, {
    sex: {
        value: '男',
        writable: true
    },
    name: {
        value: '张三',
        writable: false
    }
});
obj.name = '李四';
obj.sex = '女';
console.log(obj);   //{sex: "女", name: "张三"}
```

### 2.1.4 value

包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为`undefined`。

``` js
let person = {};
Object.defineProperty(person, "name", {
    value: "Nicholas"
});
console.log(person.name);   //Nicholas
```

### 2.1.5 get

获取函数，在读取属性时调用。默认值为`undefined`。

``` js
let book = {
    year_: 2017, 
    edition: 1
};
Object.defineProperty(book, "year", {
    get() {
        return this.year_;
    }
});
console.log(book.year); // 2017
console.log(book.edition); // 1
```

### 2.1.6 set

设置函数，在写入属性时调用。默认值为`undefined`。

``` js
let book = {
    year_: 2017, 
    edition: 1
};
Object.defineProperty(book, "year", {
    get() {
        return this.year_;
    },
    set(newValue) {
        if (newValue > 2017) {
            this.year_ = newValue;
            this.edition += newValue - 2017;
        }
    }
});
book.year = 2018;
console.log(book.year); // 2018
console.log(book.edition); // 2
```

## 2.2 getOwnPropertyDescriptor

获取指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含属性的类型。

``` js
let book = { name: '张三' };
console.log(Object.getOwnPropertyDescriptor(book, 'name'));	//{value: "张三", writable: true, enumerable: true, configurable: true}
```

## 2.2 getOwnPropertyDescriptors

方法用来获取一个对象的所有自身属性的描述符。

``` js
let book = { name: '张三', age: 12 };
console.log(Object.getOwnPropertyDescriptors(book));
/**
{
    age: { value: 12, writable: true, enumerable: true, configurable: true }
    name: { value: "张三", writable: true, enumerable: true, configurable: true }
}
*/
```

## 2.3 合并对象

在`es6`之前，通常会封装一个方法，可参考`jqeury`的[`extend`](https://www.runoob.com/jquery/misc-extend.html)方法。

``` js
var obj = {
    a: 1,
    b: 2
}
var obj1 = {
    c: 3,
    a: 5
}
{
    a: 5,
    b: 2,
    c: 3
}
```

``` js
//一个特别简单的浅拷贝
function extend(target, source) {
    target = target || {};
    if (typeof target !== 'object') {
        throw new Error('target不是对象');
    }
    if (!source) {
        throw new Error('source不能为空');
    }
    if (typeof source !== 'object') {
        throw new Error('source不是对象');
    }
    for (let key in source) {
        target[key] = source[key];  //然后将源对象的值赋值到target中
    }
    return target;  //最后返回target
}

var obj = extend({
    a: 1,
    b: 2
}, {
    c: 3,
    a: 5
})
/**
{
    a: 5,
    b: 2,
    c: 3
}
*/
```

> **Object.assign**

用于对象的合并，将源对象`（source）`的所有可枚举属性，复制到目标对象`（target）`。源对象可以是多个，后者替换前者。

``` js
let obj = Object.assign({ a: 1 }, { b: 2 }, { c: 3 }, { a: 5 }, { b: 6 });
//{a: 5, b: 6, c: 3}
```

**出现的问题：**

以上方法都是**浅拷贝**，如果拷贝属性是对象，那么拷贝的只是引用。

``` js
var obj = {
    a: 1,
    b: 'fff'
}
var obj1 = {
    a: 2,
    c: {
        name: '李四',
        age: 20
    }
}
var obj2 = Object.assign({}, obj, obj1);
obj1.a = 3;
obj1.c.name = '王五';
obj1.c.age = 30;
console.log(obj2);	//obj2.c会跟着obj1.c的改变而改变
```

> **深拷贝**

``` js
//深拷贝
function deepClone(target, source) {
    if (typeof target !== 'object' || !target) {
        return source || target;
    }
    if (typeof source !== 'object' || !source) {
        return source;
    }
    for (let key in source) {
        var item = source[key];
        if (typeof item === 'object' && item) {
            target[key] = deepClone(Array.isArray(item) ? [] : {}, item);
        } else {
            target[key] = item;
        }
    }
    return target;
}

var obj = {
    a: 1,
    b: 'fff'
}
var obj1 = {
    a: 2,
    c: {
        name: '李四',
        age: 20
    }
}
var obj2 = deepClone(obj, obj1);
obj1.a = 3;
obj1.c.name = '王五';
obj1.c.age = 30;
console.log(obj2);	//obj2.c不会跟着obj1.c的改变而改变
```

## 2.4 解构

``` js
// 使用对象解构
let person = { name: 'Matt', age: 27 };
//可以使用别名 personAge
//相当于 let name = person.name;
//相当于 let personAge = person.age;
let { name, age: personAge } = person;
console.log(name, personAge);	//Matt   27
```

``` js
let person = { name: 'Matt', age: 27 };
let { job } = person;	//不存在的也可以解构，其实就相当于   let job = person.job;
console.log(job);	//undefined
```

``` js
let person = { name: 'Matt', age: 27, sex: null };
//也可以设置一个默认值，如果获取的值为undefined的话
//注：如果获取的值为null则不会取默认值，而是直接设置为null
let { name, job='Software engineer', sex = '男' } = person; 
console.log(name); // Matt 
console.log(sex);	//null
console.log(job); // Software engineer
```

``` js
//无法解构null和undefined
let { _ } = null; // TypeError
let { _ } = undefined; // TypeError
```

``` js
const [n1, n2, { a }] = [1, 2, { a: 3 }];	//解构数组
console.log(n1, n2, a); // 1 2 3
```

**思考：**

``` js
const data = [
    {
        name: '张三',
        age: 50,
        sex: '男',
        children: [
            {
                name: '张琳',
                sex: '女',
                age: 20
            }
        ]
    },
    {
        name: '王五',
        age: 25,
        sex: undefined
    }
];
//把每个人的 name,age,sex解构出来，没有sex的设置默认值：男，重名的设置别名
```

## 2.5 创建对象

**思考：**假如现在有个需求，要创建5个人物对象，需要有名字、年龄、工作，大家会怎么写？

**千万不要一个一个对象的去定义，不要重复相同的劳动，毫无意义！！！**

### 2.5.1 简单工厂模式

简单理解工厂就是有一条标准化的流水线，只要输入参数就能按照标准流程生产出需要的产品。

``` js
function createPerson(name, age, job) {
    let o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function () {
        console.log(this.name);
    };
    return o;
}
let person1 = createPerson("Nicholas", 29, "Software Engineer");
let person2 = createPerson("Greg", 27, "Doctor");
```

### 2.5.2 构造函数模式

``` js
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function () {
        console.log(this.name);
    };
}

let person1 = new Person("Nicholas", 29, "Software Engineer"); 
let person2 = new Person("Greg", 27, "Doctor"); 
person1.sayName(); // Nicholas 
person2.sayName(); // Greg
console.log(person1.constructor == Person); // true 
console.log(person2.constructor == Person); // true

console.log(person2 instanceof Object); // true 
console.log(person2 instanceof Person); // true
```

``` js
//写成函数表达式也行
let Person = function (name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function () {
        console.log(this.name);
    };
}

let person1 = new Person("Nicholas", 29, "Software Engineer"); 
let person2 = new Person("Greg", 27, "Doctor"); 
person1.sayName(); // Nicholas 
person2.sayName(); // Greg
console.log(person1.constructor == Person); // true 
console.log(person2.constructor == Person); // true

console.log(person2 instanceof Object); // true 
console.log(person2 instanceof Person); // true
```

**缺陷：**每次`sayName`方法都要重新定义一次，其实这个方法只需定义一次即可。

### 2.5.3 原型模式

``` js
function Person() { }
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function () {
    console.log(this.name);
};
```

**缺陷：** 1. 原型上的对象数据会被共享，一个对象改了，其他对象也会跟着变。2. 创建对象不方便。

> **改良**

``` js
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
}
//将无需重复定义/共享的定义在原型上
Person.prototype.sayName = function () {
    console.log(this.name);
};

let person1 = new Person("Nicholas", 29, "Software Engineer"); 
let person2 = new Person("Greg", 27, "Doctor"); 
person1.sayName(); // Nicholas 
person2.sayName(); // Greg
```

## 2.6 hasOwnProperty

`hasOwnProperty()`方法用于确定某个属性是在实例上还是在原型对象上。

``` js
function Person() { }
Person.prototype.age = 12;
let person1 = new Person;
person1.age = 20;
console.log(person1.age);	//20
console.log(person1.hasOwnProperty("age"));	//true	来自实例
delete person1.age;
console.log(person1.age);	//12
console.log(person1.hasOwnProperty("age"));	//false	来自原型
```

> **in**

`in`操作符会在可以通过对象访问指定属性时返回`true`，无论该属性是在实例上还是在原型上。

``` js
function Person() { }
Person.prototype.age = 12;
let person1 = new Person;
person1.age = 20;
console.log(person1.age);	//20
console.log(person1.hasOwnProperty("age"));	//true	来自实例
'age' in person1;	//true
delete person1.age;
console.log(person1.age);	//12
console.log(person1.hasOwnProperty("age"));	//false	来自原型
'age' in person1;	//true
```

**思考**：

如何判断一个属性是来自原型而不是来自实例呢？

## 2.7 keys

`Object.keys()`方法接收一个对象作为参数，返回包含该对象所有可枚举的实例属性名称的字符串数组。

``` js
Object.keys({ a: 1, b: 2, c: 3 });  //["a", "b", "c"]
```

## 2.8 getOwnPropertyNames

`Object.getOwnPropertyNames()`方法可以获取所有实例属性，无论是否可以枚举。

``` js
function Person() {
    this.sex = '男';
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function () {
    console.log(this.name);
};
var p = new Person();
console.log(Object.getOwnPropertyNames(p)); //?
```

## 2.9 values

 `Object.values()`返回对象值的数组。

``` js
const o = {
    foo: 'bar',
    baz: 1,
    qux: {}
};
console.log(Object.values(o)); // ["bar", 1, {}]
```

## 2.10 entries

 `Object.entries()` 接收一个对象，返回键/值对的数组。

``` js
const o = {
    foo: 'bar',
    baz: 1,
    qux: {}
};
console.log(Object.entries(o));	// [["foo", "bar"], ["baz", 1], ["qux", {}]]
```

**思考：**

``` js
const o = {
    foo: 'bar',
    baz: 1,
    qux: {}
};
Object.entries(o);	//用解构将所有的key和value解构出来
```

## 2.11 原型

 每个对象都有一个特殊的属性叫作`原型（prototype）`，在原型上定义的属性和方法会被每一个实例对象共享。

``` js
function Person() { }
Person.prototype.name = "无名";
Person.prototype.children = [];
Person.prototype.sayName = function () {
    console.log(`我的名字叫：${this.name}`);
}

let zhangsan = new Person();
let lisi = new Person();
console.log(zhangsan.name);
console.log(lisi.name);
console.log(zhangsan.hasOwnProperty('name'));
zhangsan.name = '张三';
console.log(zhangsan.hasOwnProperty('name'));
console.log(lisi.name);
Person.prototype.name = '有名';
console.log(lisi.name);
console.log(zhangsan.name);
delete zhangsan.name;
console.log(zhangsan.name);

lisi.name = '李四';
console.log(zhangsan.sayName());
console.log(lisi.sayName());
console.log(zhangsan.sayName === lisi.sayName);

zhangsan.children.push('张欣');
console.log(zhangsan.children);
console.log(lisi.children);
console.log(zhangsan.hasOwnProperty('children'));
console.log(zhangsan.children === lisi.children);
//?
```

## 2.12 原型链

每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个内部指针指向另一个构造函数的原型对象，这样就在实例和原型之间构造了一条原型链。

```` js
function Person() { }
Person.prototype.constructor === ?;
Person.prototype.constructor.prototype === ?;
Person.prototype.__proto__ === ?

let zhangsan = new Person;
zhangsan.constructor === Person;
zhangsan.__proto__ === ?;
zhangsan.__proto__.__proto__ === ?
````

``` js
let obj = new Object();
obj.__proto__ === ?;
obj.__proto__.__proto__ === ?
```

## 2.13 面向过程

现在有个需求：创建一个人，张三、男、20岁。

``` js
let zhangsan = new Object;
zhangsan.name = '张三';
zhangsan.age = 20;
zhangsan.sex = '男';
```

又新来了一个需求：创建一个人，李四、男、30岁。

``` js
let lisi = new Object;
lisi.name = '李四';
lisi.age = 30;
lisi.sex = '男';
```

随着需求的不断增加，已经添加了1000个人。

``` js
let zhangsan = new Object;
zhangsan.name = '张三';
zhangsan.age = 20;
zhangsan.sex = '男';

let lisi = new Object;
lisi.name = '李四';
lisi.age = 30;
lisi.sex = '男';
//...........剩下的3992行代码
```

然后突然有一天新增了一个需求：将所有年龄>=20的标记为青年，<20的标记为少年。

``` js
let zhangsan = new Object;
zhangsan.name = '张三';
zhangsan.age = 20;
zhangsan.sex = '男';
zhangsan.type = '青年';

let lisi = new Object;
lisi.name = '李四';
lisi.age = 30;
lisi.sex = '男';
zhangsan.type = '青年';
//...........剩下的4990行代码
```

突然有一天，又要为每个人新增一个行为：能自我介绍。

...........更多的需求

**思考：**面向过程的痛点是什么？怎么去解决它？

## 2.14 面向对象

将任何事物都想象成一个对象，并提炼出这个对象的属性、行为等，然后封装起来。

需求：创建一个人，张三、男、20岁。

此刻，首先需将人想象为一个对象，目前给出的三个属性是姓名、性别、年龄，将封装思想用起来。

``` js
function Person(name, age, sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
}

let zhangsan = new Person('张三', 20, '男');
```

又新来了一个需求：创建一个人，李四、男、30岁。

``` js
let lisi = new Person('李四', 30, '男');
```

随着需求的不断增加，已经添加了1000个人。

``` js
function Person(name, age, sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
}

let zhangsan = new Person('张三', 20, '男');
let lisi = new Person('李四', 30, '男');
//...   剩下的998行代码
```

然后突然有一天新增了一个需求：将所有年龄>=20的标记为青年，<20的标记为少年。

``` js
function Person(name, age, sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
    //只需在构造函数里新增一个判断即可，其他每个实例都不用动
    if (this.age >= 20) {
        this.type = '青年';
    }
    else {
        this.type = '少年';
    }
}
```

突然有一天，又要为每个人新增一个行为：能自我介绍。

``` js
function Person(name, age, sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
    if (this.age >= 20) {
        this.type = '青年';
    }
    else {
        this.type = '少年';
    }
}

Person.prototype.say = function () {
    console.log(`我是${this.name}，我今年${this.age}岁了，我是个${this.sex}人，算是${this.type}了`);
}

let zhangsan = new Person('张三', 20, '男');
let lisi = new Person('李四', 30, '男');
//...  剩下的998行代码
console.log(zhangsan.say());
console.log(lisi.say());
```

##  2.15 继承

继承就是子继承父的所有属性和方法，如：父亲的基因被儿子继承，所以通过DNA（原型链）可追溯某人的向上继承关系。从技术上来讲就是继承父对象的所有属性和方法。

``` js
function Father() {
    this.money = 10000000000;   //百亿家产
    this.houses = 10;   //10栋别墅
    this.cars = 100;    //100辆车
}

function Son() {
    Father.call(this);  //继承父亲的家产
}

let son = new Son;
console.log(son.money, son.houses, son.cars);   //10000000000 10 100
```

### 2.15.1 原型式继承

``` js
function superType() {
    this.name = '张三';
    this.children = ['张欣', '张宇'];
}
superType.prototype.age = 12;
function sub() {
}
sub.prototype = new superType();
var s = new sub();
console.log(s.name, s.age);    //张三 12
console.log(s.hasOwnProperty('name'));  //false
console.log(s.hasOwnProperty('children'));  //false

var s1 = new sub();
s1.children.push('李四');
console.log(s1.children);
console.log(s.children);

console.log(s.constructor === superType);   //true
console.log(s instanceof sub);  //true
console.log(s instanceof superType);    //true
```

### 2.15.2 盗用构造函数

``` js
function superType() {
    this.name = '张三';
    this.children = ['张欣', '张宇'];
}
superType.prototype.age = 12;
function sub() {
    superType.call(this);
}

var s = new sub();	//从sub派生出来的，继承自sub
console.log(s.name);    //张三
console.log(s.hasOwnProperty('name'));  //true
console.log(s.hasOwnProperty('children'));  //true

var s1 = new sub();
s1.children.push('李四');
console.log(s1.children);
console.log(s.children);

console.log(s.constructor === sub);   //true
console.log(s instanceof sub);  //true
console.log(s instanceof superType);    //false
//目前为止一切看起来都正常了
console.log(s.age, s1.age);
```

### 2.15.3 组合继承

组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。

``` js
function superType() {
    console.log('superType执行了一次');
    this.name = '张三';
    this.children = ['张欣', '张宇'];
}
superType.prototype.age = 12;
function sub() {
    superType.call(this);
}

//直接继承原型，不用再次实例化父类构造函数，防止再次执行父类构造函数
//sub.prototype = Object.create(superType.prototype, { constructor:{ value:sub, enumerable:false } });

//跟上面的一样，只是最后自己手动修改一下构造函数的指向
sub.prototype = Object.create(superType.prototype)
sub.prototype.constructor = sub;

//使用浅拷贝的方式将自身的构造函数替换掉父类原型的构造函数
//sub.prototype = Object.assign(Object.create(superType.prototype), { constructor: sub });

var s = new sub();
console.log(s.name);    //张三
console.log(s.hasOwnProperty('name'));  //true
console.log(s.hasOwnProperty('children'));  //true

var s1 = new sub();
s1.children.push('李四');
console.log(s1.children);
console.log(s.children);

console.log(s.constructor === sub);   //true
console.log(s instanceof sub);  //true
console.log(s instanceof superType);    //true
console.log(s.age, s1.age);     //12 12
```

## 2.16 class类

与函数类型相似，定义类也有两种主要方式：类声明和类表达式。这两种方式都使用`class`关键字加大括号。类其实就是语法糖。

``` js
// 类声明
class Person {} 
// 类表达式
const Animal = class {};
```

函数可以提升，但是类不能提升。

``` js
console.log(ClassDeclaration); //ReferenceError: ClassDeclaration is not defined
class ClassDeclaration {}

//同样也受到块级作用域的限制
{ 
    function FunctionDeclaration() {} 
	class ClassDeclaration {} 
}
console.log(FunctionDeclaration);	//FunctionDeclaration() {} 
console.log(ClassDeclaration);	//ReferenceError: ClassDeclaration is not defined
```

### 2.16.1 类的构成

类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。默认情况下，**类定义中的代码都在严格模式下执行**。

``` js
// 空类定义，有效
class Foo {} 
// 有构造函数的类，有效
class Bar { 
    constructor() {} 
}
// 有获取函数的类，有效
class Baz { 
    get myBaz() {} 
}
// 有静态方法的类，有效
class Qux { 
    static myQux() {} 
}
```

``` js
class Person {
    constructor() {}

    name = '张三';
    _age = 17;
    children = [];

    say() {
        console.log(`我的名字叫：${this.name}`);
    }

    static isPerson(person) {
        return person instanceof Person;
    }

    get type() {
        if (this._age > 18) {
            return '青年';
        }
        return '少年';
    }

    get age() {
        return this._age;
    }

    set age(value) {
        if (value > 0 && value < 120) {
            this._age = value;
        }
    }
}

let person = new Person();
console.log(person.age, person.type);
person.age = 0;
console.log(person.age);
person.age = 20;
console.log(person.type);
console.log(Person.isPerson(person), Person.isPerson(new Object()));
console.log(person.hasOwnProperty('name'), person.hasOwnProperty('children'));
```

### 2.16.2 类构造函数

`constructor`关键字用于在类定义块内部创建类的构造函数。方法名`constructor`会告诉解释器在使用`new`操作符创建类的新实例时，应该调用这个函数。

``` js
class Animal { }
class Person {
    constructor() {
        console.log('person ctor');
    }
}
class Vegetable {
    constructor(color) {
        this.color = color;
    }
}
let a = new Animal();
let p = new Person(); // person ctor 
let v = new Vegetable('orange');
console.log(v.color); // orange
```

``` js
//和下面代码等价
function Person() {
    console.log('person ctor');
}
function Vegetable(color) {
    this.color = color;
}
let p = new Person(); // person ctor 
let v = new Vegetable('orange');
console.log(v.color); // orange
```

> **super**

>>>>>>> remotes/teachter/master
`super`表示父对象。

``` js
class Father {
    constructor(name, age, sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
<<<<<<< HEAD

    money = 0;	//总钱数

	//挣钱
    makeMoney(money) {
        this.money += money;
        console.log(`这次赚了${money}，到目前为止总共已经赚了${this.money}了。`);
    }

    say() {
        console.log(`我叫${this.name}，今年${this.age}岁。`);
    }
}

class Son extends Father {
    constructor(name, age, sex) {
        super(name, age, sex);  //super作为父类构造函数只能用在子类构造函数中
    }

    say() {
        //super();	//报错
        super.say();
        console.log('我是我父亲的儿子，还在读大学');
    }
}

let son = new Son('张三', 20, '男');
son.makeMoney(1000);
son.makeMoney(100);
son.say();
```

``` js
//人（基类）基本类
class Person {
    constructor(name, age, sex, skin, country) {
        this.name = name;
        this.age = age;
        this.sex = sex;
        this.skin = skin;
        this.country = country;
    }

    //定义的函数（自我介绍）
    introduction() {
        console.log(`我叫${this.name}，今年${this.age}岁了，性别：${this.sex}，国籍：${this.country}，肤色：${this.skin}`);
    }
}

//黄种人
class YellowPerson extends Person {
    constructor(name, age, sex, country) {
        super(name, age, sex, '黄色', country);
    }
}

//中国人
class ChinesePerson extends YellowPerson {
    constructor(name, age, sex) {
        super(name, age, sex, '中国');
    }

    //自我介绍
    introduction() {
        super.introduction();
        console.log(`我们都会功夫，我们是世界第一！`);
    }
}

let yellowPerson = new YellowPerson('张三', 20, '男', '新加坡');
let chinesePerson = new ChinesePerson('李四', 30, '男');
yellowPerson.introduction();
chinesePerson.introduction();
```

### 2.16.3 继承

`ES6`类支持单继承。使用`extends`关键字，就可以继承任何拥有`[[Construct]]`和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）。

``` js
class Father {
    money = 10000000000;   //百亿家产
    houses = 10;   //10栋别墅
    cars = 100;    //100辆车

    makeMoney(money) {
        console.log(`又赚了${money}元`);
        this.money += money;
    }
}

class Son extends Father { }

let son = new Son();
console.log(son.money, son.houses, son.cars);
son.makeMoney(10000);
console.log(son.money, son.houses, son.cars);
console.log(son.hasOwnProperty('money'), son.hasOwnProperty('houses'), son.hasOwnProperty('cars'));
console.log(son instanceof Son);
console.log(son instanceof Father);
```

> **单继承**

一次只能继承一个父类，就好比一个人只能有一个父亲。但是可以嵌套继承，就好比儿子继承父亲，父亲继承爷爷。

``` js
//爷爷
class GrandPa { }
//父亲
class Father extends { }

class Son extends Father, GrandPa { }	//错误
class Son extends Father extends Object { } //错误
class Son extends Father, extends Object { } //错误
class Son extends Father { }	//正确，同时拥有了爷爷和父亲的属性
```

``` js
//爷爷
class GrandPa {
    house = 10;
}
//父亲
class Father extends GrandPa {
    cars = 10;
    tellMe() {
        console.log(`我继承了我父亲的${this.house}套房子`);
    }
}
//儿子
class Son extends Father {
    tellMe() {
        console.log(`我不用劳动就继承了我爷爷的${this.house}套房子和我父亲的${this.cars}辆车子`);
    }
}

var father = new Father;
var son = new Son;
father.tellMe();
son.tellMe();
```

**思考：**可以无限继承吗？

<<<<<<< HEAD
```js
	虽然使用Object构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：创建具有同样接口的多个对象需要重复编写很多代码。
<<<<<<< HEAD
	
1、 new 操作符 + Object 创建对象
var person = new Object();
    person.name = "lisi";
    person.age = 21;
    person.family = ["lida","lier","wangwu"];
    person.say = function(){
        alert(this.name);
=======
**练习：**用继承实现`dialog`、`alert`、`confirm`等效果。

​``` js
function Dialog(msg) {
    if (!(this instanceof Dialog)) {
        return new Dialog(msg);
>>>>>>> 30a980fb6d9d9242d67dd702cf719b316b44bc5d
    }
    this.id = Dialog.id++;
    this.Dialogs.push(this);
    this.init(msg);
}

//所有的弹出框对象
Dialog.prototype.Dialogs = [];

//计算底部位置
Dialog.prototype.getHeight = function () {
    return this.container.clientHeight;
}

//使用观察者模式告知删除
//接收通知
Dialog.prototype.receive = function (height) {
    this.resetTop(height);
}

//通知
Dialog.prototype.notify = function () {
    const height = -(this.getHeight() + 10);
    this.Dialogs.forEach(item => {
        if (item.id > this.id) {
            item.receive(height);
        }
    });
}

//计算所有容器的高度总和
Dialog.prototype.calcAllHeight = function () {
    let height = 0;
    this.Dialogs.forEach(item => {
        if (item.id !== this.id) {
            height += item.getHeight();
        }
    });
    return height;
}

Dialog.prototype.resetTop = function (top) {
    if (!isNaN(top)) {
        const originHeight = parseInt(this.container.style.top.replace('px'));  //原始高度
        top += originHeight;
    } else {
        top = this.calcAllHeight() + 10 * this.Dialogs.length;
    }
    //改变容器位置
    this.container.style.top = top + 'px'
}

Dialog.prototype.init = function (content) {
    this.container = document.createElement('div'); //创建一个div容器
    this.container.style = `background: yellow;padding: 10px; border: #000000 1px solid; position: fixed;z-index: 99999;left: 43%;`;

    this.header = document.createElement('div');    //头部容器
    this.header.style = 'text-align:right;font-size:15px;';
    this.closeButton = document.createElement('label'); //关闭按钮
    this.closeButton.innerText = 'X';
    this.closeButton.style = 'font-weight:bold;';
    this.closeButton.onclick = () => {
        this.remove();
    };
    this.header.appendChild(this.closeButton);

    this.content = document.createElement('div');  //创建一个div用于显示content内容
    this.content.innerHTML = content;
    this.resetTop();
    this.container.appendChild(this.header);
    this.container.appendChild(this.content);
    document.body.appendChild(this.container);  //将容器加入到body最后
}

Dialog.prototype.remove = function () {
    const index = this.Dialogs.findIndex(c => c.id === this.id);
    this.Dialogs.splice(index, 1);
    this.notify();  //通知下边的提示框已删除
    this.container.parentElement.removeChild(this.container);   //移除弹出框
}

Dialog.id = 0;

let d1 = new Dialog('这是第一个弹出框');
let d2 = Dialog('这是第二个弹出框');
let d5 = Dialog(`<table border="1">
<tr>
    <td>姓名</td>
    <td>年龄</td>
</tr>
<tr>
    <td>张三</td>
    <td>20</td>
</tr>
<tr>
    <td>李四</td>
    <td>30</td>
</tr>
</table>`);

//弹出提示框
function MyAlert(msg, type) {
    Dialog.call(this, msg);     //将当前的this指向Dialog，所以使用this同样可以获取Dialog的this属性
    this.setIcon(type);
}

//提示框继承Dialog，在Dialog的原基础上新增或修改
MyAlert.prototype = Object.create(Dialog.prototype);
MyAlert.prototype.constructor = MyAlert;

MyAlert.prototype.setIcon = function (type) {
    this.icon = document.createElement('label');
    this.icon.innerText = type === 'fail' ? '×' : '√';
    this.icon.style = 'color:red;font-size:20px';
    this.container.insertBefore(this.icon, this.content);   //将图标加入到内容的前面

    this.okButton = document.createElement('input');
    this.okButton.type = 'button';
    this.okButton.value = '确定';

    //把内容容器改为inline-block
    this.content.style.display = 'inline-block';

    //将头部隐藏，因为不需要关闭按钮了
    this.header.style.display = 'none';

    //改变容器位置
    this.resetTop();

    //点击确定按钮时隐藏
    this.okButton.onclick = () => {
        this.remove();
    }

    this.buttonsContainer = document.createElement('div');  //用于存放按钮的容器
    this.buttonsContainer.appendChild(this.okButton);
    this.buttonsContainer.style = 'text-align:right;';
    this.container.appendChild(this.buttonsContainer);
}

let d3 = new MyAlert('这是第一个失败的弹出框', 'fail');
let d4 = new MyAlert('这是第一个成功弹出框', 'success');

//询问对话框
function MyConfirm(msg, title) {
    MyAlert.call(this, msg);
    this.setTitle(title);
}

//询问对话框可以继承提示框，在提示框的原基础上新增或修改
MyConfirm.prototype = Object.create(MyAlert.prototype);
MyConfirm.prototype.constructor = MyAlert;

//设置标题
MyConfirm.prototype.setTitle = function (title = '提示') {
    this.title = document.createElement('div');
    this.title.innerText = title;
    this.title.style = 'font-size:15px;font-weight:bold;';
    this.container.insertBefore(this.title, this.icon);

    //改变一下icon的内容
    this.icon.innerText = '？';

    //改变容器位置
    this.resetTop();

    this.cancelButton = document.createElement('input');
    this.cancelButton.type = 'button';
    this.cancelButton.value = '取消';
    this.cancelButton.onclick = () => {
        console.log('取消');
        this.remove();
    };

    this.buttonsContainer.appendChild(this.cancelButton);
}

let c1 = new MyConfirm('你确定要删除吗？');
let c2 = new MyConfirm('你确定要删除吗？', '请看清楚');
```

# 执行上下文

当`JavaScript`代码执行一段可执行代码`(executable code)`时，会创建对应的执行上下文`(execution context)`。

对于每个执行上下文，都有三个重要属性：

- 变量对象`(Variable object，VO)`
- 作用域链`(Scope chain)`
- `this`

## 5.1 变量对象

变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。

### 5.1.1 全局上下文

可以通过`this`引用，在客户端 `JavaScript`中，全局对象就是`window`对象。

```js
console.log(this);	//window
```

全局对象是由`Object`构造函数实例化的一个对象。

```js
console.log(this instanceof Object);
```

预定义了一堆，大堆函数和属性。

```js
//都能生效
console.log(Math.random());
console.log(this.Math.random());
```

作为全局变量的宿主。

```js
var a = 1;
console.log(this.a);
```

客户端`JavaScript`中，全局对象有`window`属性指向自身。

```js
var a = 1;
console.log(window.a);	//1

this.window.b = 2;
console.log(this.b);	//2

console.log(self);	//window
console.log(globalThis);	//window
```

全局上下文中的变量对象其实就是全局对象。

### 1.1.2 函数上下文

在函数上下文中，我们用活动对象`(Activation Object, AO)`来表示变量对象。活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在`JavaScript`环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫`Activation Object`，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。

活动对象是在进入函数上下文时被创建的，它通过函数的`arguments`属性初始化。`arguments`属性值是 `Arguments`对象。

```js
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};
  b = 3;
  console.log(a);
  console.log(b);
}
foo(1);
```

在进入执行上下文后。

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}

//var person = { name: '张三', age: 13 }; obj.name;
```

## 5.2 作用域链

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

函数有一个内部属性`[scope]`，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解`[scope]`就是所有父变量对象的层级链。

``` js
function foo() {
    function bar() {
        //更多代码
    }
}
```

函数创建时，各自的`[scope]`为：

```js
foo.[scope] = [
  globalContext.VO
];

bar.[scope] = [
    fooContext.AO,
    globalContext.VO
];
```

子作用域可以访问父作用域的变量，父作用域不能访问子作用域的变量（只能自下往上查找，不能自上往下查找）。

``` js
function parent() {
    var a = 1;
    function child() {
        var b = 2;
        console.log(a); //可以访问到parent中的a
    }
    console.log(b);     //报错，因为访问不到child中的b
}
<<<<<<< HEAD
```

## 5.3 this

前面已经提到`javascript`采用的是静态作用域，但是`this`算是模仿了动态作用域，`this`是在执行阶段时确定的。

### 5.3.1 默认绑定

不带任何修饰的函数进行调用的，只能采用默认绑定，`this`指向全局。严格模式下不能将全局对象用于默认绑定，因此`this`会绑定到`undefined`。

```js
function foo () {
    console.log(this);	//window
    console.log(this.a);
}
var a = 12;
foo();  //12
```

```js
function a() {
    console.log('a', this);	//'a' window
}
function b() {
    a();
    console.log('b', this);	//'b' window
}
function c() {
    b();
    console.log('c', this);	//'c' window
}
c();
```

### 5.3.2 隐式绑定

对象内部包含一个指向函数的属性，并通过这个属性间接引用这个函数，从而把`this`间接（隐式）绑定到这个对象上。

+ 无论是直接在`obj`中定义还是再添加为引用属性，这个函数严格来说都不属于`obj`对象。

```js
function foo() {
    console.log(this);	//{a: 2, foo: ƒ}
    console.log(this.a);	//2
}
>>>>>>> f40588e0b6432d77a46744363122d2c18d0f3ae2

=======
```

## 5.3 this

前面已经提到`javascript`采用的是静态作用域，但是`this`算是模仿了动态作用域，`this`是在执行阶段时确定的。

### 5.3.1 默认绑定

不带任何修饰的函数进行调用的，只能采用默认绑定，`this`指向全局。严格模式下不能将全局对象用于默认绑定，因此`this`会绑定到`undefined`。

```js
function foo () {
    console.log(this);	//window
    console.log(this.a);
}
var a = 12;
foo();  //12
```

```js
function a() {
    console.log('a', this);	//'a' window
}
function b() {
    a();
    console.log('b', this);	//'b' window
}
function c() {
    b();
    console.log('c', this);	//'c' window
}
c();
```

### 5.3.2 隐式绑定

对象内部包含一个指向函数的属性，并通过这个属性间接引用这个函数，从而把`this`间接（隐式）绑定到这个对象上。

+ 无论是直接在`obj`中定义还是再添加为引用属性，这个函数严格来说都不属于`obj`对象。

```js
function foo() {
    console.log(this);	//{a: 2, foo: ƒ}
    console.log(this.a);	//2
}

var obj = {
    a: 2,
    foo: foo
}
obj.foo();

var obj = {
    a: 2,
    foo: function() {
        console.log(this);	//{a: 2, foo: ƒ}
        console.log(this.a);	//2
    }
}
obj.foo();
```


基本排序算法其核心思想是指对一组数据按照一定的顺序重新排列。

    重新排列时用到的技术是一组嵌套的for循环。其中外循环会遍历数组的每一项，内循环则用于比较元素。
=======

    money = 0;	//总钱数
    
    //挣钱
    makeMoney(money) {
        this.money += money;
        console.log(`这次赚了${money}，到目前为止总共已经赚了${this.money}了。`);
    }
    
    say() {
        console.log(`我叫${this.name}，今年${this.age}岁。`);
    }
}

class Son extends Father {
    constructor(name, age, sex) {
        super(name, age, sex);  //super作为父类构造函数只能用在子类构造函数中
    }

    say() {
        //super();	//报错
        super.say();
        console.log('我是我父亲的儿子，还在读大学');
    }
}

let son = new Son('张三', 20, '男');
son.makeMoney(1000);
son.makeMoney(100);
son.say();
```

​``` js
//人（基类）基本类
class Person {
    constructor(name, age, sex, skin, country) {
        this.name = name;
        this.age = age;
        this.sex = sex;
        this.skin = skin;
        this.country = country;
    }
>>>>>>> remotes/teachter/master

    //定义的函数（自我介绍）
    introduction() {
        console.log(`我叫${this.name}，今年${this.age}岁了，性别：${this.sex}，国籍：${this.country}，肤色：${this.skin}`);
    }
}

//黄种人
class YellowPerson extends Person {
    constructor(name, age, sex, country) {
        super(name, age, sex, '黄色', country);
    }
}

//中国人
class ChinesePerson extends YellowPerson {
    constructor(name, age, sex) {
        super(name, age, sex, '中国');
    }

    //自我介绍
    introduction() {
        super.introduction();
        console.log(`我们都会功夫，我们是世界第一！`);
    }
}

let yellowPerson = new YellowPerson('张三', 20, '男', '新加坡');
let chinesePerson = new ChinesePerson('李四', 30, '男');
yellowPerson.introduction();
chinesePerson.introduction();
```

### 2.16.3 继承

`ES6`类支持单继承。使用`extends`关键字，就可以继承任何拥有`[[Construct]]`和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）。

``` js
class Father {
    money = 10000000000;   //百亿家产
    houses = 10;   //10栋别墅
    cars = 100;    //100辆车

    makeMoney(money) {
        console.log(`又赚了${money}元`);
        this.money += money;
    }
}

class Son extends Father { }

let son = new Son();
console.log(son.money, son.houses, son.cars);
son.makeMoney(10000);
console.log(son.money, son.houses, son.cars);
console.log(son.hasOwnProperty('money'), son.hasOwnProperty('houses'), son.hasOwnProperty('cars'));
console.log(son instanceof Son);
console.log(son instanceof Father);
```

> **单继承**

<<<<<<< HEAD
=======
```

+ 调用位置会使用`obj`上下文来引用函数，因此你可以说函数被调用时`obj`对象“拥有”或者“包含”函数引用。当`foo()`被调用时，它的前面确实加上了对`obj`的引用，当函数引用有上下文对象时，隐式绑定规则会把函数调用中的`this`绑定到这个上下文对象。因此调用`foo()`时`this`被绑定到`obj`，因此在函数中执行`this.a`和`obj.a`是一样的。
+ 对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。

​```js
function foo() {
    console.log(this.a);
}

var obj2 = {
    a: 1,
    foo: foo
}

var obj1 = {
    a: 2,
    obj2: obj2
}
obj1.obj2.foo();    //1

var obj3 = {
    a: 3,
    obj1: obj1
}
obj3.obj1.obj2.foo();	//1
>>>>>>> 5ad182241fc33c1ce1717de2e86146cd9b52fb0d
=======
一次只能继承一个父类，就好比一个人只能有一个父亲。但是可以嵌套继承，就好比儿子继承父亲，父亲继承爷爷。

​``` js
//爷爷
class GrandPa { }
//父亲
class Father extends { }

class Son extends Father, GrandPa { }	//错误
class Son extends Father extends Object { } //错误
class Son extends Father, extends Object { } //错误
class Son extends Father { }	//正确，同时拥有了爷爷和父亲的属性
>>>>>>> remotes/teachter/master
```

``` js
//爷爷
class GrandPa {
    house = 10;
}
//父亲
class Father extends GrandPa {
    cars = 10;
    tellMe() {
        console.log(`我继承了我父亲的${this.house}套房子`);
    }
}
//儿子
class Son extends Father {
    tellMe() {
        console.log(`我不用劳动就继承了我爷爷的${this.house}套房子和我父亲的${this.cars}辆车子`);
    }
}

var father = new Father;
var son = new Son;
father.tellMe();
son.tellMe();
```

**思考：**可以无限继承吗？

<<<<<<< HEAD
<<<<<<< HEAD
```js
	虽然使用Object构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：创建具有同样接口的多个对象需要重复编写很多代码。
=======
>>>>>>> 5ad182241fc33c1ce1717de2e86146cd9b52fb0d
	
1、 new 操作符 + Object 创建对象
var person = new Object();
    person.name = "lisi";
    person.age = 21;
    person.family = ["lida","lier","wangwu"];
    person.say = function(){
        alert(this.name);
=======
**练习：**用继承实现`dialog`、`alert`、`confirm`等效果。

​``` js
function Dialog(msg) {
    if (!(this instanceof Dialog)) {
        return new Dialog(msg);
>>>>>>> remotes/teachter/master
    }
    this.id = Dialog.id++;
    this.Dialogs.push(this);
    this.init(msg);
}

//所有的弹出框对象
Dialog.prototype.Dialogs = [];

//计算底部位置
Dialog.prototype.getHeight = function () {
    return this.container.clientHeight;
}

//使用观察者模式告知删除
//接收通知
Dialog.prototype.receive = function (height) {
    this.resetTop(height);
}

//通知
Dialog.prototype.notify = function () {
    const height = -(this.getHeight() + 10);
    this.Dialogs.forEach(item => {
        if (item.id > this.id) {
            item.receive(height);
        }
    });
}

//计算所有容器的高度总和
Dialog.prototype.calcAllHeight = function () {
    let height = 0;
    this.Dialogs.forEach(item => {
        if (item.id !== this.id) {
            height += item.getHeight();
        }
    });
    return height;
}

Dialog.prototype.resetTop = function (top) {
    if (!isNaN(top)) {
        const originHeight = parseInt(this.container.style.top.replace('px'));  //原始高度
        top += originHeight;
    } else {
        top = this.calcAllHeight() + 10 * this.Dialogs.length;
    }
    //改变容器位置
    this.container.style.top = top + 'px'
}

Dialog.prototype.init = function (content) {
    this.container = document.createElement('div'); //创建一个div容器
    this.container.style = `background: yellow;padding: 10px; border: #000000 1px solid; position: fixed;z-index: 99999;left: 43%;`;

    this.header = document.createElement('div');    //头部容器
    this.header.style = 'text-align:right;font-size:15px;';
    this.closeButton = document.createElement('label'); //关闭按钮
    this.closeButton.innerText = 'X';
    this.closeButton.style = 'font-weight:bold;';
    this.closeButton.onclick = () => {
        this.remove();
    };
    this.header.appendChild(this.closeButton);

    this.content = document.createElement('div');  //创建一个div用于显示content内容
    this.content.innerHTML = content;
    this.resetTop();
    this.container.appendChild(this.header);
    this.container.appendChild(this.content);
    document.body.appendChild(this.container);  //将容器加入到body最后
}

Dialog.prototype.remove = function () {
    const index = this.Dialogs.findIndex(c => c.id === this.id);
    this.Dialogs.splice(index, 1);
    this.notify();  //通知下边的提示框已删除
    this.container.parentElement.removeChild(this.container);   //移除弹出框
}

Dialog.id = 0;

let d1 = new Dialog('这是第一个弹出框');
let d2 = Dialog('这是第二个弹出框');
let d5 = Dialog(`<table border="1">
<tr>
    <td>姓名</td>
    <td>年龄</td>
</tr>
<tr>
    <td>张三</td>
    <td>20</td>
</tr>
<tr>
    <td>李四</td>
    <td>30</td>
</tr>
</table>`);

//弹出提示框
function MyAlert(msg, type) {
    Dialog.call(this, msg);     //将当前的this指向Dialog，所以使用this同样可以获取Dialog的this属性
    this.setIcon(type);
}

//提示框继承Dialog，在Dialog的原基础上新增或修改
MyAlert.prototype = Object.create(Dialog.prototype);
MyAlert.prototype.constructor = MyAlert;

MyAlert.prototype.setIcon = function (type) {
    this.icon = document.createElement('label');
    this.icon.innerText = type === 'fail' ? '×' : '√';
    this.icon.style = 'color:red;font-size:20px';
    this.container.insertBefore(this.icon, this.content);   //将图标加入到内容的前面

    this.okButton = document.createElement('input');
    this.okButton.type = 'button';
    this.okButton.value = '确定';

    //把内容容器改为inline-block
    this.content.style.display = 'inline-block';

    //将头部隐藏，因为不需要关闭按钮了
    this.header.style.display = 'none';

    //改变容器位置
    this.resetTop();

    //点击确定按钮时隐藏
    this.okButton.onclick = () => {
        this.remove();
    }

    this.buttonsContainer = document.createElement('div');  //用于存放按钮的容器
    this.buttonsContainer.appendChild(this.okButton);
    this.buttonsContainer.style = 'text-align:right;';
    this.container.appendChild(this.buttonsContainer);
}

let d3 = new MyAlert('这是第一个失败的弹出框', 'fail');
let d4 = new MyAlert('这是第一个成功弹出框', 'success');

//询问对话框
function MyConfirm(msg, title) {
    MyAlert.call(this, msg);
    this.setTitle(title);
}

//询问对话框可以继承提示框，在提示框的原基础上新增或修改
MyConfirm.prototype = Object.create(MyAlert.prototype);
MyConfirm.prototype.constructor = MyAlert;

//设置标题
MyConfirm.prototype.setTitle = function (title = '提示') {
    this.title = document.createElement('div');
    this.title.innerText = title;
    this.title.style = 'font-size:15px;font-weight:bold;';
    this.container.insertBefore(this.title, this.icon);

    //改变一下icon的内容
    this.icon.innerText = '？';

    //改变容器位置
    this.resetTop();

    this.cancelButton = document.createElement('input');
    this.cancelButton.type = 'button';
    this.cancelButton.value = '取消';
    this.cancelButton.onclick = () => {
        console.log('取消');
        this.remove();
    };

    this.buttonsContainer.appendChild(this.cancelButton);
}

<<<<<<< HEAD
　　　　继承这些知识点与其说是对象的继承，更像是函数的功能用法，如何用函数做到复用，组合，这些和使用继承的思考是一样的。上述几个继承的方法都可以手动修复他们的缺点，但就是多了这个手动修复就变成了另一种继承模式。
　　　　这些继承模式的学习重点是学它们的思想，不然你会在coding书本上的例子的时候，会觉得明明可以直接继承为什么还要搞这么麻烦。就像原型式继承它用函数复制了内部对象的一个副本，这样不仅可以继承内部对象的属性，还能把函数（对象，来源内部对象的返回）随意调用，给它们添加属性，改个参数就可以改变原型对象，而这些新增的属性也不会相互影响。
```

### 类

```js
类声明:
定义类有2中方式，类声明和类表达式：
// 类声明
class Student {}
// 类表达式
const Student = class {}

为什么说它是语法糖
因为类实际上它是一个function，区别在于构造函数是函数作用域，类是块级作用域，类中的方法，都是定义在类的prototype上面，所以文章开头说它还是构造函数和原型的概念

类包含的属性和方法
类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。

类的构造函数
类的构造函数关键字是constructor，它同等于原型中的prototype.constructor。
如果没有写constructor函数，那么会默认有一个空的constructor函数。
```
<<<<<<< HEAD
=======
+ 调用位置会使用`obj`上下文来引用函数，因此你可以说函数被调用时`obj`对象“拥有”或者“包含”函数引用。当`foo()`被调用时，它的前面确实加上了对`obj`的引用，当函数引用有上下文对象时，隐式绑定规则会把函数调用中的`this`绑定到这个上下文对象。因此调用`foo()`时`this`被绑定到`obj`，因此在函数中执行`this.a`和`obj.a`是一样的。
+ 对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。

```js
function foo() {
    console.log(this.a);
}

var obj2 = {
    a: 1,
    foo: foo
}

var obj1 = {
    a: 2,
    obj2: obj2
}
obj1.obj2.foo();    //1

var obj3 = {
    a: 3,
    obj1: obj1
}
obj3.obj1.obj2.foo();	//1
```

### 5.3.3 显示绑定

`call`,`apply`,`bind`都属于显式绑定一类，显示绑定后`this`便无法再修改。

```js
function foo() {
    console.log(this);	//{a: 2}
    console.log(this.a);  //2
}
var obj = {
    a: 2
}
foo.call(obj);
```

### 5.3.4 new绑定

实例化一个新对象后，会将实例对象绑定到函数调用中的`this`上。

```js
function foo(a) {
    console.log(this);	//foo {}
    this.a = a;
    console.log(this.a);	//2
}
var bar = new foo(2);
console.log(bar.a); //2
console.log(a);	//Uncaught ReferenceError: a is not defined
```

### 5.3.5 箭头函数

`es6`新增的`()=>`箭头函数中，`this`在分析阶段时就确定了（跟函数中的`this`在执行阶段时确定相反），绑定的是父作用域中的`this`，指向永远不变。其实总结起来就两点：

+ 外层有函数：外层函数的`this`就是箭头函数的`this`。

```js
function ab() {
    var b = () => {
        console.log(this);
    };
    b();
}
ab();   //window，因为外层函数的this采用了默认绑定规则
```

```js
var obj = {
    a: 1,
    foo() {
        var fn = () => {
            console.log(this.a);
        };
        fn();
    }
}
obj.foo();  //1，外层函数的this采用了隐式绑定规则
```

外层没有函数：箭头函数的`this`就是`window`。

```js
var a = 123;
var obj = {
    a: 1,
    foo: () => {
        console.log(this.a);
    }
}
obj.foo();  //123
```

## 5.4 总结
>>>>>>> f40588e0b6432d77a46744363122d2c18d0f3ae2

到目前为止还不知道执行上下文的结构。接下来通过例子讲解。

``` js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```

1. 全局上下文初始化。

```js
globalContext = {
    VO: [global],	//window是暴露出来的一个指向全局变量对象的属性
    Scope: [globalContext.VO],
    this: globalContext.VO
}
```

=======
### 5.3.3 显示绑定

`call`,`apply`,`bind`都属于显式绑定一类，显示绑定后`this`便无法再修改。

```js
function foo() {
    console.log(this);	//{a: 2}
    console.log(this.a);  //2
}
var obj = {
    a: 2
}
foo.call(obj);
```

### 5.3.4 new绑定

实例化一个新对象后，会将实例对象绑定到函数调用中的`this`上。

```js
function foo(a) {
    console.log(this);	//foo {}
    this.a = a;
    console.log(this.a);	//2
}
var bar = new foo(2);
console.log(bar.a); //2
console.log(a);	//Uncaught ReferenceError: a is not defined
```

### 5.3.5 箭头函数

`es6`新增的`()=>`箭头函数中，`this`在分析阶段时就确定了（跟函数中的`this`在执行阶段时确定相反），绑定的是父作用域中的`this`，指向永远不变。其实总结起来就两点：

+ 外层有函数：外层函数的`this`就是箭头函数的`this`。

```js
function ab() {
    var b = () => {
        console.log(this);
    };
    b();
}
ab();   //window，因为外层函数的this采用了默认绑定规则
```

```js
var obj = {
    a: 1,
    foo() {
        var fn = () => {
            console.log(this.a);
        };
        fn();
    }
}
obj.foo();  //1，外层函数的this采用了隐式绑定规则
```

外层没有函数：箭头函数的`this`就是`window`。

```js
var a = 123;
var obj = {
    a: 1,
    foo: () => {
        console.log(this.a);
    }
}
obj.foo();  //123
```

## 5.4 总结

到目前为止还不知道执行上下文的结构。接下来通过例子讲解。

``` js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```

1. 全局上下文初始化。

```js
globalContext = {
    VO: [global],	//window是暴露出来的一个指向全局变量对象的属性
    Scope: [globalContext.VO],
    this: globalContext.VO
}
```

>>>>>>> 5ad182241fc33c1ce1717de2e86146cd9b52fb0d
=======

### 5.2 作用域链
=======
let c1 = new MyConfirm('你确定要删除吗？');
let c2 = new MyConfirm('你确定要删除吗？', '请看清楚');
```

# 执行上下文

当`JavaScript`代码执行一段可执行代码`(executable code)`时，会创建对应的执行上下文`(execution context)`。

对于每个执行上下文，都有三个重要属性：

- 变量对象`(Variable object，VO)`
- 作用域链`(Scope chain)`
- `this`

## 5.1 变量对象

变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。

### 5.1.1 全局上下文

可以通过`this`引用，在客户端 `JavaScript`中，全局对象就是`window`对象。

​```js
console.log(this);	//window
```

全局对象是由`Object`构造函数实例化的一个对象。

```js
console.log(this instanceof Object);
```

预定义了一堆，大堆函数和属性。

```js
//都能生效
console.log(Math.random());
console.log(this.Math.random());
```

作为全局变量的宿主。

```js
var a = 1;
console.log(this.a);
```

客户端`JavaScript`中，全局对象有`window`属性指向自身。

```js
var a = 1;
console.log(window.a);	//1

this.window.b = 2;
console.log(this.b);	//2

console.log(self);	//window
console.log(globalThis);	//window
```

全局上下文中的变量对象其实就是全局对象。

### 1.1.2 函数上下文

在函数上下文中，我们用活动对象`(Activation Object, AO)`来表示变量对象。活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在`JavaScript`环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫`Activation Object`，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。

活动对象是在进入函数上下文时被创建的，它通过函数的`arguments`属性初始化。`arguments`属性值是 `Arguments`对象。

```js
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};
  b = 3;
  console.log(a);
  console.log(b);
}
foo(1);
```

在进入执行上下文后。

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}

//var person = { name: '张三', age: 13 }; obj.name;
```

## 5.2 作用域链
>>>>>>> remotes/teachter/master

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

函数有一个内部属性`[scope]`，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解`[scope]`就是所有父变量对象的层级链。

``` js
function foo() {
    function bar() {
        //更多代码
    }
}
```

函数创建时，各自的`[scope]`为：

```js
foo.[scope] = [
  globalContext.VO
];

bar.[scope] = [
    fooContext.AO,
    globalContext.VO
];
```

子作用域可以访问父作用域的变量，父作用域不能访问子作用域的变量（只能自下往上查找，不能自上往下查找）。

``` js
function parent() {
    var a = 1;
    function child() {
        var b = 2;
        console.log(a); //可以访问到parent中的a
    }
    console.log(b);     //报错，因为访问不到child中的b
}
```

## 5.3 this

前面已经提到`javascript`采用的是静态作用域，但是`this`算是模仿了动态作用域，`this`是在执行阶段时确定的。

### 5.3.1 默认绑定

不带任何修饰的函数进行调用的，只能采用默认绑定，`this`指向全局。严格模式下不能将全局对象用于默认绑定，因此`this`会绑定到`undefined`。

``` js
function foo () {
    console.log(this);	//window
    console.log(this.a);
}
var a = 12;
foo();  //12
```

``` js
function a() {
    console.log('a', this);	//'a' window
}
function b() {
    a();
    console.log('b', this);	//'b' window
}
function c() {
    b();
    console.log('c', this);	//'c' window
}
c();
```

**思考：**

``` js
var a = 12;
function test() {
    this.a = 13;
}
test();
console.log(a);	//?
```

### 5.3.2 隐式绑定

对象内部包含一个指向函数的属性，并通过这个属性间接引用这个函数，从而把`this`间接（隐式）绑定到这个对象上。

+ 无论是直接在`obj`中定义还是再添加为引用属性，这个函数严格来说都不属于`obj`对象。

``` js
function foo() {
    console.log(this);	//{a: 2, foo: ƒ}
    console.log(this.a);	//2
}

var obj = {
    a: 2,
    foo: foo
}
obj.foo();

var obj = {
    a: 2,
    foo: function() {
        console.log(this);	//{a: 2, foo: ƒ}
        console.log(this.a);	//2
    }
}
obj.foo();
```

+ 调用位置会使用`obj`上下文来引用函数，因此你可以说函数被调用时`obj`对象“拥有”或者“包含”函数引用。当`foo()`被调用时，它的前面确实加上了对`obj`的引用，当函数引用有上下文对象时，隐式绑定规则会把函数调用中的`this`绑定到这个上下文对象。因此调用`foo()`时`this`被绑定到`obj`，因此在函数中执行`this.a`和`obj.a`是一样的。
+ 对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。

``` js
function foo() {
    console.log(this.a);
}

var obj2 = {
    a: 1,
    foo: foo
}

var obj1 = {
    a: 2,
    obj2: obj2
}
obj1.obj2.foo();    //1

var obj3 = {
    a: 3,
    obj1: obj1
}
obj3.obj1.obj2.foo();	//1
```

### 5.3.3 显示绑定

`call`,`apply`,`bind`都属于显式绑定一类，显示绑定后`this`便无法再修改。

``` js
function foo() {
    console.log(this);	//{a: 2}
    console.log(this.a);  //2
}
var obj = {
    a: 2
}
foo.call(obj);
```

``` js
function foo() {
    console.log(this);	//{a: 2}
    console.log(this.a);  //2
}
var obj = {
    a: 2
}
foo.apply(obj);
```

``` js
function foo() {
    console.log(this);	//{a: 2}
    console.log(this.a);	//2
}
var obj = {
    a: 2
}
var f = foo.bind(obj);
f();
```

### 5.3.4 new绑定

实例化一个新对象后，会将实例对象绑定到函数调用中的`this`上。

``` js
function foo(a) {
    console.log(this);	//foo {}
    this.a = a;
    console.log(this.a);	//2
}
var bar = new foo(2);
console.log(bar.a); //2
console.log(a);	//Uncaught ReferenceError: a is not defined
```

**思考：**

``` js
function foo() {
    console.log(this);	//?
    console.log(this.a);	//?
}
var obj = {
    a: 2
}
var obj1 = {
    a: 20
}
var f = foo.bind(obj);
f = f.bind(obj1);
f();
```

``` js
var num = 1;
function a1() {
    'use strict';
    console.log(this.num++);
}

function a2() {
    console.log(++this.num);
}

(function () {
    'use strict';
    a2();	// ?
})()
a1();	// ?
```

``` js
function c1(name) {
    if (name) {
        this.name = name;
    }
}

function c2(name) {
    this.name = name;
}

function c3(name) {
    this.name = name || 'test';
}

c1.prototype.name = 'c1';
c2.prototype.name = 'c2';
c3.prototype.name = 'c3';
console.log(new c1().name + new c2().name + new c3().name);		// ?
```

### 5.3.5 箭头函数

`es6`新增的`()=>`箭头函数中，`this`在分析阶段时就确定了（跟函数中的`this`在执行阶段时确定相反），绑定的是父作用域中的`this`，指向永远不变。其实总结起来就两点：

+ 外层有函数：外层函数的`this`就是箭头函数的`this`。

``` js
function ab() {
    var b = () => {
        console.log(this);
    };
    b();
}
ab();   //window，因为外层函数的this采用了默认绑定规则
```

``` js
var obj = {
    a: 1,
    foo() {
        var fn = () => {
            console.log(this.a);
        };
        fn();
    }
}
obj.foo();  //1，外层函数的this采用了隐式绑定规则
```

+ 外层没有函数：箭头函数的`this`就是`window`。

``` js
var a = 123;
var obj = {
    a: 1,
    foo: () => {
        console.log(this.a);
    }
}
obj.foo();  //123
```

**思考：**

``` js
var a = 666;
var obj = {
    a: 1,
    obj: {
        a: 2,
        obj: {
            a: 3,
            foo: () => {
                console.log(this.a);
            }
        }
    }
}
obj.obj.obj.foo();	//?
```

``` js
var a = 666;
var obj = {
    a: 1,
    foo() {
        console.log(this.a);
        var obj1 = {
            a: 2,
            foo: () => {
                console.log(this.a);
                function f() {
                    console.log(a);
                    console.log(this.a);
                }
                f();
                return f;
            }
        }
        obj1.foo()();
    }
};
obj.foo();  //?
var ff = obj.foo;
ff();   //?
```

## 5.4 总结

到目前为止还不知道执行上下文的结构。接下来通过例子讲解。

``` js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```

1. 全局上下文初始化。

```js
globalContext = {
    VO: [global],	//window是暴露出来的一个指向全局变量对象的属性
    Scope: [globalContext.VO],
    this: globalContext.VO
}
```

>>>>>>> 5ad182241fc33c1ce1717de2e86146cd9b52fb0d
2. 初始化的同时，`checkscope`函数被创建，保存作用域链到函数的内部属性`[scope]`。

``` js
checkscope.[scope] = [
  globalContext.VO
];
```

3. 执行`checkscope`函数，创建`checkscope`函数执行上下文并初始化。

```js
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope: undefined,
        f: reference to function f(){}
    },
    Scope: [AO, globalContext.VO],
    this: undefined
}
```

4. 执行`f`函数，创建`f`函数执行上下文并初始化。

```js
fContext = {
    AO: {
        arguments: {
            length: 0
        }
    },
    Scope: [AO, checkscopeContext.AO, globalContext.VO],
    this: undefined
}
```

**思考：**

``` js
this.a = 20;
function go() {
    console.log(this);
    console.log(this.a);
    this.a = 30;
}
go.prototype.a = 40;
var test = {
    a: 50,
    init(fn) {
        fn();
        console.log(this.a);
        return fn;
    }
};
console.log(new go().a);	// ?
test.init(go);	// ?
var;	// ?
p();	// ?
```

#  第九章

代理基础

## 代理与反射

代理模式：为一个对象找一个替代对象，以便对原对象进行访问。在我的理解钟，代理就类似于第三方，比如，电视剧中的某大亨出现意外情况的时候，基本都会让律师全权代理，不会直接和大亨进行沟通，律师所做的事情就可以理解为代理模式。还有就是代购这个职业，比如我们因为各种原因不能出国去购买某种化妆品，这时候，代购的作用就显而易见了，她可以代替你出国去购买你所需要的东西，而你不需要出国。这也是符合代理模式的。

在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。

使用代理的原因是我们不愿意或者不想对原对象直接进行操作。

**先来一个简单的例子，代购买化妆品的例子**

```js
// 化妆品类
var cosmetic = function(name) {
    this.name = name;
}
cosmetic.prototype.getName = function() {
    return this.name;
}
// 定义不能出国的人
var people =  {
    buyCosmetic: function(name) {
        console.log('请帮我代购'+ name)
    }
}
// 定义代购对象
var purchasing = {
    buyCosmetic: function(cosmetic) {
        people.buyCosmetic(cosmetic.getName())
    }
}
purchasing.buyCosmetic(new cosmetic('口红'))
```



**ES6所提供`Proxy`构造函数能够让我们轻松的使用代理模式:**

```js
var proxy = new Proxy(target, handler);
```

`Proxy`构造函数传入两个参数，第一个参数`target`表示所要代理的对象，第二个参数`handler`也是一个对象用来设置对所代理的对象的行为。如果想知道`Proxy`的具体使用方法，可参考阮一峰的[《 ECMAScript入门 - Proxy 》](https://link.zhihu.com/?target=http%3A//es6.ruanyifeng.com/%23docs/proxy)。

 

**虚拟代理：是把一些开销很大的对象，延迟到真正需要它的时候才去创建执行**

我们在浏览一些购物商城的时候，会发现，当网络不太好的情况下，有些图片是加载不出来的，会有暂无图片的一张图片去代替它实际的图片，等网路图片加载完成之后，暂无图片就会被实际的图片代替。这就是使用的图片的懒加载。图片的懒加载也可是使用虚拟代理的模式来进行设计。

```js
    // 图片懒加载
    var myImage = (function(){
        var imgNode = document.createElement('img')
        document.body.appendChild( imgNode)
        return {
            setSrc: function(src) {
                imgNode.src =src
            }
        }
    }
)();
var proxyImage = (function() {
    var img = new Image;
    img.onload = function() {
        myImage.setSrc(this.src)
    }
    return {
        setSrc: function(src) {
            console.log('src', src)
            myImage.setSrc('http://seopic.699pic.com/photo/40007/8839.jpg_wh1200.jpg');
            img.src = src;
        }
    }
})();
proxyImage.setSrc('http://seopic.699pic.com/photo/40006/7735.jpg_wh1200.jpg')
```

**缓存代理：：可以作为一些开销大的运算结果提供暂时的存储，下次运算时，如果传递进来堵塞参数跟之前一致，则可以直接返回前面存储的运算结果。**

例如，前后端分离，向后端请求分页的数据的时候，每次页码改变时都需要重新请求后端数据，我们可以将页面和对应的结果进行缓存，当请求同一页的时候，就不再请求后端的接口而是从缓存中去取数据。



```js
const getFib = (number) => {
  if (number <= 2) {
    return 1;
  } else {
    return getFib(number - 1) + getFib(number - 2);
  }
}

const getCacheProxy = (fn, cache = new Map()) => {
  return new Proxy(fn, {
    apply(target, context, args) {
      const argsString = args.join(' ');
      if (cache.has(argsString)) {
        // 如果有缓存,直接返回缓存数据        console.log(`输出${args}的缓存结果: ${cache.get(argsString)}`);
        
        return cache.get(argsString);
      }
      const result = fn(...args);
      cache.set(argsString, result);

      return result;
    }
  })
}
const getFibProxy = getCacheProxy(getFib);
getFibProxy(40); // 102334155getFibProxy(40); // 输出40的缓存结果: 102334155
```



**使用场景：**

 代理模式的类型较多，不同类型的代理模式有不同的优缺点，它们应用于不同的场合：

​    (1) 当客户端对象需要访问远程主机中的对象时可以使用远程代理。

​    (2) 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。

​    (3) 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。

​    (4) 当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。

​    (5) 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。

**优缺点：**

优点：代理模式能够将代理对象与被调用的对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样，可以起到保护目标对象的作用。代理对象也可以对目标对象调用之前进行其他的操作。

缺点：； 增加系统的复杂度y\





## 代理捕获器与反射方法

代理可以捕获13种不同的基本操作。这些操作有各自不同的反射API方法、参数、关联ECMAScript操作和不变式。

### 9.2.1get()

​	get()捕获器会在获取属性值的操作中被调用。对应的反射API方法为

```js
constmyTarget={};constproxy=newProxy(myTarget,{get(target,property,receiver){console.log('get()');returnReflect.get(...arguments)}});proxy.foo;//get()

1. 返回值返回值无限制。
2. 拦截的操作proxy.propertyproxy[property]Object.create(proxy)[property]Reflect.get(proxy,property, receiver)
3. 捕获器处理程序参数target：目标对象。property：引用的目标对象上的字符串键属性。receiver：代理对象或继承代理对象的对象。
4. 捕获器不变式如果target.property不可写且不可配置，则处理程序返回的值必须与target.property匹配。
```

### 9.2.2    set()

​	set()捕获器会在设置属性值的操作中被调用。对应的反射API方法为Reflect.set()。

```js
constmyTarget={};constproxy=newProxy(myTarget,{set(target,property,value,receiver){console.log('set()');returnReflect.set(...arguments)}});proxy.foo='bar';
//set()
1. 返回值返回true表示成功；返回false表示失败，严格模式下会抛出TypeError。
2. 拦截的操作proxy.property=valueproxy[property]=valueObject.create(proxy)[property] = valueReflect.set(proxy,property, value,receiver)
3. 捕获器处理程序参数target：目标对象。property：引用的目标对象上的字符串键属性。value：要赋给属性的值。receiver：接收最初赋值的对象。
4. 捕获器不变式如果target.property不可写且不可配置，则不能修改目标属性的值。如果target.property不可配置且[[Set]]特性为undefined，则不能修改目标属性的值。在严格模式下，处理程序中返回false会抛出TypeError。
```

### 9.2.3      has()

​	has()捕获器会在in操作符中被调用。对应的反射API方法为Reflect.has()。

```js
constmyTarget={};constproxy=newProxy(myTarget,{has(target,property){console.log('has()');returnReflect.has(...arguments)}});'foo'inproxy;
//has()
1. 返回值has()必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。
2. 拦截的操作propertyinproxypropertyinObject.create(proxy)with(proxy){(property);}Reflect.has(proxy,property)
3. 捕获器处理程序参数target：目标对象。property：引用的目标对象上的字符串键属性。
4. 捕获器不变式如果target.property存在且不可配置，则处理程序必须返回true。如果target.property存在且目标对象不可扩展，则处理程序必须返回true。
```

### 9.2.4defineProperty()

​	defineProperty()捕获器会在Object.defineProperty()中被调用。对应的反射API方法为Reflect.defineProperty()。

### 9.2.5getOwnPropertyDescriptor()

​	getOwnPropertyDescriptor()捕获器会在Object.getOwnPropertyDescriptor()中被调用。对应的反射API方法为Reflect.getOwnPropertyDescriptor()。

### 9.2.6deleteProperty()

​		deleteProperty()捕获器会在delete操作符中被调用。对应的反射API方法为Reflect.deleteProperty()。

### 9.2.7ownKeys()

ownKeys()捕获器会在Object.keys()及类似方法中被调用。对应的反射API方法为Reflect.ownKeys()。

### 9.2.8getPrototypeOf()

​		getPrototypeOf()捕获器会在Object.getPrototypeOf()中被调用。对应的反射API方法为Reflect.getPrototypeOf()。

### 9.2.9setPrototypeOf()

​	setPrototypeOf()捕获器会在Object.setPrototypeOf()中被调用。对应的反射API方法为Reflect.setPrototypeOf()。
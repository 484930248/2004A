javascript 是1995年问世的主要是来替换Prel的都无端语言
核心是ECMSAScript 
ECMA不局限于web 而且web浏览器是ECMA的一种宿主环境、
与自身交互的扩展等   其他的宿主环境还有 Node.js 
 JavaScript 1.1  的 Date 对象就依赖平台
ES5增加了原生的解析和序列化JSON数据的 JSON 对象、方便继 承和高级属性定义的方法，以及新的增强ECMAScript引擎解释和 执行代码能力的严格模式
ES6正式支持了类、模块、迭代器、生成器、箭 头函数、期约、反射、代理和众多新的数据类型

文档模型是DOM
文档对象模型（DOM，Document Object Model）是一个应用编程 接口（API），用于在HTML中使用扩展的XML。DOM将整个页面抽 象为一组分层节点。HTML或XML页面的每个组成部分都是一种节 点，包含不同的数据。
除了DOM Core和DOM HTML接口还可以
可伸缩矢量图（SVG，Scalable Vector Graphics） 数学标记语言（MathML，Mathematical Markup Language） 同步多媒体集成语言（SMIL，Synchronized Multimedia Integration Language） 
. Web浏览器对DOM的支持情况

浏览器对象模型是BOM
浏览器对象模型（BOM） API，
弹出新浏览器窗口的能力； 移动、缩放和关闭浏览器窗口的能力； navigator 对象，提供关于浏览器的详尽信息； location 对象，提供浏览器加载页面的详尽信息； screen 对象，提供关于用户屏幕分辨率的详尽信息； performance 对象，提供浏览器内存占用、导航行为和时间统 计的详尽信息； 对cookie的支持； 其他自定义对象，如 XMLHttpRequest 和IE的 ActiveXObject 。
JavaScript是一门用来与网页交互的脚本语言
ECMAScript 提供核心功能
文档对象模型（DOM） 提供与网页内容交互的方法和接口。
浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。
JavaScript五大浏览器 IE、Firefox、 Chrome、Safari和Opera


HTML中的JavaScript
前期是将JavaScript插入HTML网页使用<Script>(此标签出自于网景)元素
script有八个属性分别是
async表示立即开始下载脚本 不能阻止其他页面的动作只对外部脚本有效
charset使用src属性 
crossorigin  配置相关请求的CORS（跨源资源共 享）设置。默认不使用CORS。
crossorigin="anonymous" 配置文件请求不必设置凭据标 志。 crossorigin="use-credentials"
设置凭据标志，意 味着出站请求会包含凭据。
defer表示解析完成后立即执行
integrity 允许接收到的资源和指定的加密签名  如果不匹配则会报错 脚本不会执行
language 已废弃
src 表示包含要执行的代码的外部文件。
type代替 language ，
使用了 src 属性的 标签中再包含其他JavaScript代码。
。跟 <img> 元素很像，
<script> 元素的 src 属性可以是一个完整的URL，而且这个URL
指向的资源可以跟包含它的HTML页面不在同一个域中
例子   <script src = "http://www.somewhere.com/afile.js"></script>

标签占位符
以前所有 <script> 元素都被放在页面的 <head> 标签内
defer 属性只对外部脚本文件才有效。
因此支持HTML5的浏览器会忽略行内脚本的 defer 属性
对 defer 属性的支持是从IE4、Firefox 3.5、Safari 5和Chrome 7 开始的

异步执行脚本 
HTML5为 <script> 元素定义了 async 属性。
给脚本添加 async 属性的目的是告 诉浏览器，不必等脚本下载和执行完后再加载页面，同样也不必等到 该异步脚本下载和执行后再加载其他脚本

动态加载脚本
除了 <script> 标签，还有其他方式可以加载脚本。因为
JavaScript可以使用DOM API，所以通过向DOM中动态添加 script
元素同样可以加载指定的脚本。只要创建一个 script 元素并将其添
加到DOM即可。 
在把 HTMLElement 元素添加到DOM且执行到这段代码 之前不会发送请求

XHTML中的变化
可扩展超文本标记语言  是将HTML作为XML的应用重新包装的结果。
解析 <script> 元素会应用特殊规则   <号 替换为&lt；
第二种方法是把所有代码都包含到一个CDATA块中。
在兼容XHTML的浏览器中，这样能解决问题

行内代码与外部文件
虽然可以直接在HTML文件中嵌入JavaScript代码，但通常认为最 佳实践是尽可能将JavaScript代码放在外部文件中。
可维护性。JavaScript代码如果分散到很多HTML页面 会导致维 护困难  如果是用一个目录保存所有的JavaScript文件则容易维护
缓存。浏览器会根据特定的设置缓存所有外部链接的JavaScript文 件，这意味着如果两个页面都用到同一个文件  有利于页面的加载
适应未来   通过把JavaScript放到外部文件中，就不必考虑用 XHTML或前面提到的注释黑科技

文档模式
IE5.5发明了文档模式的概念  可 以使用 doctype切换文档模式
 ：混杂模式（quirks mode）和标准模式 （standards mode）
混杂模式在所有浏览器中都以省略文档开头的 doctype 声明作 为开关
准标准模式通过过渡性文档类型（ Transitional ）和框架集 文档类型（ Frameset ）来触发 准标准模式与标准模式非常接近，很少需要区分

<noscript> 元素
<noscript> 元素是针对早期浏览器不支持JavaScript的问题，需要一个页面优雅降级 的处理方案   如今的浏览器已经100%支持 JavaScript，  <noscript> 元素可以包含任何可以出现在 <body> 中的
HTML元素， <script> 除外  任何一个条件被满足，包含在 <noscript> 中的内容就会被渲
染。否则， ，浏览器不会渲染 <noscript> 中的内容。
小结
JavaScript是通过 <script> 元素插入到HTML页面中的。这个
元素可用于把JavaScript代码嵌入到HTML页面中，跟其他标记混合在
一起，也可用于引入保存在外部文件中的JavaScript。
要包含外部JavaScript文件，必须将 src 属性设置为要包含文件 的URL。文件可以跟网页在同一台服务器上，也可以位于完全不 同的域。

语言基础
语法 区分大小写 
首先要知道的是，ECMAScript中一切都区分大小写。 变量 test 和变 量 Test 是两个不同的变量。
标识符  就是变量、函数、属性或函数参数的名称。
注释   ECMAScript采用C语言风格的注释，包括单行注释和块注释。单 行注释以两个斜杠字符开头 
严格模式   ECMAScript 5增加了严格模式（strict mode）的概念
语句  ECMAScript中的语句以分号结尾。 省略分号意味着由解析器确定 语句在哪里结尾
if之类的控制语句只在执行多条语句时要求必须有代码块。

关键字与保留字
规范中也描述了一组未来的保留字，同样不能用作标识符或属性 名。
变量
ECMAScript变量是松散类型的，意思是变量可以用于保存任何类 型的数据。
每个变量只不过是一个用于保存任意值的命名占位符。有3 个关键字可以声明变量： var 、 const 和 let 。其中， var 在 ECMAScript的所有版本中都可以使用，而 const 和 let 只能在 ECMAScript 6及更晚的版本中使用。 
var 关键字
var 声明作用域    使用 var 操作符定义的变量会成为包含它的 函数的局部变量    
message 变量是在函数内部使用 var 定义的。 函数叫 test() 
var 声明提升
使用 var 时  个关键字 声明的变量会自动提升到函数作用域顶部
let 声明
let 跟 var 的作用差不多，但有着非常重要的区别。
区别是
let 声明的范围是块作用域，而 var 声明的范围是函数作 用域
age 变量之所以不能在 if 块外部被引用，是因为它 的作用域仅限于该块内部。
let 也不允许同一个块作用域中出现冗余声明。这样会导致报 错
暂时性死区
let 与 var 的另一个重要的区别，就是 let 声明的变量不会 在作用域中被提升
. 全局声明
与 var 关键字不同，使用 let 在全局作用域中声明的变量不会 成为 window 对象的属性（ var 声明的变量则会）。
条件声明
在使用 var 声明变量时，由于声明会被提升，JavaScript引擎会 自动将多余的声明在作用域顶部合并为一个声明。
使用 try / catch 语句或 typeof 操作符也不能解决，因为条 件块中 let 声明的作用域仅限于该块
for 循环中的 let 声明
在 let 出现之前， for 循环定义的迭代变量会渗透到循环体外 部  改成let后 就消失了
const 声明
const 的行为与 let 基本相同，唯一一个重要的区别是用它声 明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导 致运行时错误     const 声明的限制只适用于它指向的变量的引用。如果const引入的是一个对象 那么修改这个对象内部的属性并不违反cosnt限制
声明风格及最佳实践
ECMAScript 6增加 let 和 const 从客观上为这门语言更精确地 声明作用域和语义提供了更好的支持
不使用 var 有了 let 和 const ，大多数开发者会发现自己不再需要 var 了
数据类型
ECMAScript有6种简单数据类型（也称为原始类型）： Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 
typeof 操作符
因为ECMAScript的类型系统是松散的，所以需要一种手段来确定 任意变量的数据类型。 typeof 操作符就是为此而生的。对一个值使 用 typeof 操作符会返回下列字符串之一
"undefined" 表示值未定义； "boolean" 表示值为布尔值； "string" 表示值为字符串； "number" 表示值为数值； "object" 表示值为对象（而不是函数）或 null ； "function" 表示值为函数； "symbol" 表示值为符号
Undefined 类型
Undefined 类型只有一个值，就是特殊值 undefined 。当使 用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予 了 undefined 值
变量 message 显式地以 undefined 来初始化。 
Null 类型
Null 类型同样只有一个值，即特殊值 null
在定义将来要保存对象值的变量时，建议使用 null 来初始化， 不要使用其他值
用等于操作符（ == ）比较 null 和 undefined 始终返回 true 
Boolean 类型
Boolean （布尔值）类型是ECMAScript中使用最频繁的类型之 一，有两个字面值： true 和 false
Number 类型
ECMAScript中最有意思的数据类型或许就是 Number 了。
叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。
整数也可以用八进制（以8为基数）或十六进制（以16为基数）字 面量表示。对于八进制字面量，第一个数字必须是零（0），然后是相 应的八进制数字（数值0~7）。   八进制字面量在严格模式下是无效的，会导致JavaScript引擎抛出 语法错误。1
使用八进制和十六进制格式创建的数值在所有数学操作中都被视 为十进制数值。
浮点值
要定义浮点值，数值中必须包含小数点，而且小数点后面必须至 少有一个数字。
值的范围
由于内存的限制，ECMAScript并不支持表示这个世界上的所有数 值。   有一个特殊的数值叫 NaN 
数值转换
有3个函数可以将非数值转换为数值： Number() 、 parseInt() 和 parseFloat() 。 Number() 是转型函数， 可用于任何数据类型
Number() 函数基于如下规则执行转换。 布尔值， true 转换为1， false 转换为0。 数值，直接返回。 null ，返回0。 undefined ，返回 NaN 。
字符串如果字符串包含数值字符，包括数值字符前面带加、减 号的情况，则转换为一个十进制数值
String 类型
String （字符串）数据类型表示零或多个16位Unicode字符序 列。 字符串可以使用双引号（"）、单引号（'）或反引号（`）标示，
字符串的特点
ECMAScript中的字符串是不可变的（immutable），意思是一旦 创建，它们的值就不能变了
转换为字符串
有两种方式把一个值转换为字符串。首先是使用几乎所有值都有 的 toString() 方法。
toString() 方法可见于数值、布尔值、对象和字符串值。  toString() 返回数值的十进制字符串表示   toString() 输出的字符串 值也会随之改变。数值10可以输出为任意数值格式。 如果值有 toString() 方法，则调用该方法（不传参数） 并返回结果  如果值是 null ，返回 "null" 。 如果值是 undefined ，返回 "undefined" 。
字符串插值
模板字面量最常用的一个特性是支持字符串插值，也就是可以在 一个连续定义中插入一个或多个值 所有插入的值都会使用 toString() 强制转型为字符串，而且 任何JavaScript表达式都可以用于插值
模板字面量标签函数 
模板字面量也支持定义标签函数（tag function），而通过标签函 数可以自定义插值行为。
对于有 n 个插值的模板字面量，传给标签函数的表达式参数的个数始终是 n ，而传给标签函数的第一个参数所包含的字符串个数则始终是 n+1
原始字符串
使用模板字面量也可以直接获取原始的模板字面量内容（如换行 符或Unicode字符），而不是被转换后的字符表示。
可以使 用默认的 String.raw 标
Symbol 类型
Symbol （符号）是ECMAScript 6新增的数据类型。符号是原始 值，且符号实例是唯一、不可变的。
符号的基本用法符号需要使用 Symbol() 函数初始化。因为符号本身是原始类 型，所以 typeof 操作符对符号返回 symbol
调用 Symbol() 函数时，也可以传入一个字符串参数作为对符 号的描述（description），将来可以通过这个字符串来调试代码。
符号没有字面量语法，这也是它们发挥作用的关键。 Symbol() 函数不能用作构造函数，与 new 关键 字一起使用。
使用全局符号注册表
如果运行时的不同部分需要共享和重用符号实例，那么可以用一 个字符串作为键，在全局符号注册表中创建并重用符号。 为此，需要使用 Symbol.for() 方法     Symbol.for() 对每个字符串键都执行幂等操作。   还可以使用 Symbol.keyFor() 来查询全局注册表
Symbol.isConcatSpreadable 
根据ECMAScript规范，这个符号作为一个属性表示“一个布尔 值
Symbol.iterator
Symbol.match
Symbol.replace 
Symbol.search 
Symbol.species
Symbol.split
Symbol.toPrimitive
Symbol.toStringTag
Symbol.unscopables
Object 类型
ECMAScript中的对象其实就是一组数据和功能的集合。对象通 过 new 操作符后跟对象类型的名称来创建。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方 法
let o = new Object();
操作符
ECMA-262描述了一组可用于操作数据值的操作符，包括数学操 作符（如加、减）、位操作符、关系操作符和相等操作符等。
一元操作符
只操作一个值的操作符叫一元操作符（unary operator）。一元操 作符是ECMAScript中最简单的操作符。
递增/递减操作符
递增和递减操作符直接照搬自C语言，但有两个版本：前缀版和 后缀版
一元加和减
一元加和减操作符对大多数开发者来说并不陌生，它们在 ECMAScript中跟在高中数学中的用途一样
一元减由一个减号（ - ）表示，放在变量前头，主要用于把数值 变成负值，如把1转换为-1。
let num = 25; num = -num; console.log(num); // -25
先转换在赋值
let s1 = "01"; let s2 = "1.1"; let s3 = "z"; let b = false; let f = 1.1; let o = { valueOf() { return -1; } }; s1 = -s1; // 值变成数值-1 s2 = -s2; // 值变成数值-1.1 s3 = -s3; // 值变成NaN b = -b; // 值变成数值0 f = -f; // 变成-1.1 o = -o; // 值变成数值1 
位操作符
接下来要介绍的操作符用于数值的底层操作，也就是操作内存中 表示数据的比特（位）。
按位非 按位非操作符用波浪符（ ~ ）表示，它的作用是返回数值的一补 数。
按位与 按位与操作符用和号（ & ）表示，有两个操作数。本质上，按位 与就是将两个数的每一个位对齐
按位或 按位或操作符用管道符（ | ）表示，同样有两个操作数。
布尔操作符
对于编程语言来说，布尔操作符跟相等操作符几乎同样重要。如 果没有能力测试两个值的关系，那么像 if-else 和循环这样的语句 也没什么用了
. 逻辑非 
逻辑非操作符由一个叹号（ ! ）表示，可应用给ECMAScript中 的任何值
如果操作数是对象，则返回 false 。 如果操作数是空字符串，则返回 true 。 如果操作数是非空字符串，则返回 false 。 如果操作数是数值0，则返回 true 。 如果操作数是非0数值（包括 Infinity ），则返回 false 。 如果操作数是 null ，则返回 true 。 如果操作数是 NaN ，则返回 true 。 如果操作数是 undefined ，则返回 true 。
逻辑与
逻辑与操作符由两个和号（ && ）表示，应用到两个值，如下所 示：
let result = true && false;
. 逻辑或
逻辑或操作符由两个管道符（ || ）表示，比如： let result = true || false; 

乘性操作符
ECMAScript定义了3个乘性操作符：乘法、除法和取模。这些操 作符跟它们在Java、C语言及Perl中对应的操作符作用一样，但在处理 非数值时，它们也会包含一些自动的类型转换。
乘法操作符乘法操作符由一个星号（ * ）表示  let result = 34 * 56;
除法操作符 除法操作符由一个斜杠（ / ）表示 let result = 66 / 11;
取模操作符 取模（余数）操作符由一个百分比符号（ % ）表示  let result = 26 % 5; // 等于1 

指数操作符ECMAScript 7新增了指数操作符， Math.pow() 现在有了自己 的操作符 ** 
console.log(Math.pow(3, 2);
// 9 console.log(3 ** 2);
// 9 console.log(Math.pow(16, 0.5);
// 4 console.log(16** 0.5); // 4 
加性操作符
加性操作符，即加法和减法操作符，一般都是编程语言中最简单 的操作符
加法操作符 加法操作符（ + ）用于求两个数的和 let result = 1 + 2;
减法操作符  减法操作符（ - ）也是使用很频繁的一种操作符 let result = 2 - 1;
 关系操作符  关系操作符执行比较两个值的操作，包括小于（ < ）、大于 （ > ）、小于等于（ <= ）和大于等于（ >= ），用法跟数学课上学 的一样
let result1 = 5 > 3; // true let result2 = 5 < 3; // false
相等操作符
 判断两个变量是否相等是编程中最重要的操作之一。
. 等于和不等于   ECMAScript中的等于操作符用两个等于号（ == ）表示，如果操 作数相等，则会返回 true
 全等和不全等 全等和不全等操作符与相等和不相等操作符类似，只不过它们在 比较相等时不转换操作数。全等操作符由3个等于号（ === ）表 示，只有两个操作数在不转换的前提下相等才返回 true
let result1 = ("55" == 55); // true，转换后相 等 let result2 = ("55" === 55); // false，不相 等，因为数据类型不同 
let result1 = ("55" != 55); // false，转换后相 等 let result2 = ("55" !== 55); // true，不相等， 因为数据类型不同

条件操作符   
条件操作符是ECMAScript中用途最为广泛的操作符之一，语法跟 Java中一样
variable = boolean_expression ? true_value : false_value;
 赋值操作符  
简单赋值用等于号（ = ）表示，将右手边的值赋给左手边的变 量，  let num = 10;
每个数学操作符以及其他一些操作符都有对应的复合赋值操作 符：
乘后赋值（ *= ）
除后赋值（ /= ）
取模后赋值（ %= ）
加后赋值（ += ）
减后赋值（ -= ）
左移后赋值（ <<= ）
右移后赋值（ >>= ）
无符号右移后赋值（ >>>= ）

逗号操作符
逗号操作符可以用来在一条语句中执行多个操作
let num1 = 1, num2 = 2, num3 = 3;
在一条语句中同时声明多个变量是逗号操作符最常用的场景
let num = (5, 1, 4, 8, 0); // num的值为0 
语句
ECMA-262描述了一些语句（也称为流控制语句），而 ECMAScript中的大部分语法都体现在语句中。
if 语句
if 语句是使用最频繁的语句之一，语法如下：
if (condition) statement1 else statement2
这里的条件（ condition ）可以是任何表达式，并且求值结果 不一定是布尔值。
if (i > 25) console.log("Greater than 25."); // 只有一行代码 的语句 else { console.log("Less than or equal to 25."); // 一 个语句块 } 
do-while 语句
do-while 语句是一种后测试循环语句，即循环体中的代码执 行后才会对退出条件进行求值。
do-while 的语法如下： do { statement } while (expression);
个例子： let i = 0; do { i += 2; } while (i < 10);
while 语句
while 语句是一种先测试循环语句，即先检测退出条件，再执 行循环体内的代码。
while 循环的语法： while(expression) statement
例子： let i = 0; while (i < 10) { i += 2; } 在

for 语句
for 语句也是先测试语句，只不过增加了进入循环之前的初始 化代码，以及循环执行后要执行的表达式
语法for (initialization; expression; post-loopexpression) statement 
例： let count = 10; for (let i = 0; i < count; i++) { console.log(i); } 

for-in 语句
for-in 语句是一种严格的迭代语句，用于枚举对象中的非符号 键属性
，语法 for (property of expression) statement
例： for (const el of [2,4,6,8]) { document.write(el); } 

标签语句
语法 label: statement 
例子： start: for (let i = 0; i < count; i++) { console.log(i); }

break 和 continue 语句
break 和 continue 语句为执行循环代码提供了更严格的控制 手段。
例子： let num = 0; for (let i = 1; i < 10; i++) { if (i % 5 == 0) { break; } num++; } console.log(num); // 4

with 语句
with 语句的用途是将代码作用域设置为特定的对象
语法 ： with (expression) statement;
例子 let qs = location.search.substring(1); let hostName = location.hostname; let url = location.href;
switch 语句
switch 语句是与 if 语句紧密相关的一种流控制语句，从其他 语言借鉴而来
语 句 switch (expression) { case value1: statement break; case value2: statement break; case value3: statement break; case value4: statement break; default: statement } 
函数
函数对任何语言来说都是核心组件，因为它们可以封装语句，然 后在任何地方、任何时间执行。
是函数的基本语法： function functionName(arg0, arg1,...,argN) { statements }
例子： function sayHi(name, message) { console.log("Hello " + name + " , " + message); } 
小结﻿
JavaScript的核心语言特性在ECMA-262中以伪语言ECMAScript的 形式来定义
ECMA 基本类型包括   Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。
 ECMAScript提供了C语言和类C语言中常见的很多基本操作符， 包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值 操作符等
Number 一种数值数据类型。
Object 是一种复杂数据类型
其中 if语句 for语句 switch语句 都是借鉴过来的
不需要指定函数的返回值，因为任何函数可以在任何时候返回任 何值。 

不指定返回值的函数实际上会返回特殊值 undefined 。

===================================================================================================================================================================================================
1.19 JavaScript 第四章阅读笔记
变量、作用域与内存（187-225）
JavaScript中的变量可谓独树一帜

通过变量使用原始值与引用值
原始值（primitve value）是最简单的数据  在赋值变量时JavaScript必须确定是原始值还是引用值
原始值共分为： Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。 
保存原始值的变量 是按值（by value）
引用值（reference value）多个值构成的对象
实际操作对象是引用值（reference）不是对象的本身 所以 保存引用值的变量是按（by reference）访问的

动态属性          可以随时添加、修改和删除其属 性和方法
例子： let person = new Object(); person.name = "Nicholas"; console.log(person.name); // "Nicholas" 
如果代码想给name定义一个age 并且给他进行赋值
let name1 = "Nicholas"; let name2 = new String("Matt"); name1.age = 27; name2.age = 26; console.log(name1.age); // undefined console.log(name2.age); // 26 console.log(typeof name1); // string console.log(typeof name2); // object
复制值 如果在同一个变量里面  通过变量把一个原始值赋值到另一个变量时 原始值会被复制到新的变量的位置
例如   let num1 =5；  let num2 = num1；
这num1时5 如果把num2初始化为num1 时  num2也会得到数值5


传递参数     ECMAScript中所有函数都是按值来进行传递的      如果按值传递参数时值会被复制到一个局部变量（arguments）对象
例如 function addTen(num) { num += 10; return num; } let count = 20; let result = addTen(count); console.log(count); // 20，没有变化 console.log(result); // 30
这里函数addTen（）有一个参数num他是一个局部变量     在调用时count作为参数传入
确定类型      typeof 操作符最适合用来判断一个变量是否为原 始类型      
它是判断一个变量是否为字符串、数值、布尔 值或 undefined 的最好方式
例子
let s = "Nicholas";
let b = true;
let i = 22;
let u;
let n = null;
let o = new Object();
console.log(typeof s);// string
console.log(typeof i);// number
console.log(typeof b);// boolean
console.log(typeof u);// undefined
console.log(typeof n);// object
console.log(typeof o);// object 
 如果想知道他时一个什么类型的对象 可以用instanceof 操作符
语法：     result = variable instanceof constructor
例子 ：     console.log(person instanceof Object); // 变量 persion是Object吗？
console.log(colors instanceof Array); // 变量 colors是Array吗？ 
console.log(pattern instanceof RegExp); // 变量 pattern是RegExp吗？ 
如果所有值都是object的实例 那么通过 instanceof操作符检测任何引用值和 Object 构造函数都会返 回 true
如果用 instanceof 检测原始值，则始终会返 回 false ，因为原始值不是对象


理解执行上下文

执行上下文（以下简称“上下文”）的概念在JavaScript中是颇为重 要的
每个上下文都有一个关联的变量对象（variable object），而 这个上下文中定义的所有变量和函数都存在于这个对象上
全局上下文是最外层的上下文       根据ECMAScript实现表示的全局可能不一样

作用域链增强       虽然执行上下文主要有全局上下文和函数上下文两种（ eval() 调用内部存在第三种上下文），但有其他方式来增强作用域链
try / catch 语句的 catch 块 with 语句 
例子： function buildUrl() { let qs = "?debug=true"; with(location){ let url = href + qs; } return url; } 
这这个例子中 with 语句将 location 对象作为上下文，因此 location 会被添加到作用域链前端          某些 语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码 执行后会被删除
try / catch 语句的 catch 块 with 语句 
的例子： function buildUrl() { let qs = "?debug=true"; with(location){ let url = href + qs; } return url; }
with 语句将 location 对象作为上下文，因此 location 会被添加到作用域链前端

变量声明     var      let 和 const  
. 使用 var 的函数作用域声明
在使用 var 声明变量时，变量会被自动添加到最接近的上下 文 在函数中，最接近的上下文就是函数的局部上下文
例子      function add(num1, num2) { var sum = num1 + num2; return sum; } let result = add(10, 20); // 30 console.log(sum); // 报错：sum在这里不是 有效变量       函数 add() 定义了一个局部变量 sum ，保存加法操作的 结果

使用 let 的块级作用域声明 ES6新增的 let 关键字跟 var 很相似，但它的作用域是块级 的，这也是JavaScript中的新概念。块级作用域由最近的一对包含 花括号 {} 界定。换句话说， if 块、 while 块、 function 块，甚至连单独的块也是 let 声明变量的作用域。 if (true) { let a; } console.log(a); // ReferenceError: a没有定义 while (true) { let b; } console.log(b); // ReferenceError: b没有定义 function foo() { let c; } console.log(c); // ReferenceError: c没有定义 // 这没什么可奇怪的 // var声明也会导致报错 // 这不是对象字面量，而是一个独立的块 // JavaScript解释器会根据其中内容识别出它来 { let d; } console.log(d); // ReferenceError: d没有定义 let 与 var 的另一个不同之处是在同一作用域内不能声明两 次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError 。 var a; var a; // 不会报错 { let b; let b; } // SyntaxError: 标识符b已经声明过了 let 的行为非常适合在循环中声明迭代变量。

. 标识符查找      当在特定上下文中为读取或写入而引用一个标识符时，必须通过 搜索确定这个标识符表示什么     搜索开始于作用域链前端，以给 定的名称搜索对应的标识符。如果在局部上下文中找到该标识 符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作 用域链搜索 
例子： var color = 'blue'; function getColor() { return color; } console.log(getColor()); // 'blue'

理解垃圾回收 
JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码 执行时管理内存
，通过自动内存管理实现内存分配和闲置资源回收     确定哪个变量不会再使用，然后释放它占用的内存      或者说在代码执行过程 中某个预定的收集时间就会自动运行。垃圾回收过程是一个近似且 不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题， 意味着靠算法是解决不了的。 

标记清理     JavaScript最常用的垃圾回收策略是标记清理（mark-andsweep）。
 当变量进入上下文，比如在函数内部声明一个变量时，这个 变量会被加上存在于上下文中的标记

引用计数     另一种没那么常用的垃圾回收策略是引用计数（reference counting）
其思路是对每个值都记录它被引用的次数
所谓循环引用，就是对象A有一个指针指向对象 B，而对象B也引用了对象A。比如： function problem() { let objectA = new Object(); let objectB = new Object(); objectA.someOtherObject = objectB; objectB.anotherObject = objectA; }       objectA 和 objectB 通过各自的属性相互引 用，意味着它们的引用数都是2

性能          垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可 能造成性能损失，因此垃圾回收的时间调度很重要         垃圾回收有可能会明显拖慢渲染的速度和帧速率。 开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代 码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工 作
IE7一下不建议用垃圾回收
     内存管理     在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。 不过，JavaScript运行在一个内存管理与垃圾回收都很特殊的环境。
将内存占用量保持在一个较小的值可以让页面性能更好。优化内 存占用的最佳手段就是保证在执行代码时只保存必要的数据
例子     function createPerson(name){ let localPerson = new Object(); localPerson.name = name; return localPerson; } let globalPerson = createPerson("Nicholas"); // 解除globalPerson对值的引用 globalPerson = null;

通过 const 和 let 声明提升性能 
ES6增加这两个关键字不仅有助于改善代码风格，而且同样有助 于改进垃圾回收的过程。因为 const 和 let 都以块（而非函 数）为作用域，所以相比于使用 var ，使用这两个新关键字可 能会更早地让垃圾回收程序介入，尽早回收应该回收的内存
隐藏类和删除操作
根据JavaScript所在的运行环境，有时候需要根据浏览器使用的 JavaScript引擎来采取不同的性能优化策略
内存泄漏
写得不好的JavaScript可能出现难以察觉且有害的内存泄漏问题。 在内存有限的设备上，或者在函数会被调用很多次的情况下，内 存泄漏可能是个大问题
静态分配与对象池 
为了提升JavaScript性能，最后要考虑的一点往往就是压榨浏览器 了     一个关键问题就是如何减少浏览器执行垃圾回收的次 数。开发者无法直接控制什么时候开始收集垃圾，但可以间接控 制触发垃圾回收的条件

小结     JavaScript变量可以保存两种类型的值：原始值和引用值。原始值 可能是以下6种原始数据类型之一： Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。
     原始值和引用值
原始值大小固定，因此保存在栈内存上。 从一个变量到另一个变量复制原始值会创建该值的第二个副本。 引用值是对象，存储在堆内存上。 包含引用值的变量实际上只包含指向相应对象的一个指针，而不 是对象本身。 从一个变量到另一个变量复制引用值只会复制指针，因此结果是 两个变量都指向同一个对象。 typeof 操作符可以确定值的原始类型，而 instanceof 操作 符用于确保值的引用类型。 任何变量（不管包含的是原始值还是引用值）都存在于某个执行 上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生 命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如 下。 执行上下文分全局上下文、函数上下文和块级上下文。 代码执行流每进入一个新上下文，都会创建一个作用域链，用于 搜索变量和函数。 函数或块的局部上下文不仅可以访问自己作用域内的变量，而且 也可以访问任何包含上下文乃至全局上下文中的变量。 全局上下文只能访问全局上下文中的变量和函数，不能直接访问 局部上下文中的任何数据。 变量的执行上下文用于确定什么时候释放内存。 JavaScript是使用垃圾回收的编程语言，开发者不需要操心内存分 配和回收。JavaScript的垃圾回收程序可以总结如下。 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被 删除。 主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标 记，再回来回收它们的内存。 引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。 JavaScript引擎不再使用这种算法，但某些旧版本的IE仍然会受这 种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如 DOM元素）。 引用计数在代码中存在循环引用时会出现问题。 解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮 助。为促进内存回收，全局对象、全局对象的属性和循环引用都 应该在不需要时解除引用。

》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》

第 5 章 基本引用类型

理解对象
基本JavaScript数据类型

原始值与原始值包装类型 
引用值（或者对象）是某个特定引用类型的实例。在ECMAScript中， 引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”
对象被认为是某个特定引用类型的实例。新对象通过使用 new 操作符 后跟一个构造函数（constructor）来创建、
例子let now = new Date();



这行代码创建了引用类型 Date 的一个新实例，并将它保存在变量now 中

Date

ECMAScript的 Date 类型参考了Java早期版本中的 java.util.Date

Date 类型将日期保存为自协调世界时 时间1970年1月1日午夜（零时）至今 所经过的毫秒数

要创建日期对象，就使用 new 操作符来调用 Date 构造函数：

let now = new Date();

Date.parse() 方法接收一个表示日期的字符串参数，尝试将这个字

符串转换为表示该日期的毫秒数。

“月/日/年”，如 "5/23/2019" ；

“月名 日, 年”，如 "May 23, 2019" ；

“周几 月名 日 年 时:分:秒 时区”，如 "Tue May 23 2019 00:00:00



let someDate = new Date(Date.parse("May 23, 2019"));

创建一个日期的代码


5.1.1 继承的方法

与其他类型一样， Date 类型重写了 toLocaleString() 、

toString() 和 valueOf() 方法     

Date 类型的 toLocaleString() 方法返回与浏览器

运行的本地环境一致的日期和时间



5.1.2 日期格式化方法

Date 类型有几个专门用于格式化日期的方法，它们都会返回字符

串：

toDateString() 显示日期中的周几、月、日、年



toTimeString() 显示日期中的时、分、秒和时区

toLocaleDateString() 显示日期中的周几、月、日、年

toLocaleTimeString() 显示日期中的时、分、秒

toUTCString() 显示完整的UTC日期

5.1.3 日期/时间组件方法

Date 类型剩下的方法（见下表）直接涉及取得或设置日期值的特定

部分

getTime()返回日期的毫秒

setTime(milliseconds)设置日期的毫秒表示，从而修改设置日期的毫秒数

getFullYear() 返回4位数

getUTCFullYear()返回UTC日期 的4位数

setFullYear(year)设置日期的年（ year 必须是4位数）



setUTCFullYear(year)设置UTC日期的年（ year 必须 是4位数）

getMonth()返回日期的月（0表示1月，11表示12月）

getUTCMonth()返回UTC日期的月（0表示1月，11表示12月）

setMonth(month)设置日期的月（ month 为大于0的数值，大于11加年）

setUTCMonth(month)设置UTC日期的月（ month 为大于0的数值，大于11加年）



getDate()返回日期中的日（1~31）

getUTCDate()返回UTC日期中的日（1~31）

setDate(date)设置日期中的日（如果 date 大于该月天数，则加月）

setUTCDate(date)设置UTC日期中的日（如果date 大于该月天数，则加月）

getDay()返回日期中表示周几的数值（0表示周日，6表示周六）

getUTCDay()返回UTC日期中表示周几的数值（0表示周日，6表示周六）

getHours()返回日期中的时（0~23）

getUTCHours()返回UTC日期中的时（0~23）

setHours(hours)设置日期中的时（如果 hours大于23，则加日）

setUTCHours(hours)设置UTC日期中的时（如果

hours 大于23，则加日）

getMinutes()返回日期中的分（0~59）

getUTCMinutes()返回UTC日期中的分（0~59）

setMinutes(minutes)设置日期中的分（如果

minutes 大于59，则加时）

setUTCMinutes(minutes)设置UTC日期中的分（如果

minutes 大于59，则加时）

getSeconds()返回日期中的秒（0~59）

getUTCSeconds()返回UTC日期中的秒（0~59）

setSeconds(seconds)设置日期中的秒（如果

seconds 大于59，则加分）

setUTCSeconds(seconds)设置UTC日期中的秒（如果

seconds 大于59，则加分）

getMilliseconds()返回日期中的毫秒

getUTCMilliseconds()返回UTC日期中的毫秒

setMilliseconds(milliseconds)设置日期中的毫秒

setUTCMilliseconds(milliseconds)设置中的毫秒 UTC日期



getTimezoneOffset()返回以分钟计的UTC与本地时区的偏移量（如美国EST即“东部标准时间”返回300，进

入夏令时的地区可能有所差异）

5.2 RegExp

ECMAScript通过 RegExp 类型支持正则表达式。正则表达式使用类似

Perl的简洁语法来创建：

let expression = /pattern/flags;

g ：全局模式

i ：不区分大小写

m ：多行模式

y ：粘附模式

u ：Unicode模式

s ： dotAll 模式



5.2.1 RegExp 实例属性

每个 RegExp 实例都有下列属性

global ：布尔值，表示是否设置了 g 标记

ignoreCase ：布尔值，表示是否设置了 i 标记

unicode ：布尔值，表示是否设置了 u 标记。

sticky ：布尔值，表示是否设置了 y 标记。

lastIndex ：整数表示在源字符串中下一次搜索的开始位置，始终从0开始

multiline ：布尔值，表示是否设置了 m 标记。

dotAll ：布尔值，表示是否设置了 s 标记

source ：正则表达式的字面量字符串没有凯头和结尾的斜杠

flags ：正则表达式的标记字符串

5.2.2 RegExp 实例方法

RegExp 实例的主要方法是 exec() ，主要用于配合捕获组使用。这

个方法只接收一个参数，即要应用模式的字符串

例子：

let text = "mom and dad and baby";

let pattern = /mom( and dad( and baby)?)?/gi;

let matches = pattern.exec(text);

console.log(matches.index); // 0

console.log(matches.input); // "mom and dad and

baby"console.log(matches[0]); // "mom and dad and

baby"

console.log(matches[1]); // " and dad and baby"

console.log(matches[2]); // " and baby"

5.2.3 RegExp 构造函数属性

RegExp 构造函数本身也有几个属性。

这些属性适用于作用域中的所有正则表达式，而且会根据

最后执行的正则表达式操作而变化。这些属性还有一个特点，就是可以通过

两种不同的方式访问它们。

5.2.4 模式局限

虽然ECMAScript对正则表达式的支持有了长足的进步，但仍然缺少Perl

语言中的一些高级特性

\A 和 \Z 锚（分别匹配字符串的开始和末尾）联合及交叉类原子组

x （忽略空格）匹配模式条件式匹配正则表达式注释

5.3 原始值包装类型

为了方便操作原始值，ECMAScript提供了3种特殊的引用类型：

Boolean 、 Number 和 String

例子：

let s1 = "some text";

let s2 = s1.substring(2);

s1 是一个包含字符串的变量，它是一个原始值。第二行紧接

着在 s1 上调用了 substring() 方法，并把结果保存在 s2 中

(1) 创建一个 String 类型的实例；

(2) 调用实例上的特定方法；

(3) 销毁实例

let s1 = new String("some text");

let s2 = s1.substring(2);

s1 = null;




5.3.1 Boolean

Boolean 是对应布尔值的引用类型要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入 true 或 false

例如let booleanObject = new Boolean(true);

Boolean 的实例会重写 valueOf() 方法，返回一个原始值 true

或 false 。

5.3.2 Number

Number 是对应数值的引用类型。要创建一个 Number 对象，就使用 Number 构造函数并传入一个数值，如下例所示：

let numberObject = new Number(10);

与 Boolean 类型一样， Number 类型重写了 valueOf() 、toLocaleString() 和 toString() 方法。

5.3.3 String

String 是对应字符串的引用类型。要创建一个 String 对象，使

用 String 构造函数并传入一个数值，如下例所示：

let stringObject = new String("hello world");

String 对象的方法可以在所有字符串原始值上调用。3个继承的方

法 valueOf() 、 toLcaleString() 和 toString() 都返回对象的原

始字符串值。

每个 String 对象都有一个 length 属性，表示字符串中字符的数

量。

String 类型提供了很多方法来解析和操作字符串。

1. JavaScript字符 

JavaScript字符串由16位码元（code unit）组成。

2. normalize() 方法

些Unicode字符可以有多种编码方式。有的字符既可以通过一个BMP

字符表示，也可以通过一个代理对表示


比如：

// U+00C5：上面带圆圈的大写拉丁字母A

console.log(String.fromCharCode(0x00C5));

// Å

// U+212B：长度单位“埃”

console.log(String.fromCharCode(0x212B));

// Å

// U+004：大写拉丁字母A

// U+030A：上面加个圆圈

console.log(String.fromCharCode(0x0041, 0x030A));

// Å


3. 字符串操作方法


concat() ，用于将一个

或多个字符串拼接成一个新字符串。


例子：

let stringValue = "hello ";

let result = stringValue.concat("world");

console.log(result); // "hello world"

console.log(stringValue); // "hello


4. 字符串位置方法

有两个方法用于在字符串中定位子字符串： indexOf() 和

lastIndexOf() 都是从字符串中查找 并返回值 如果没有就返回-1

indexOf()是从字符串开头查找

lastIndexOf（）从字符串末尾开始查找



5. 字符串包含方法

ES6   增加了3个用于判断字符串的方法 startsWith() 、 endsWith() 和 includes()


startsWith() 检查开始于索引0的匹配项，

endsWith() 检查开始于索引 (string.length -

substring.length) 的匹配项，而 includes() 检查整个字符串

6. trim() 方法

CMAScript在所有字符串上都提供了 trim() 方法。这个方法会创建

字符串的一个副本，删除前、后所有空格符，再返回结果

如 ： let stringValue = " hello world ";
let trimmedStringValue = stringValue.trim();

console.log(stringValue); // " helloworld "

console.log(trimmedStringValue); // "helloworld"

7. repeat() 方法


这个方法接收

一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后

的结果


8. padStart() 和 padEnd() 方法

法会复制字符串，如果小于指定长

度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个

参数是长度，第二个参数是可选的填充字符串，默认为空格

（U+0020）。

9. 字符串迭代与解构


字符串的原型上暴露了一个 @@iterator 方法，表示可以迭代字符串

的每个字符。


10. 字符串大小写转换


toLowerCase() 、toLocaleLowerCase() 、 toUpperCase() 和toLocaleUpperCase() 。

toLowerCase() 和toUpperCase() 方法是原来就有的方法，与 java.lang.String中的方法同名。 toLocaleLowerCase() 和toLocaleUpperCase() 方法旨在基于特定地区实现

11. 字符串模式匹配方法 

match() 方法 

本质上跟 RegExp 对象的 exec()方法相同。 match() 方法接收一个参数，可以是一个正则表达式字符串，也可以是一个 RegExp


12. localeCompare() 方法 比较字符串


如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负

值   通常是 -1

如果字符串与字符串参数相等，则返回 0


如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正

值   通常是 1

13. HTML方法


anchor(name)<a name="name">string</a>



big()<big>string</big>



bold()<b>string</b>



fixed()<tt>string</tt>



5.4 单例内置对象

对内置对象的定义是“任何由ECMAScript实现提供、与宿主

环境无关，并在ECMAScript程序开始执行时就存在的对象”。这就意味着，

开发者不用显式地实例化内置对象，因为它们已经实例化好了


5.4.1 Global


Global 对象是ECMAScript中最特别的对象，因为代码不会显式地访

问它。


1. URL编码方法


encodeURI() 和 encodeURIComponent() 方法用于编码统一资

源标识符（URI），以便传给浏览器


2. eval() 方法

eval() 。这个方法就是一个完整的ECMAScript解释器，它接收一个

参数，即一个要执行的ECMAScript（JavaScript）字符串


例子：eval("console.log('hi')");

3. Global 对象属性


undefined 、 NaN 和 Infinity 等特殊值都是 Global 对象的属

性  

Object 和 Function ，也都是 Global 对象的属性

4. window 对象

   

浏览器将window 对象实现为 Global 对象的代理

因此，所有全局作用域中

声明的变量和函数都变成了 window 的属性


例子：

var color = "red";

function sayColor() {

console.log(window.color);

}

window.sayColor(); // "red"

5.4.2 Math


Math 对象提供了一些辅助计算的属性和方法。


1. Math 对象属性 Math 对象有一些属性，主要用于保存数学中的一些特殊值

 


2. min() 和 max() 方法 

Math 对象也提供了很多辅助执行简单或复杂数学计算的方法。

min() 和 max() 方法用于确定一组数值中的最小值和最大值。

例子

let max = Math.max(3, 54, 32, 16);

console.log(max); // 54

let min = Math.min(3, 54, 32, 16);

console.log(min); // 3


3. 舍入方法

Math.ceil() 方法始终向上舍入为最接近的整数。

Math.floor() 方法始终向下舍入为最接近的整数。

Math.round() 方法执行四舍五入。

Math.fround() 方法返回数值最接近的单精度（32位）浮点值表示。

4. random() 方法


Math.random() 方法返回一个0~1范围内的随机数，其中包含0但不包含1。

5. 其他方法



Math 对象还有很多涉及各种简单或高阶数运算的方法。讨论每种方

法的具体细节或者它们的适用场景超出了本书的范畴


Math.abs(x) 返回 x 的绝对值

Math.exp(x) 返回 Math.E 的 x 次幂

Math.expm1(x) 等于 Math.exp(x) - 1 

...

...

此处省略好多字

5.5 小结


JavaScript中的对象称为引用值


引用值与传统面向对象编程语言中的类相似，但实现不同


Date 类型提供关于日期和时间的信息，包括当前日期、时间及相关计算



RegExp 类型是ECMAScript支持正则表达式的接口，提供了大多数基础的和部分高级的正则表达式功能

由于原始值包装类型的存在，JavaScript中的原始值可以被当成对象来使用。有3种原始值包装类型： Boolean 、 Number 和 String 。

每种包装类型都映射到同名的原始类型。以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借

助这个对象可以操作相应的数据。涉及原始值的语句执行完毕后，包装对象就会被销毁

当代码开始执行时，全局上下文中会存在两个内置对象： Global 和Math 。其中， Global 对象在大多ECMAScript实现中无法直接访问。不过，浏览器将其实现为 window 对象。所有全局变量和函数都是Global 对象的属性。 Math 对象包含辅助完成复杂计算的属性和方法。


第六章 292~385 
6.1 Object
 Object 是ECMAScript中最常用的类型之一。虽然 Object 的实例没有 多少功能，但很适合存储和在应用程序间交换数据
 显式地创建 Object 的实例有两种方式。第一种是使用 new 操作符 和 Object 构造函数
示例如下 let person = new Object(); person.name = "Nicholas"; person.age = 29;

另一种方式是使用对象字面量（object literal）表示法。对象字面量是 对象定义的简写形式，目的是为了简化包含大量属性的对象的创建
let person = { name: "Nicholas" , age: 29 };
虽然使用哪种方式创建 Object 实例都可以，但实际上开发者更倾向 于使用对象字面量表示法。这是因为对象字面量代码更少，看起来也更有 封装所有相关数据的感觉
比如： function displayInfo(args) { let output = ""; if (typeof args.name == "string"){ output += "Name: " + args.name + "\n"; } if (typeof args.age == "number") { output += "Age: " + args.age + "\n"; } alert(output); } displayInfo({ name: "Nicholas" , age: 29 }); displayInfo({ name: "Greg" });

6.2 Array 
除了 Object ， Array 应该就是ECMAScript中最常用的类型了。 ECMAScript数组跟其他编程语言的数组有很大区别。跟其他语言中的数组 一样，ECMAScript数组也是一组有序的数据，但跟其他语言不同的是，数 组中每个槽位可以存储任意类型的数据
可以创建一个数组，它 的第一个元素是字符串，第二个元素是数值，第三个是对象。ECMAScript 数组也是动态大小的，会随着数据添加而自动增长
6.2.1 创建数组 
有几种基本的方式可以创建数组。一种是使用 Array 构造函数，比 如： let colors = new Array(); 
如果知道数组中元素的数量，那么可以给构造函数传入一个数值，然 后 length 属性就会被自动创建并设置为这个值。
下面的代码会创 建一个初始 length 为20的数组
let colors = new Array(20);
也可以给 Array 构造函数传入要保存的元素。
创建一个包含3个字符串值的数组： let colors = new Array("red" , "blue" , "green");
 let colors = new Array(3); // 创建一个包含3个元素的 数组 let names = new Array("Greg"); // 创建一个只包含一个元 素，即字符串"Greg"的数组 在使用 Array 构造函数时，也可以省略 new 操作符。结果是一样 的，比如： let colors = Array(3); // 创建一个包含3个元素的数组 let names = Array("Greg"); // 创建一个只包含一个元素，即 字符串"Greg"的数组
  Array 构造函数还有两个ES6新增的用于创建数组的静态方法： from() 和 of() 。 from() 用于将类数组结构转换为数组实例，而 of() 用于将一组参数转换为数组实例。 Array.from() 的第一个参数是一个类数组对象，即任何可迭代的 结构，或者有一个 length 属性和可索引元素的结构。这种方式可用于很 多场合： // 字符串会被拆分为单字符数组 console.log(Array.from("Matt")); // ["M" , "a" , "t" , "t"] // 可以使用from()将集合和映射转换为一个新数组 const m = new Map().set(1, 2) .set(3, 4); const s = new Set().add(1) .add(2) .add(3) .add(4); console.log(Array.from(m)); // [[1, 2], [3, 4]] console.log(Array.from(s)); // [1, 2, 3, 4] // Array.from()对现有数组执行浅复制 const a1 = [1, 2, 3, 4]; const a2 = Array.from(a1); console.log(a1); // [1, 2, 3, 4] alert(a1 === a2); // false // 可以使用任何可迭代对象 const iter = { *[Symbol.iterator]() { yield 1; yield 2; yield 3; yield 4; } }; console.log(Array.from(iter)); // [1, 2, 3, 4] // arguments对象可以被轻松地转换为数组 function getArgsArray() { return Array.from(arguments); } console.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4] // from()也能转换带有必要属性的自定义对象 const arrayLikeObject = { 0: 1, 1: 2, 2: 3, 3: 4, length: 4 }; console.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4] 
Array.from() 还接收第二个可选的映射函数参数
Array.prototype.slice.call(arguments) ，一种异 常笨拙的将 arguments 对象转换为数组的写法： console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4] console.log(Array.of(undefined)); // [undefined]
6.2.2 数组空位
使用数组字面量初始化数组时，可以使用一串逗号来创建空位 （hole）。 
const options = [,,,,,]; // 创建包含5个元素的数组 console.log(options.length); // 5 console.log(options); // [,,,,,]
6.2.3 数组索引
要取得或设置数组的值，需要使用中括号并提供相应值的数字索引， 如下所示： let colors = ["red" , "blue" , "green"]; // 定义一个字 符串数组 alert(colors[0]); // 显示第一项 colors[2] = "black"; // 修改第三项 colors[3] = "brown"; // 添加第四项
使用 length 属性可以方便地向数组末尾添加元素
数组中最后一个元素的索引始终是 length - 1 ，因此下一个新增 槽位的索引就是 length 
6.2.4 检测数组

ECMAScript问题是判断一个对象是不是数组 使用 instanceof 操作符
if (value instanceof Array){ // 操作数组 }
6.2.5 迭代器方法
Array 的原型上暴露了3个用于检索数组内容的方法： keys() 、 values() 和 entries() 。 keys() 返回数组索引的迭 代器， values() 返回数组元素的迭代器，而 entries() 返回索引/值 对的迭代器
const a = ["foo" , "bar" , "baz" , "qux"]; // 因为这些方法都返回迭代器，所以可以将它们的内容 // 通过Array.from()直接转换为数组实例 const aKeys = Array.from(a.keys()); const aValues = Array.from(a.values()); const aEntries = Array.from(a.entries()); console.log(aKeys); // [0, 1, 2, 3] console.log(aValues); // ["foo" , "bar" , "baz" , "qux"] console.log(aEntries); // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]] 
6.2.6 复制和填充方法 
：批量复制方法 fill() ，以及填充数组方法 copyWithin() 
使用 fill() 方法可以向一个已有的数组中插入全部或部分相同的 值
fill() 静默忽略超出数组边界、零长度及方向相反的索引范围
与 fill() 不同， copyWithin() 会按照指定范围浅复制数组中的 部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引 则与 fill() 使用同样的计算方法： 
copyWithin() 静默忽略超出数组边界、零长度及方向相反的索引 范围
6.2.7 转换方法 
所有对象都有 toLocaleString() 、 toString() 和 valueOf() 方法
valueOf() 返回的还是数组本身。而 toString() 返回由数组中每个值的等效字符串拼接而成的一个逗号分 隔的字符串
首先是被显式调用的 toString() 和 valueOf() 方法， ，它们分别 返回了数组的字符串表示，即将所有字符串组合起来，以逗号分隔
toLocaleString() 方法也可能返回跟 toString() 和 valueOf() 相同的结果，但也不一定。在调用数组的 toLocaleString() 方法时，会得到一个逗号分隔的数组值的字符串。 它与另外两个方法唯一的区别是，为了得到最终的字符串，会调用数组每 个值的 toLocaleString() 方法，而不是 toString() 方法
6.2.8 栈方法
数据项的插入（称为推入，push）和删除（称为弹出，pop） 只在栈的一个地方发生，即栈顶。ECMAScript数组提供了 push() 和 pop() 方法，以实现类似栈的行为
push() 方法接收任意数量的参数，并将它们添加到数组末尾，返回 数组的最新长度
pop() 方法则用于删除数组的最后一项，同时减少数 组的 length 值，返回被删除的项
6.2.9 队列方法 
就像栈是以LIFO形式限制访问的数据结构一样，队列以先进先出 （FIFO，First-In-First-Out）形式限制访问
。队列在列表末尾添加数据，但 从列表开头获取数据。因为有了在数据末尾添加数据的 push() 方法，所 以要模拟队列就差一个从数组开头取得数据的方法了。这个数组方法叫 shift() ，它会删除数组的第一项并返回它，然后数组长度减1

6.2.11 操作方法
对于数组中的元素，我们有很多操作方法。比如， concat() 方法 可以在现有数组全部元素基础上创建一个新数组
let colors = ["red" , "green" , "blue"]; let colors2 = colors.concat("yellow" , ["black" , "brown"]); console.log(colors); // ["red" , "green" , "blue"] console.log(colors2); // ["red" , "green" , "blue", "yellow" , "black" , "brown"] 
这里先创建一个包含3个值的数组 colors 。然后 colors 调用 concat() 方法，传入字符串 "yellow" 和一个包 含 "black" 和 "brown" 的数组。保存在 colors2 中的结果就是 ["red" , "green" , "blue", "yellow", "black", "brown"] 。原始数组 colors 保持不变
lice() 方法可以接收一个或两个参数：返回元素的开始 索引和结束索引。如果只有一个参数，则 slice() 会返回该索引到数组 末尾的所有元素。
这里， colors 数组一开始有5个元素。调用 slice() 传入1会得到 包含4个元素的新数组
。因此 colors3 包含 "green" 、 "blue" 和 "yellow" 。
删除。需要给 splice() 传2个参数：要删除的第一个元素的位置和 要删除的元素数量。
插入。需要给 splice() 传3个参数：开始位置、0（要删除的元素 数量）和要插入的元素，可以在数组中指定的位置插入元素。
替换。 splice() 在删除元素的同时可以在指定位置插入新元素， 同样要传入3个参数：开始位置、要删除元素的数量和要插入的任意 多个元素
6.2.12 搜索和位置方法
1. 严格相等 ECMAScript提供了3个严格相等的搜索方法： indexOf() 、 lastIndexOf() 和 includes() 。
2. 断言函数 ECMAScript也允许按照定义的断言函数搜索数组，每个索引都会调用 这个函数。

6.2.13 迭代方法
每个方法接收两个参数：以 每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象 （影响函数中 this 的值）。
every() ：对数组每一项都运行传入的函数，如果对每一项函数都 返回 true ，则这个方法返回 true 。 filter() ：对数组每一项都运行传入的函数，函数返回 true 的 项会组成数组之后返回。 forEach() ：对数组每一项都运行传入的函数，没有返回值。 map() ：对数组每一项都运行传入的函数，返回由每次函数调用的 结果构成的数组。 some() ：对数组每一项都运行传入的函数，如果有一项函数返回 true ，则这个方法返回 true 。

6.2.14 归并方法 
： reduce() 和 reduceRight() 。这两个方法都会迭代数组的所有项，并在此基础上 构建一个最终返回值。 reduce() 方法从数组第一项开始遍历到最后一 项。而 reduceRight() 从最后一项开始遍历至第一项。

6.3 定型数组
定型数组（typed array）是ECMAScript新增的结构，目的是提升向原 生库传输数据的效率。

6.3.4 定型数组
定型数组是另一种形式的 ArrayBuffer 视图。虽然概念上与 DataView 接近，但定型数组的区别在于，它特定于一种 ElementType 且遵循系统原生的字节序

6.4 Map 

在JavaScript中实现“键/值”式存储可以使用 Object 来方便高效地完成，也就是使用对象属性作为键，再使用属性来 引用值。但这种实现并非没有问题，为此TC39委员会专门为“键/值”存储定 义了一个规范。 
6.4.1 基本API
使用 new 关键字和 Map 构造函数可以创建一个空映射： const m = new Map(); 如果想在创建的同时初始化实例，可以给 Map 构造函数传入一个可 迭代对象，需要包含键/值对数组。

6.4.2 顺序与迭代 与 Object 类型的一个主要差异是， Map 实例会维护键值对的插入 顺序，因此可以根据插入顺序执行迭代操作。
因为 entries() 是默认迭代器，所以可以直接对映射实例使用扩展 操作，把映射转换为数组：

6.4.3 选择 Object 还是 Map
选择 Object 还是 Map 只是个人偏好 问题，影响不大。
1. 内存占用 Object 和 Map 的工程级实现在不同浏览器间存在明显差异，但存 储单个键/值对所占用的内存数量都会随键的数量线性增加。
2. 插入性能 向 Object 和 Map 中插入新键/值对的消耗大致相当，不过插入 Map 在所有浏览器中一般会稍微快一点儿
3. 查找速度 与插入不同，从大型 Object 和 Map 中查找键/值对的性能差异极 小，但如果只包含少量键/值对，则 Object 有时候速度更快。
4. 删除性能 使用 delete 删除 Object 属性的性能一直以来饱受诟病，目前在 很多浏览器中仍然如此。



第 8 章 对象、类与面向对象编程

 

8.1 理解对象 

创建自定义对象 是创建 Object 的一个新实例，然后 再给它添加属性和方法，

let person = new Object(); person.name = "Nicholas"; person.age = 29; person.job = "Software Engineer"; person.sayName = function() { console.log(this.name); };

8.1.1 属性的类型 

属性分两种：数据属性和访问器属性。

\1. 数据属性  数据属性包含一个保存数据值的位置。值会从这个位置读取，也 会写入到这个位置。数据属性有4个特性描述它们的行为。

[[Configurable]] ：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把 它改为访问器属性默认情况下，所有直接定义在对象上的 属性的这个特性都是 true

[[Enumberable]] ：表示属性是否可以通过 for-in 循 环返回。默认情况下，所有直接定义在对象上的属性的这个 特性都是 true ，

[[Writable]] ：表示属性的值是否可以被修改。默认情 况下，所有直接定义在对象上的属性的这个特性都是 true 

[[Value]] ：包含属性实际的值。这就是前面提到的那个 读取和写入属性值的位置。这个特性的默认值为 undefined 。 

在像前面例子中那样将属性显式添加到对象之后， [[Configurable]] 、 [[Enumerable]] 和 [[Writable]] 都会被设置为 true ，而 [[Value]] 特性会 被设置为指定的值

修改属性的默认特性，就必须使用 Object.defineProperty() 方法。

这个方法接收3个参数： 要给其添加属性的对象、属性的名称和一个描述符对象。最后一 个参数，即描述符对象上的属性可以包含： configurable 、 enumerable 、 writable 和 value ，跟相关特性的名称一 一对应。根据要修改的特性，可以设置其中一个或多个值。

let person = {}; Object.defineProperty(person, "name" , { configurable: false, value: "Nicholas" }); console.log(person.name); // "Nicholas" delete person.name; console.log(person.name); // "Nicholas"

**2. 访问器属性**  访问器属性不包含数据值

包含一个获取（getter）函 数和一个设置（setter）函数  **在读 取访问器属性时，会调用获取函数，这个函数的责任就是返回一 个有效的值。在写入访问器属性时，会调用设置函数并传入新 值，这个函数必须决定对数据做出什么修改。访问器属性有4个特 性描述它们的行为。** 

[[Configurable]] ：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把 它改为数据属性。默认情况下，所有直接定义在对象上的属 性的这个特性都是 true 。

[[Configurable]] ：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把 它改为数据属性。默认情况下，所有直接定义在对象上的属 性的这个特性都是 true 。

[[Get]] ：获取函数，在读取属性时调用。默认值为 undefined 。

[[Set]] ：设置函数，在写入属性时调用。默认值为 undefined 。

访问器属性是不能直接定义的，必须使用 Object.defineProperty() 

例子：

let book = { year_: 2017, edition: 1 }; Object.defineProperty(book, "year" , { get() { return this.year_; }, set(newValue) { if (newValue > 2017) { this.year_ = newValue; this.edition += newValue - 2017; } } }); book.year = 2018; console.log(book.edition); // 2

获取函数和设置函数不一定都要定义。只定义获取函数意味着属 性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入 只定义了获取函数的属性会抛出错误。 ，非严格模式下读取会返回 undefined ，严格模式下会抛出错误。  在不支持 Object.defineProperty() 的浏览器中没有办法 修改 [[Configurable]] 或 [[Enumerable]] 。 

**8.1.2 定义多个属性 在一个对象上同时定义多个属性了 Object.defineProperties() 方法。**

**通过多个描述符一次性定义多个属性 接收两个参数：要为 之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修 改的属性一一对应。
**

比如： let book = {}; Object.defineProperties(book, { year_: { value: 2017 }, edition: { value: 1 }, year: { get() { return this.year_; }, set(newValue) { if (newValue > 2017) { this.year_ = newValue; this.edition += newValue - 2017; } } } }); 

**8.1.3 读取属性的特性** 使用 Object.getOwnPropertyDescriptor() 方法可以取 得指定属性的属性描述符。

方法接收两个参数：属性所在的对象 和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包 含 configurable 、 enumerable 、 get 和 set 属性，对于数 据属性包含 configurable 、 enumberable 、 writable 和 value 属性。

比如： let book = {}; Object.defineProperties(book, { year_: { value: 2017 }, edition: { value: 1 }, year: { get: function() { return this.year_; }, set: function(newValue){ if (newValue > 2017) { this.year_ = newValue; this.edition += newValue - 2017; } } } }); let descriptor = Object.getOwnPropertyDescriptor(book, "year_"); console.log(descriptor.value); // 2017 console.log(descriptor.configurable); // false console.log(typeof descriptor.get); // "undefined" let descriptor = Object.getOwnPropertyDescriptor(book, "year"); console.log(descriptor.value); // undefined console.log(descriptor.enumerable); // false console.log(typeof descriptor.get); // "function" 

**8.1.4 合并对象 
**

JavaScript开发者经常觉得“合并”（merge）两个对象很有用。更具 体地说，就是把源对象所有的本地属性一起复制到目标对象上。有时 候这种操作也被称为“混入”（mixin），因为目标对象通过混入源对象 的属性得到了增强。 

ES6专门为合并对象提供了 Object.assign() 方 法。 然后 将每个源对象中可枚举（ Object.propertyIsEnumerable() 返 回 true ）和自有（ Object.hasOwnProperty() 返回 true ） 属性复制到目标对象

Object.assign() 实际上对每个源对象执行的是浅复制。如 果多个源对象都有相同的属性，则使用最后一个复制的值

8.1.5 对象标识及相等判定 **在ECMAScript 6之前，有些特殊情况即使是 === 操作符也无能 为力 为改善这类情况，ECMAScript 6规范新增了 Object.is() ，这 个方法与 === 很像，但同时也考虑到了上述边界情形。这个方法必 须接收两个参数：**

要检查超过两个值，递归地利用相等性传递即可：

**8.1.6 增强的对象语法 ECMAScript 6为定义和操作对象新增了很多极其有用的语法糖特 性。这些特性都没有改变现有引擎的行为，但极大地提升了处理对象 的方便程度。
**

 **1. 属性值简写 在给对象添加变量的时候，开发者经常会发现属性名和变量名是 一样的。

**

\2. 可计算属性 在引入可计算属性之前，如果想使用变量的值作为属性，那么必 须先声明对象，然后使用中括号语法来添加属性。

\3. 简写方法名 在给对象定义方法时，通常都要写一个方法名、冒号，然后再引 用一个匿名函数表达式，

**8.1.7 对象解构 ECMAScript 6新增了对象解构语法，可以在一条语句中使用嵌套 数据实现一个或多个赋值操作。对象解构就是使用与对象 匹配的结构来实现对象属性赋值。
**

**1. 嵌套解构  解构对于引用嵌套的属性或赋值目标没有限制。为此，可以通过 解构来复制对象属性  解构赋值可以使用嵌套结构，以匹配嵌套的属性：
**

**2. 部分解构  。如果一个解构表达式涉及多个赋值，开始的赋值成功而 后面的赋值出错，则整个解构赋值只会完成一部分
**

**3. 参数上下文匹配 在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会 影响 arguments 对象，但可以在函数签名中声明在函数体内使 用局部变量：
**

**8.2 创建对象 
**

**创建具有同样接口的多个对象需要重复编 写很多代码。 
**

**ES6开始正式支持类和继承 ES6的类旨在完全涵盖之 前规范设计的基于原型的继承模式。**

**8.2.2 工厂模式  工厂模式是一种众所周知的设计模式，广泛应用于软件工程领 域，用于抽象创建特定对象的过程。
**

 **8.2.3 构造函数模式   ECMAScript中的构造函数是用于创建特定类型 对象的。像 Object 和 Array 这样的原生构造函数，运行时可以直 接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为 自己的对象类型定义属性和方法。**

**要创建 Person 的实例，应使用 new 操作符。
**

**(1) 在内存中创建一个新对象。 (2) 这个新对象内部的 [[Prototype]] 特性被赋值为构造函数 的 prototype 属性。 (3) 构造函数内部的 this 被赋值为这个新对象（即 this 指向 新对象）。 (4) 执行构造函数内部的代码（给新对象添加属性）。 (5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创 建的新对象。
**

**1. 构造函数也是函数 构造函数与普通函数唯一的区别就是调用方式不同。除此之外， 构造函数也是函数。 并没有把某个函数定义为构造函数的特殊语 法。任何函数只要使用 new 操作符调用就是构造函数，而不使 用 new 操作符调用的函数就是普通函数。
**

**2. 构造函数的问题 构造函数虽然有用，但也不是没有问题。构造函数的主要问题在 于，其定义的方法会在每个实例上都创建一遍。因此对前面的例 子而言， person1 和 person2 都有名为 sayName() 的方 法，但这两个方法不是同一个 Function 实例。
**

**8.2.4 原型模式
**

**每个函数都会创建一个 prototype 属性，这个属性是一个对 象，包含应该由特定引用类型的实例共享的属性和方法。
**

**使用原型对象的好 处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造 函数中直接赋给对象实例的值，可以直接赋值给它们的原型，
**

**1. 理解原型 
**

**无论何时，只要创建一个函数，就会按照特定的规则为这个函数 创建一个 prototype 属性（指向原型对象）。默认情况下，所 有原型对象自动获得一个名为 constructor 的属性，指回与之 关联的构造函数。
**

**在自定义构造函数时，原型对象默认只会获得 constructor 属 性，其他的所有方法都继承自 Object 。每次调用构造函数创建 一个新实例，这个实例的内部 [[Prototype]] 指针就会被赋 值为构造函数的原型对象
**

**[[Prototype]] 特性的标准方式，但Firefox、Safari和Chrome 会在每个对象上暴露 __proto__ 属性，通过这个属性可以访问 对象的原型。
**

**2. 原型层级 
**

**在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索 开始于对象实例本身。如果在这个实例上发现了给定的名称，则 返回该名称对应的值。
**

**在调用 person1.sayName() 时，会发生两步搜 索。首先，JavaScript引擎会问：“ person1 实例有 sayName 属性吗？”答案是没有。然后，继续搜索并问：“ person1 的原 型有 sayName 属性吗？”答案是有。于是就返回了保存在原型上 的这个函数。在调用 person2.sayName() 时，会发生同样的 搜索过程，而且也会返回相同的结果。这就是原型用于在多个对 象实例间共享属性和方法的原理。 因此，在调用 person1.sayName() 时，会发生两步搜 索。首先，JavaScript引擎会问：“ person1 实例有 sayName 属性吗？”答案是没有。然后，继续搜索并问：“ person1 的原 型有 sayName 属性吗？”答案是有。于是就返回了保存在原型上 的这个函数。在调用 person2.sayName() 时，会发生同样的 搜索过程，而且也会返回相同的结果。这就是原型用于在多个对 象实例间共享属性和方法的原理。 
**

**3. 原型和 in 操作符 有两种方式使用 in 操作符：单独使用和在 for-in 循环中使 用。在单独使用时， in 操作符会在可以通过对象访问指定属性 时返回 true ，无论该属性是在实例上还是在原型上。 只要通过对象可以访问， in 操作符就返回 true ，而 hasOwnProperty() 只有属性存在于实例上时才返回 true 。因此，只要 in 操作符返回 true 且 hasOwnProperty() 返回 false ，就说明该属性是一个原型 属性。
**

**4. 属性枚举顺序 
**

**for-in 循环、 Object.keys() 、 Object.getOwnPropertyNames() 、 Object.getOwnPropertySymbols() 以及 Object.assign() 在属性枚举顺序方面有很大区别。 forin 循环和 Object.keys() 的枚举顺序是不确定的，取决于 JavaScript引擎，可能因浏览器而异。 Object.getOwnPropertyNames() 、 Object.getOwnPropertySymbols() 和 Object.assign() 的枚举顺序是确定性的。先以升序枚举数 值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定 义的键以它们逗号分隔的顺序插入。
**

**8.2.5 对象迭代
**

**在JavaScript有史以来的大部分时间内，迭代对象属性都是一个难 题。 用于将对象内容转换为序 列化的——更重要的是可迭代的——格式。这两个静态方法 Object.values() 和 Object.entries() 接收一个对象，返回 它们内容的数组。 Object.values() 返回对象值的数组， Object.entries() 返回键/值对的数组。
**

**1. 其他原型语法
**

每次定义一个属性或方 法都会把 Person.prototype 重写一遍。为了减少代码冗余， 也为了从视觉上更好地封装原型功能

function Person() {} Person.prototype = { name: "Nicholas" , age: 29, job: "Software Engineer" , sayName() { console.log(this.name); } }; 

**2. 原型的动态性 因为从原型上搜索值的过程是动态的，所以即使实例在修改原型 之前已经存在，任何时候对原型对象所做的修改也会在实例上反 映出来。**

**例子： let friend = new Person(); Person.prototype.sayHi = function() { console.log("hi"); }; friend.sayHi(); // "hi"，没问题！ 以上代码先创建一个 Person 实例
**

**3. 原生对象原型 
**

 **原型模式之所以重要，不仅体现在自定义类型上，而且还因为它 也是实现所有原生引用类型的模式。所有原生引用类型的构造函 数（包括 Object 、 Array 、 String 等）都在原型上定义 了实例方法。**

**4. 原型的问题  原型模式也不是没有问题。首先，它弱化了向构造函数传递初始 化参数的能力，会导致所有实例默认都取得相同的属性值。虽
**

**这会带来不便，但还不是原型的最大问题。原型的最主要问题源 自它的共享特性。 原型上的所有属性是在实例间共享的，这对函数来说 比较合适。另外包含原始值的属性也还好，
**

**例子： function Person() {} Person.prototype = { constructor: Person, name: "Nicholas" , age: 29, job: "Software Engineer" , friends: ["Shelby" , "Court"], sayName() { console.log(this.name); } }; let person1 = new Person(); let person2 = new Person(); person1.friends.push("Van"); console.log(person1.friends); // "Shelby,Court,Van" console.log(person2.friends); // "Shelby,Court,Van" console.log(person1.friends === person2.friends); // true 
**

**8.3 继承 
**

**继承是面向对象编程中讨论最多的话题。很多面向对象语言都支 持两种继承：接口继承和实现继承
**

**8.3.1 原型链 原型链定义为ECMAScript的主要继承方式
**

**其基本 思想就是通过原型继承多个引用类型的属性和方法。重温一下构造函 数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一 个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是 另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向 另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。
**

**实现原型链涉及如下代码模式： function SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function() { return this.property; }; function SubType() { this.subproperty = false; } // 继承SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function () { return this.subproperty; }; let instance = new SubType(); console.log(instance.getSuperValue()); // true
**

**SubType 通过创建 SuperType 的实例并将其赋值给自己的原型 SubTtype.prototype 实现了对 SuperType 的继承。这个赋值 重写了 SubType 最初的原型，将其替换为 SuperType 的实例。这 意味着 SuperType 实例可以访问的所有属性和方法也会存在于 SubType.prototype 。这样实现继承之后，代码紧接着又给 SubType.prototype ，也就是这个 SuperType 的实例添加了一 个新方法。最后又创建了 SubType 的实例并调用了它继承的 getSuperValue() 方法。
**

**1. 默认原型 
**

**原型链中还有一环。默认情况下，所有引用类型都继承 自 Object ，这也是通过原型链实现的。任何函数的默认原型都 是一个 Object 的实例，这意味着这个实例有一个内部指针指 向 Object.prototype 。
**

**2. 原型与继承关系
**

**原型与实例的关系可以通过两种方式来确定。第一种方式是使用 instanceof 操作符，如果一个实例的原型链中出现过相应的 构造函数，则 instanceof 返回 true
**

**3. 关于方法 
**

**子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为 此，这些方法必须在原型赋值之后再添加到原型上。
**

**4. 原型链的问题
**

**问题出 现在原型中包含引用值的时候。前面在谈到原型的问题时也提到 过，原型中包含的引用值会在所有实例间共享，这也是为什么属 性通常会在构造函数中定义而不会定义在原型上的原因。在使用 原型实现继承时，原型实际上变成了另一个类型的实例。这意味 着原先的实例属性摇身一变成为了原型属性。
**

**例子  function SuperType() { this.colors = ["red" , "blue" , "green"]; } function SubType() {} // 继承SuperType SubType.prototype = new SuperType(); let instance1 = new SubType(); instance1.colors.push("black"); console.log(instance1.colors); // "red,blue,green,black" let instance2 = new SubType(); console.log(instance2.colors); // "red,blue,green,black" 
**

**8.3.2 盗用构造函数
**

**为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函 数”（constructor stealing）的技术在开发社区流行起来（这种技术有时 也称作“对象伪装”或“经典继承”）。 在子类构造函 数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码 的简单对象，所以可以使用 apply() 和 call() 方法以新创建的对 象为上下文执行构造函数。
**

**1. 传递参数 相比于使用原型链，盗用构造函数的一个优点就是可以在子类构 造函数中向父类构造函数传参。
**

**2. 盗用构造函数的问题 盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的 问题：必须在构造函数中定义方法，因此函数不能重用。
**

**8.3.3 组合继承 
**

 **组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函 数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上 的属性和方法，而通过盗用构造函数继承实例属性。**

**例子： function SuperType(name){ this.name = name; this.colors = ["red" , "blue" , "green"]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age){ // 继承属性 SuperType.call(this, name); this.age = age; } // 继承方法 SubType.prototype = new SuperType(); SubType.prototype.sayAge = function() { console.log(this.age); }; let instance1 = new SubType("Nicholas" , 29); instance1.colors.push("black"); console.log(instance1.colors); // "red,blue,green,black" instance1.sayName(); // "Nicholas"; instance1.sayAge(); // 29 let instance2 = new SubType("Greg" , 27); console.log(instance2.colors); // "red,blue,green" instance2.sayName(); // "Greg"; instance2.sayAge(); // 27** 

**8.3.4 原型式继承
**

**function object(o) { function F() {} F.prototype = o; return new F(); } 
**

**object() 函数会创建一个临时构造函数，将传入的对象 赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。
**

**你有一个对象，想 在它的基础上再创建一个新对象。你需要把这个对象先传给 object() ，然后再对返回的对象进行适当修改。在这个例子中， person 对象定义了另一个对象也应该共享的信息，把它传给 object() 之后会返回一个新对象。这个新对象的原型是 person ，意味着它的原型上既有原始值属性又有引用值属性。这也 意味着 person.friends 不仅是 person 的属性，也会跟 anotherPerson 和 yetAnotherPerson 共享。这里实际上克隆 了两个 person 。 
**

**8.3.5 寄生式继承 
**

**与原型式继承比较接近的一种继承方式是寄生式继承（parasitic inheritance），也是Crockford首倡的一种模式。寄生式继承背后的思 路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某 种方式增强对象，然后返回这个对象
**

**function createAnother(original){ let clone = object(original); // 通过调用函数创 建一个新对象 clone.sayHi = function() { // 以某种方式增强 这个对象 console.log("hi"); }; return clone; // 返回这个对象 } 
**

**8.3.6 寄生式组合继承
**

**组合继承其实也存在效率问题。最主要的效率问题就是父类构造 函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在 子类构造函数中调用
**

**本质上，子类原型最终是要包含超类对象的所 有实例属性，子类构造函数只要在执行时重写自己的原型就行了
**

**例子： function SuperType(name) { this.name = name; this.colors = ["red" , "blue" , "green"]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age){ SuperType.call(this, name); // 第二次调用 SuperType() this.age = age; } SubType.prototype = new SuperType(); // 第一次调 用SuperType() SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function() { console.log(this.age); }; 
**

**8.4 类
**

**类（class）是ECMAScript中新的基础性语法糖结 构，因此刚开始接触时可能会不太习惯。虽然ECMAScript 6类表面上 看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是 原型和构造函数的概念。 
**

**8.4.1 类定义
**

  **与函数类型相似，定义类也有两种主要方式：类声明和类表达 式。这两种方式都使用 class 关键字加大括号：**

**// 类声明 class Person {} // 类表达式 const Animal = class {}; 
**

**类的构成 类可以包含构造函数方法、实例方法、获取函数、设置函数和静 态类方法，但这些都不是必需的。空的类定义照样有效。默认情况 下，类定义中的代码都在严格模式下执行
**

**与函数构造函数一样，多数编程风格都建议类名的首字母要大 写，以区别于通过它创建的实例（比如，通过 class Foo {} 创建 实例 foo ）： // 空类定义，有效 class Foo {} // 有构造函数的类，有效 class Bar { constructor() {} } // 有获取函数的类，有效 class Baz { get myBaz() {} } // 有静态方法的类，有效 class Qux { static myQux() {} } 类表
**

**8.4.2 类构造函数
**

**constructor 关键字用于在类定义块内部创建类的构造函数。 方法名 constructor 会告诉解释器在使用 new 操作符创建类的新 实例时，应该调用这个函数。构造函数的定义不是必需的，不定义构 造函数相当于将构造函数定义为空函数
**

**1. 实例化 使用 new 操作符实例化 Person 的操作等于使用 new 调用其 构造函数。唯一可感知的不同之处就是，JavaScript解释器知道使 用 new 和类意味着应该使用 constructor 函数进行实例化。
**

**使用new调用类的构造函数会执行如下操作。 (1) 在内存中创建一个新对象。 (2) 这个新对象内部的 [[Prototype]] 指针被赋值为构造函数 的 prototype 属性。 (3) 构造函数内部的 this 被赋值为这个新对象（即 this 指向 新对象）。 (4) 执行构造函数内部的代码（给新对象添加属性）。 (5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创 建的新对象。 来看下面的例子： class Animal {} class Person { constructor() { console.log('person ctor'); } } class Vegetable { constructor() { this.color = 'orange'; } } let a = new Animal(); let p = new Person(); // person ctor let v = new Vegetable(); console.log(v.color); // orange 类实例化时传入的参数会用作构造函数的
**

**2. 把类当成特殊函数 ECMAScript中没有正式的类这个类型。从各方面来看， ECMAScript类就是一种特殊函数。声明一个类之后，通过 typeof 操作符检测类标识符，表明它是一个函数： class Person {} console.log(Person); // class Person {} console.log(typeof Person); // function
**

**8.4.3 实例、原型和类成员
**

**1. 实例成员 每次通过 new 调用类标识符时，都会执行类构造函数。在这个 函数内部，可以为新创建的实例（ this ）添加“自有”属性。
**

**每个实例都对应一个唯一的成员对象，这意味着所有成员都不会 在原型上共享： 
**

**class Person { constructor() { // 这个例子先使用对象包装类型定义一个字符串 // 为的是在下面测试两个对象的相等性 this.name = new String('Jack'); this.sayName = () => console.log(this.name); this.nicknames = ['Jake' , 'J-Dog'] } } let p1 = new Person(), p2 = new Person(); p1.sayName(); // Jack p2.sayName(); // Jack console.log(p1.name === p2.name); // false console.log(p1.sayName === p2.sayName); // false console.log(p1.nicknames === p2.nicknames); // false p1.name = p1.nicknames[0]; p2.name = p2.nicknames[1]; p1.sayName(); // Jake p2.sayName(); // J-Dog
**

**3. 静态类方法 
**

**静态类成员在类定义中使用 static 关键字作为前缀。在静态成 员中， this 引用类自身。其他所有约定跟原型成员一样： class Person { constructor() { // 添加到this的所有内容都会存在于不同的实例上 this.locate = () => console.log('instance' , this); } // 定义在类的原型对象上 locate() { console.log('prototype' , this); } // 定义在类本身上 static locate() { console.log('class' , this); } } let p = new Person(); p.locate(); // instance, Person {} Person.prototype.locate(); // prototype, {constructor: ... } Person.locate(); // class, class Person {} 
**

**8.4.4 继承
**

**1. 继承基础 使用 extends 关键字，就可以继承任何拥 有 [[Construct]] 和原型的对象。很大程度上，这意味着不 仅可以继承一个类，也可以继承普通的构造函数**

**2. 构造函数、 HomeObject 和 super() 派生类的方法可以通过 super 关键字引用它们的原型。这个关 键字只能在派生类中使用，而且仅限于类构造函数、实例方法和 静态方法内部。在类构造函数中使用 super 可以调用父类构造 函数。
**

**3. 抽象基类 有时候可能需要定义这样一个类，它可供其他类继承，但本身不 会被实例化。 ，但通 过 new.target 也很容易实现。 new.target 保存通过 new 关键字调用的类或函数。通过在实例化时检测 new.target 是 不是抽象基类，可以阻止对抽象基类的实例化
**

**8.5 小结 
**

**工厂模式就是一个简单的函数，这个函数可以创建对象，为它添 加属性和方法，然后返回这个对象。这个模式在构造函数模式出 现后就很少用了。 使用构造函数模式可以自定义引用类型，可以使用 new 关键字 像创建内置类型实例一样创建自定义类型的实例。不过，构造函 数模式也有不足，主要是其成员无法重用，包括函数。考虑到函 数本身是松散的、弱类型的，没有理由让函数不能在多个对象实 例间共享。 原型模式解决了成员共享的问题，只要是添加到构造函数 prototype 上的属性和方法就可以共享。而组合构造函数和原 型模式通过构造函数定义实例属性，通过原型定义共享的属性和 方法。 
**

**原型式继承可以无须明确定义构造函数而实现继承，本质上是对 给定对象执行浅复制。这种操作的结果之后还可以再进一步增 强。 与原型式继承紧密相关的是寄生式继承，即先基于一个对象创建 一个新对象，然后再增强这个新对象，最后返回新对象。这个模 式也被用在组合继承中，用于避免重复调用父类构造函数导致的 浪费。 寄生组合继承被认为是实现基于类型继承的最有效方式。**第 8 章 对象、类与面向对象编程

 

8.1 理解对象 

创建自定义对象 是创建 Object 的一个新实例，然后 再给它添加属性和方法，

let person = new Object(); person.name = "Nicholas"; person.age = 29; person.job = "Software Engineer"; person.sayName = function() { console.log(this.name); };

8.1.1 属性的类型 

属性分两种：数据属性和访问器属性。

\1. 数据属性  数据属性包含一个保存数据值的位置。值会从这个位置读取，也 会写入到这个位置。数据属性有4个特性描述它们的行为。

[[Configurable]] ：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把 它改为访问器属性默认情况下，所有直接定义在对象上的 属性的这个特性都是 true

[[Enumberable]] ：表示属性是否可以通过 for-in 循 环返回。默认情况下，所有直接定义在对象上的属性的这个 特性都是 true ，

[[Writable]] ：表示属性的值是否可以被修改。默认情 况下，所有直接定义在对象上的属性的这个特性都是 true 

[[Value]] ：包含属性实际的值。这就是前面提到的那个 读取和写入属性值的位置。这个特性的默认值为 undefined 。 

在像前面例子中那样将属性显式添加到对象之后， [[Configurable]] 、 [[Enumerable]] 和 [[Writable]] 都会被设置为 true ，而 [[Value]] 特性会 被设置为指定的值

修改属性的默认特性，就必须使用 Object.defineProperty() 方法。

这个方法接收3个参数： 要给其添加属性的对象、属性的名称和一个描述符对象。最后一 个参数，即描述符对象上的属性可以包含： configurable 、 enumerable 、 writable 和 value ，跟相关特性的名称一 一对应。根据要修改的特性，可以设置其中一个或多个值。

let person = {}; Object.defineProperty(person, "name" , { configurable: false, value: "Nicholas" }); console.log(person.name); // "Nicholas" delete person.name; console.log(person.name); // "Nicholas"

**2. 访问器属性**  访问器属性不包含数据值

包含一个获取（getter）函 数和一个设置（setter）函数  **在读 取访问器属性时，会调用获取函数，这个函数的责任就是返回一 个有效的值。在写入访问器属性时，会调用设置函数并传入新 值，这个函数必须决定对数据做出什么修改。访问器属性有4个特 性描述它们的行为。** 

[[Configurable]] ：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把 它改为数据属性。默认情况下，所有直接定义在对象上的属 性的这个特性都是 true 。

[[Configurable]] ：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把 它改为数据属性。默认情况下，所有直接定义在对象上的属 性的这个特性都是 true 。

[[Get]] ：获取函数，在读取属性时调用。默认值为 undefined 。

[[Set]] ：设置函数，在写入属性时调用。默认值为 undefined 。

访问器属性是不能直接定义的，必须使用 Object.defineProperty() 

例子：

let book = { year_: 2017, edition: 1 }; Object.defineProperty(book, "year" , { get() { return this.year_; }, set(newValue) { if (newValue > 2017) { this.year_ = newValue; this.edition += newValue - 2017; } } }); book.year = 2018; console.log(book.edition); // 2

获取函数和设置函数不一定都要定义。只定义获取函数意味着属 性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入 只定义了获取函数的属性会抛出错误。 ，非严格模式下读取会返回 undefined ，严格模式下会抛出错误。  在不支持 Object.defineProperty() 的浏览器中没有办法 修改 [[Configurable]] 或 [[Enumerable]] 。 

**8.1.2 定义多个属性 在一个对象上同时定义多个属性了 Object.defineProperties() 方法。**

**通过多个描述符一次性定义多个属性 接收两个参数：要为 之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修 改的属性一一对应。
**

比如： let book = {}; Object.defineProperties(book, { year_: { value: 2017 }, edition: { value: 1 }, year: { get() { return this.year_; }, set(newValue) { if (newValue > 2017) { this.year_ = newValue; this.edition += newValue - 2017; } } } }); 

**8.1.3 读取属性的特性** 使用 Object.getOwnPropertyDescriptor() 方法可以取 得指定属性的属性描述符。

方法接收两个参数：属性所在的对象 和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包 含 configurable 、 enumerable 、 get 和 set 属性，对于数 据属性包含 configurable 、 enumberable 、 writable 和 value 属性。

比如： let book = {}; Object.defineProperties(book, { year_: { value: 2017 }, edition: { value: 1 }, year: { get: function() { return this.year_; }, set: function(newValue){ if (newValue > 2017) { this.year_ = newValue; this.edition += newValue - 2017; } } } }); let descriptor = Object.getOwnPropertyDescriptor(book, "year_"); console.log(descriptor.value); // 2017 console.log(descriptor.configurable); // false console.log(typeof descriptor.get); // "undefined" let descriptor = Object.getOwnPropertyDescriptor(book, "year"); console.log(descriptor.value); // undefined console.log(descriptor.enumerable); // false console.log(typeof descriptor.get); // "function" 

**8.1.4 合并对象 
**

JavaScript开发者经常觉得“合并”（merge）两个对象很有用。更具 体地说，就是把源对象所有的本地属性一起复制到目标对象上。有时 候这种操作也被称为“混入”（mixin），因为目标对象通过混入源对象 的属性得到了增强。 

ES6专门为合并对象提供了 Object.assign() 方 法。 然后 将每个源对象中可枚举（ Object.propertyIsEnumerable() 返 回 true ）和自有（ Object.hasOwnProperty() 返回 true ） 属性复制到目标对象

Object.assign() 实际上对每个源对象执行的是浅复制。如 果多个源对象都有相同的属性，则使用最后一个复制的值

8.1.5 对象标识及相等判定 **在ECMAScript 6之前，有些特殊情况即使是 === 操作符也无能 为力 为改善这类情况，ECMAScript 6规范新增了 Object.is() ，这 个方法与 === 很像，但同时也考虑到了上述边界情形。这个方法必 须接收两个参数：**

要检查超过两个值，递归地利用相等性传递即可：

**8.1.6 增强的对象语法 ECMAScript 6为定义和操作对象新增了很多极其有用的语法糖特 性。这些特性都没有改变现有引擎的行为，但极大地提升了处理对象 的方便程度。
**

 **1. 属性值简写 在给对象添加变量的时候，开发者经常会发现属性名和变量名是 一样的。

**

\2. 可计算属性 在引入可计算属性之前，如果想使用变量的值作为属性，那么必 须先声明对象，然后使用中括号语法来添加属性。

\3. 简写方法名 在给对象定义方法时，通常都要写一个方法名、冒号，然后再引 用一个匿名函数表达式，

**8.1.7 对象解构 ECMAScript 6新增了对象解构语法，可以在一条语句中使用嵌套 数据实现一个或多个赋值操作。对象解构就是使用与对象 匹配的结构来实现对象属性赋值。
**

**1. 嵌套解构  解构对于引用嵌套的属性或赋值目标没有限制。为此，可以通过 解构来复制对象属性  解构赋值可以使用嵌套结构，以匹配嵌套的属性：
**

**2. 部分解构  。如果一个解构表达式涉及多个赋值，开始的赋值成功而 后面的赋值出错，则整个解构赋值只会完成一部分
**

**3. 参数上下文匹配 在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会 影响 arguments 对象，但可以在函数签名中声明在函数体内使 用局部变量：
**

**8.2 创建对象 
**

**创建具有同样接口的多个对象需要重复编 写很多代码。 
**

**ES6开始正式支持类和继承 ES6的类旨在完全涵盖之 前规范设计的基于原型的继承模式。**

**8.2.2 工厂模式  工厂模式是一种众所周知的设计模式，广泛应用于软件工程领 域，用于抽象创建特定对象的过程。
**

 **8.2.3 构造函数模式   ECMAScript中的构造函数是用于创建特定类型 对象的。像 Object 和 Array 这样的原生构造函数，运行时可以直 接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为 自己的对象类型定义属性和方法。**

**要创建 Person 的实例，应使用 new 操作符。
**

**(1) 在内存中创建一个新对象。 (2) 这个新对象内部的 [[Prototype]] 特性被赋值为构造函数 的 prototype 属性。 (3) 构造函数内部的 this 被赋值为这个新对象（即 this 指向 新对象）。 (4) 执行构造函数内部的代码（给新对象添加属性）。 (5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创 建的新对象。
**

**1. 构造函数也是函数 构造函数与普通函数唯一的区别就是调用方式不同。除此之外， 构造函数也是函数。 并没有把某个函数定义为构造函数的特殊语 法。任何函数只要使用 new 操作符调用就是构造函数，而不使 用 new 操作符调用的函数就是普通函数。
**

**2. 构造函数的问题 构造函数虽然有用，但也不是没有问题。构造函数的主要问题在 于，其定义的方法会在每个实例上都创建一遍。因此对前面的例 子而言， person1 和 person2 都有名为 sayName() 的方 法，但这两个方法不是同一个 Function 实例。
**

**8.2.4 原型模式
**

**每个函数都会创建一个 prototype 属性，这个属性是一个对 象，包含应该由特定引用类型的实例共享的属性和方法。
**

**使用原型对象的好 处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造 函数中直接赋给对象实例的值，可以直接赋值给它们的原型，
**

**1. 理解原型 
**

**无论何时，只要创建一个函数，就会按照特定的规则为这个函数 创建一个 prototype 属性（指向原型对象）。默认情况下，所 有原型对象自动获得一个名为 constructor 的属性，指回与之 关联的构造函数。
**

**在自定义构造函数时，原型对象默认只会获得 constructor 属 性，其他的所有方法都继承自 Object 。每次调用构造函数创建 一个新实例，这个实例的内部 [[Prototype]] 指针就会被赋 值为构造函数的原型对象
**

**[[Prototype]] 特性的标准方式，但Firefox、Safari和Chrome 会在每个对象上暴露 __proto__ 属性，通过这个属性可以访问 对象的原型。
**

**2. 原型层级 
**

**在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索 开始于对象实例本身。如果在这个实例上发现了给定的名称，则 返回该名称对应的值。
**

**在调用 person1.sayName() 时，会发生两步搜 索。首先，JavaScript引擎会问：“ person1 实例有 sayName 属性吗？”答案是没有。然后，继续搜索并问：“ person1 的原 型有 sayName 属性吗？”答案是有。于是就返回了保存在原型上 的这个函数。在调用 person2.sayName() 时，会发生同样的 搜索过程，而且也会返回相同的结果。这就是原型用于在多个对 象实例间共享属性和方法的原理。 因此，在调用 person1.sayName() 时，会发生两步搜 索。首先，JavaScript引擎会问：“ person1 实例有 sayName 属性吗？”答案是没有。然后，继续搜索并问：“ person1 的原 型有 sayName 属性吗？”答案是有。于是就返回了保存在原型上 的这个函数。在调用 person2.sayName() 时，会发生同样的 搜索过程，而且也会返回相同的结果。这就是原型用于在多个对 象实例间共享属性和方法的原理。 
**

**3. 原型和 in 操作符 有两种方式使用 in 操作符：单独使用和在 for-in 循环中使 用。在单独使用时， in 操作符会在可以通过对象访问指定属性 时返回 true ，无论该属性是在实例上还是在原型上。 只要通过对象可以访问， in 操作符就返回 true ，而 hasOwnProperty() 只有属性存在于实例上时才返回 true 。因此，只要 in 操作符返回 true 且 hasOwnProperty() 返回 false ，就说明该属性是一个原型 属性。
**

**4. 属性枚举顺序 
**

**for-in 循环、 Object.keys() 、 Object.getOwnPropertyNames() 、 Object.getOwnPropertySymbols() 以及 Object.assign() 在属性枚举顺序方面有很大区别。 forin 循环和 Object.keys() 的枚举顺序是不确定的，取决于 JavaScript引擎，可能因浏览器而异。 Object.getOwnPropertyNames() 、 Object.getOwnPropertySymbols() 和 Object.assign() 的枚举顺序是确定性的。先以升序枚举数 值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定 义的键以它们逗号分隔的顺序插入。
**

**8.2.5 对象迭代
**

**在JavaScript有史以来的大部分时间内，迭代对象属性都是一个难 题。 用于将对象内容转换为序 列化的——更重要的是可迭代的——格式。这两个静态方法 Object.values() 和 Object.entries() 接收一个对象，返回 它们内容的数组。 Object.values() 返回对象值的数组， Object.entries() 返回键/值对的数组。
**

**1. 其他原型语法
**

每次定义一个属性或方 法都会把 Person.prototype 重写一遍。为了减少代码冗余， 也为了从视觉上更好地封装原型功能

function Person() {} Person.prototype = { name: "Nicholas" , age: 29, job: "Software Engineer" , sayName() { console.log(this.name); } }; 

**2. 原型的动态性 因为从原型上搜索值的过程是动态的，所以即使实例在修改原型 之前已经存在，任何时候对原型对象所做的修改也会在实例上反 映出来。**

**例子： let friend = new Person(); Person.prototype.sayHi = function() { console.log("hi"); }; friend.sayHi(); // "hi"，没问题！ 以上代码先创建一个 Person 实例
**

**3. 原生对象原型 
**

 **原型模式之所以重要，不仅体现在自定义类型上，而且还因为它 也是实现所有原生引用类型的模式。所有原生引用类型的构造函 数（包括 Object 、 Array 、 String 等）都在原型上定义 了实例方法。**

**4. 原型的问题  原型模式也不是没有问题。首先，它弱化了向构造函数传递初始 化参数的能力，会导致所有实例默认都取得相同的属性值。虽
**

**这会带来不便，但还不是原型的最大问题。原型的最主要问题源 自它的共享特性。 原型上的所有属性是在实例间共享的，这对函数来说 比较合适。另外包含原始值的属性也还好，
**

**例子： function Person() {} Person.prototype = { constructor: Person, name: "Nicholas" , age: 29, job: "Software Engineer" , friends: ["Shelby" , "Court"], sayName() { console.log(this.name); } }; let person1 = new Person(); let person2 = new Person(); person1.friends.push("Van"); console.log(person1.friends); // "Shelby,Court,Van" console.log(person2.friends); // "Shelby,Court,Van" console.log(person1.friends === person2.friends); // true 
**

**8.3 继承 
**

**继承是面向对象编程中讨论最多的话题。很多面向对象语言都支 持两种继承：接口继承和实现继承
**

**8.3.1 原型链 原型链定义为ECMAScript的主要继承方式
**

**其基本 思想就是通过原型继承多个引用类型的属性和方法。重温一下构造函 数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一 个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是 另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向 另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。
**

**实现原型链涉及如下代码模式： function SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function() { return this.property; }; function SubType() { this.subproperty = false; } // 继承SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function () { return this.subproperty; }; let instance = new SubType(); console.log(instance.getSuperValue()); // true
**

**SubType 通过创建 SuperType 的实例并将其赋值给自己的原型 SubTtype.prototype 实现了对 SuperType 的继承。这个赋值 重写了 SubType 最初的原型，将其替换为 SuperType 的实例。这 意味着 SuperType 实例可以访问的所有属性和方法也会存在于 SubType.prototype 。这样实现继承之后，代码紧接着又给 SubType.prototype ，也就是这个 SuperType 的实例添加了一 个新方法。最后又创建了 SubType 的实例并调用了它继承的 getSuperValue() 方法。
**

**1. 默认原型 
**

**原型链中还有一环。默认情况下，所有引用类型都继承 自 Object ，这也是通过原型链实现的。任何函数的默认原型都 是一个 Object 的实例，这意味着这个实例有一个内部指针指 向 Object.prototype 。
**

**2. 原型与继承关系
**

**原型与实例的关系可以通过两种方式来确定。第一种方式是使用 instanceof 操作符，如果一个实例的原型链中出现过相应的 构造函数，则 instanceof 返回 true
**

**3. 关于方法 
**

**子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为 此，这些方法必须在原型赋值之后再添加到原型上。
**

**4. 原型链的问题
**

**问题出 现在原型中包含引用值的时候。前面在谈到原型的问题时也提到 过，原型中包含的引用值会在所有实例间共享，这也是为什么属 性通常会在构造函数中定义而不会定义在原型上的原因。在使用 原型实现继承时，原型实际上变成了另一个类型的实例。这意味 着原先的实例属性摇身一变成为了原型属性。
**

**例子  function SuperType() { this.colors = ["red" , "blue" , "green"]; } function SubType() {} // 继承SuperType SubType.prototype = new SuperType(); let instance1 = new SubType(); instance1.colors.push("black"); console.log(instance1.colors); // "red,blue,green,black" let instance2 = new SubType(); console.log(instance2.colors); // "red,blue,green,black" 
**

**8.3.2 盗用构造函数
**

**为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函 数”（constructor stealing）的技术在开发社区流行起来（这种技术有时 也称作“对象伪装”或“经典继承”）。 在子类构造函 数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码 的简单对象，所以可以使用 apply() 和 call() 方法以新创建的对 象为上下文执行构造函数。
**

**1. 传递参数 相比于使用原型链，盗用构造函数的一个优点就是可以在子类构 造函数中向父类构造函数传参。
**

**2. 盗用构造函数的问题 盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的 问题：必须在构造函数中定义方法，因此函数不能重用。
**

**8.3.3 组合继承 
**

 **组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函 数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上 的属性和方法，而通过盗用构造函数继承实例属性。**

**例子： function SuperType(name){ this.name = name; this.colors = ["red" , "blue" , "green"]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age){ // 继承属性 SuperType.call(this, name); this.age = age; } // 继承方法 SubType.prototype = new SuperType(); SubType.prototype.sayAge = function() { console.log(this.age); }; let instance1 = new SubType("Nicholas" , 29); instance1.colors.push("black"); console.log(instance1.colors); // "red,blue,green,black" instance1.sayName(); // "Nicholas"; instance1.sayAge(); // 29 let instance2 = new SubType("Greg" , 27); console.log(instance2.colors); // "red,blue,green" instance2.sayName(); // "Greg"; instance2.sayAge(); // 27** 

**8.3.4 原型式继承
**

**function object(o) { function F() {} F.prototype = o; return new F(); } 
**

**object() 函数会创建一个临时构造函数，将传入的对象 赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。
**

**你有一个对象，想 在它的基础上再创建一个新对象。你需要把这个对象先传给 object() ，然后再对返回的对象进行适当修改。在这个例子中， person 对象定义了另一个对象也应该共享的信息，把它传给 object() 之后会返回一个新对象。这个新对象的原型是 person ，意味着它的原型上既有原始值属性又有引用值属性。这也 意味着 person.friends 不仅是 person 的属性，也会跟 anotherPerson 和 yetAnotherPerson 共享。这里实际上克隆 了两个 person 。 
**

**8.3.5 寄生式继承 
**

**与原型式继承比较接近的一种继承方式是寄生式继承（parasitic inheritance），也是Crockford首倡的一种模式。寄生式继承背后的思 路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某 种方式增强对象，然后返回这个对象
**

**function createAnother(original){ let clone = object(original); // 通过调用函数创 建一个新对象 clone.sayHi = function() { // 以某种方式增强 这个对象 console.log("hi"); }; return clone; // 返回这个对象 } 
**

**8.3.6 寄生式组合继承
**

**组合继承其实也存在效率问题。最主要的效率问题就是父类构造 函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在 子类构造函数中调用
**

**本质上，子类原型最终是要包含超类对象的所 有实例属性，子类构造函数只要在执行时重写自己的原型就行了
**

**例子： function SuperType(name) { this.name = name; this.colors = ["red" , "blue" , "green"]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age){ SuperType.call(this, name); // 第二次调用 SuperType() this.age = age; } SubType.prototype = new SuperType(); // 第一次调 用SuperType() SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function() { console.log(this.age); }; 
**

**8.4 类
**

**类（class）是ECMAScript中新的基础性语法糖结 构，因此刚开始接触时可能会不太习惯。虽然ECMAScript 6类表面上 看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是 原型和构造函数的概念。 
**

**8.4.1 类定义
**

  **与函数类型相似，定义类也有两种主要方式：类声明和类表达 式。这两种方式都使用 class 关键字加大括号：**

**// 类声明 class Person {} // 类表达式 const Animal = class {}; 
**

**类的构成 类可以包含构造函数方法、实例方法、获取函数、设置函数和静 态类方法，但这些都不是必需的。空的类定义照样有效。默认情况 下，类定义中的代码都在严格模式下执行
**

**与函数构造函数一样，多数编程风格都建议类名的首字母要大 写，以区别于通过它创建的实例（比如，通过 class Foo {} 创建 实例 foo ）： // 空类定义，有效 class Foo {} // 有构造函数的类，有效 class Bar { constructor() {} } // 有获取函数的类，有效 class Baz { get myBaz() {} } // 有静态方法的类，有效 class Qux { static myQux() {} } 类表
**

**8.4.2 类构造函数
**

**constructor 关键字用于在类定义块内部创建类的构造函数。 方法名 constructor 会告诉解释器在使用 new 操作符创建类的新 实例时，应该调用这个函数。构造函数的定义不是必需的，不定义构 造函数相当于将构造函数定义为空函数
**

**1. 实例化 使用 new 操作符实例化 Person 的操作等于使用 new 调用其 构造函数。唯一可感知的不同之处就是，JavaScript解释器知道使 用 new 和类意味着应该使用 constructor 函数进行实例化。
**

**使用new调用类的构造函数会执行如下操作。 (1) 在内存中创建一个新对象。 (2) 这个新对象内部的 [[Prototype]] 指针被赋值为构造函数 的 prototype 属性。 (3) 构造函数内部的 this 被赋值为这个新对象（即 this 指向 新对象）。 (4) 执行构造函数内部的代码（给新对象添加属性）。 (5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创 建的新对象。 来看下面的例子： class Animal {} class Person { constructor() { console.log('person ctor'); } } class Vegetable { constructor() { this.color = 'orange'; } } let a = new Animal(); let p = new Person(); // person ctor let v = new Vegetable(); console.log(v.color); // orange 类实例化时传入的参数会用作构造函数的
**

**2. 把类当成特殊函数 ECMAScript中没有正式的类这个类型。从各方面来看， ECMAScript类就是一种特殊函数。声明一个类之后，通过 typeof 操作符检测类标识符，表明它是一个函数： class Person {} console.log(Person); // class Person {} console.log(typeof Person); // function
**

**8.4.3 实例、原型和类成员
**

**1. 实例成员 每次通过 new 调用类标识符时，都会执行类构造函数。在这个 函数内部，可以为新创建的实例（ this ）添加“自有”属性。
**

**每个实例都对应一个唯一的成员对象，这意味着所有成员都不会 在原型上共享： 
**

**class Person { constructor() { // 这个例子先使用对象包装类型定义一个字符串 // 为的是在下面测试两个对象的相等性 this.name = new String('Jack'); this.sayName = () => console.log(this.name); this.nicknames = ['Jake' , 'J-Dog'] } } let p1 = new Person(), p2 = new Person(); p1.sayName(); // Jack p2.sayName(); // Jack console.log(p1.name === p2.name); // false console.log(p1.sayName === p2.sayName); // false console.log(p1.nicknames === p2.nicknames); // false p1.name = p1.nicknames[0]; p2.name = p2.nicknames[1]; p1.sayName(); // Jake p2.sayName(); // J-Dog
**

**3. 静态类方法 
**

**静态类成员在类定义中使用 static 关键字作为前缀。在静态成 员中， this 引用类自身。其他所有约定跟原型成员一样： class Person { constructor() { // 添加到this的所有内容都会存在于不同的实例上 this.locate = () => console.log('instance' , this); } // 定义在类的原型对象上 locate() { console.log('prototype' , this); } // 定义在类本身上 static locate() { console.log('class' , this); } } let p = new Person(); p.locate(); // instance, Person {} Person.prototype.locate(); // prototype, {constructor: ... } Person.locate(); // class, class Person {} 
**

**8.4.4 继承
**

**1. 继承基础 使用 extends 关键字，就可以继承任何拥 有 [[Construct]] 和原型的对象。很大程度上，这意味着不 仅可以继承一个类，也可以继承普通的构造函数**

**2. 构造函数、 HomeObject 和 super() 派生类的方法可以通过 super 关键字引用它们的原型。这个关 键字只能在派生类中使用，而且仅限于类构造函数、实例方法和 静态方法内部。在类构造函数中使用 super 可以调用父类构造 函数。
**

**3. 抽象基类 有时候可能需要定义这样一个类，它可供其他类继承，但本身不 会被实例化。 ，但通 过 new.target 也很容易实现。 new.target 保存通过 new 关键字调用的类或函数。通过在实例化时检测 new.target 是 不是抽象基类，可以阻止对抽象基类的实例化
**

**8.5 小结 
**

**工厂模式就是一个简单的函数，这个函数可以创建对象，为它添 加属性和方法，然后返回这个对象。这个模式在构造函数模式出 现后就很少用了。 使用构造函数模式可以自定义引用类型，可以使用 new 关键字 像创建内置类型实例一样创建自定义类型的实例。不过，构造函 数模式也有不足，主要是其成员无法重用，包括函数。考虑到函 数本身是松散的、弱类型的，没有理由让函数不能在多个对象实 例间共享。 原型模式解决了成员共享的问题，只要是添加到构造函数 prototype 上的属性和方法就可以共享。而组合构造函数和原 型模式通过构造函数定义实例属性，通过原型定义共享的属性和 方法。 
**

**原型式继承可以无须明确定义构造函数而实现继承，本质上是对 给定对象执行浅复制。这种操作的结果之后还可以再进一步增 强。 与原型式继承紧密相关的是寄生式继承，即先基于一个对象创建 一个新对象，然后再增强这个新对象，最后返回新对象。这个模 式也被用在组合继承中，用于避免重复调用父类构造函数导致的 浪费。 寄生组合继承被认为是实现基于类型继承的最有效方式。**第 8 章 对象、类与面向对象编程

 

8.1 理解对象 

创建自定义对象 是创建 Object 的一个新实例，然后 再给它添加属性和方法，

let person = new Object(); person.name = "Nicholas"; person.age = 29; person.job = "Software Engineer"; person.sayName = function() { console.log(this.name); };

8.1.1 属性的类型 

属性分两种：数据属性和访问器属性。

\1. 数据属性  数据属性包含一个保存数据值的位置。值会从这个位置读取，也 会写入到这个位置。数据属性有4个特性描述它们的行为。

[[Configurable]] ：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把 它改为访问器属性默认情况下，所有直接定义在对象上的 属性的这个特性都是 true

[[Enumberable]] ：表示属性是否可以通过 for-in 循 环返回。默认情况下，所有直接定义在对象上的属性的这个 特性都是 true ，

[[Writable]] ：表示属性的值是否可以被修改。默认情 况下，所有直接定义在对象上的属性的这个特性都是 true 

[[Value]] ：包含属性实际的值。这就是前面提到的那个 读取和写入属性值的位置。这个特性的默认值为 undefined 。 

在像前面例子中那样将属性显式添加到对象之后， [[Configurable]] 、 [[Enumerable]] 和 [[Writable]] 都会被设置为 true ，而 [[Value]] 特性会 被设置为指定的值

修改属性的默认特性，就必须使用 Object.defineProperty() 方法。

这个方法接收3个参数： 要给其添加属性的对象、属性的名称和一个描述符对象。最后一 个参数，即描述符对象上的属性可以包含： configurable 、 enumerable 、 writable 和 value ，跟相关特性的名称一 一对应。根据要修改的特性，可以设置其中一个或多个值。

let person = {}; Object.defineProperty(person, "name" , { configurable: false, value: "Nicholas" }); console.log(person.name); // "Nicholas" delete person.name; console.log(person.name); // "Nicholas"

**2. 访问器属性**  访问器属性不包含数据值

包含一个获取（getter）函 数和一个设置（setter）函数  **在读 取访问器属性时，会调用获取函数，这个函数的责任就是返回一 个有效的值。在写入访问器属性时，会调用设置函数并传入新 值，这个函数必须决定对数据做出什么修改。访问器属性有4个特 性描述它们的行为。** 

[[Configurable]] ：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把 它改为数据属性。默认情况下，所有直接定义在对象上的属 性的这个特性都是 true 。

[[Configurable]] ：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把 它改为数据属性。默认情况下，所有直接定义在对象上的属 性的这个特性都是 true 。

[[Get]] ：获取函数，在读取属性时调用。默认值为 undefined 。

[[Set]] ：设置函数，在写入属性时调用。默认值为 undefined 。

访问器属性是不能直接定义的，必须使用 Object.defineProperty() 

例子：

let book = { year_: 2017, edition: 1 }; Object.defineProperty(book, "year" , { get() { return this.year_; }, set(newValue) { if (newValue > 2017) { this.year_ = newValue; this.edition += newValue - 2017; } } }); book.year = 2018; console.log(book.edition); // 2

获取函数和设置函数不一定都要定义。只定义获取函数意味着属 性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入 只定义了获取函数的属性会抛出错误。 ，非严格模式下读取会返回 undefined ，严格模式下会抛出错误。  在不支持 Object.defineProperty() 的浏览器中没有办法 修改 [[Configurable]] 或 [[Enumerable]] 。 

**8.1.2 定义多个属性 在一个对象上同时定义多个属性了 Object.defineProperties() 方法。**

**通过多个描述符一次性定义多个属性 接收两个参数：要为 之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修 改的属性一一对应。
**

比如： let book = {}; Object.defineProperties(book, { year_: { value: 2017 }, edition: { value: 1 }, year: { get() { return this.year_; }, set(newValue) { if (newValue > 2017) { this.year_ = newValue; this.edition += newValue - 2017; } } } }); 

**8.1.3 读取属性的特性** 使用 Object.getOwnPropertyDescriptor() 方法可以取 得指定属性的属性描述符。

方法接收两个参数：属性所在的对象 和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包 含 configurable 、 enumerable 、 get 和 set 属性，对于数 据属性包含 configurable 、 enumberable 、 writable 和 value 属性。

比如： let book = {}; Object.defineProperties(book, { year_: { value: 2017 }, edition: { value: 1 }, year: { get: function() { return this.year_; }, set: function(newValue){ if (newValue > 2017) { this.year_ = newValue; this.edition += newValue - 2017; } } } }); let descriptor = Object.getOwnPropertyDescriptor(book, "year_"); console.log(descriptor.value); // 2017 console.log(descriptor.configurable); // false console.log(typeof descriptor.get); // "undefined" let descriptor = Object.getOwnPropertyDescriptor(book, "year"); console.log(descriptor.value); // undefined console.log(descriptor.enumerable); // false console.log(typeof descriptor.get); // "function" 

**8.1.4 合并对象 
**

JavaScript开发者经常觉得“合并”（merge）两个对象很有用。更具 体地说，就是把源对象所有的本地属性一起复制到目标对象上。有时 候这种操作也被称为“混入”（mixin），因为目标对象通过混入源对象 的属性得到了增强。 

ES6专门为合并对象提供了 Object.assign() 方 法。 然后 将每个源对象中可枚举（ Object.propertyIsEnumerable() 返 回 true ）和自有（ Object.hasOwnProperty() 返回 true ） 属性复制到目标对象

Object.assign() 实际上对每个源对象执行的是浅复制。如 果多个源对象都有相同的属性，则使用最后一个复制的值

8.1.5 对象标识及相等判定 **在ECMAScript 6之前，有些特殊情况即使是 === 操作符也无能 为力 为改善这类情况，ECMAScript 6规范新增了 Object.is() ，这 个方法与 === 很像，但同时也考虑到了上述边界情形。这个方法必 须接收两个参数：**

要检查超过两个值，递归地利用相等性传递即可：

**8.1.6 增强的对象语法 ECMAScript 6为定义和操作对象新增了很多极其有用的语法糖特 性。这些特性都没有改变现有引擎的行为，但极大地提升了处理对象 的方便程度。
**

 **1. 属性值简写 在给对象添加变量的时候，开发者经常会发现属性名和变量名是 一样的。

**

\2. 可计算属性 在引入可计算属性之前，如果想使用变量的值作为属性，那么必 须先声明对象，然后使用中括号语法来添加属性。

\3. 简写方法名 在给对象定义方法时，通常都要写一个方法名、冒号，然后再引 用一个匿名函数表达式，

**8.1.7 对象解构 ECMAScript 6新增了对象解构语法，可以在一条语句中使用嵌套 数据实现一个或多个赋值操作。对象解构就是使用与对象 匹配的结构来实现对象属性赋值。
**

**1. 嵌套解构  解构对于引用嵌套的属性或赋值目标没有限制。为此，可以通过 解构来复制对象属性  解构赋值可以使用嵌套结构，以匹配嵌套的属性：
**

**2. 部分解构  。如果一个解构表达式涉及多个赋值，开始的赋值成功而 后面的赋值出错，则整个解构赋值只会完成一部分
**

**3. 参数上下文匹配 在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会 影响 arguments 对象，但可以在函数签名中声明在函数体内使 用局部变量：
**

**8.2 创建对象 
**

**创建具有同样接口的多个对象需要重复编 写很多代码。 
**

**ES6开始正式支持类和继承 ES6的类旨在完全涵盖之 前规范设计的基于原型的继承模式。**

**8.2.2 工厂模式  工厂模式是一种众所周知的设计模式，广泛应用于软件工程领 域，用于抽象创建特定对象的过程。
**

 **8.2.3 构造函数模式   ECMAScript中的构造函数是用于创建特定类型 对象的。像 Object 和 Array 这样的原生构造函数，运行时可以直 接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为 自己的对象类型定义属性和方法。**

**要创建 Person 的实例，应使用 new 操作符。
**

**(1) 在内存中创建一个新对象。 (2) 这个新对象内部的 [[Prototype]] 特性被赋值为构造函数 的 prototype 属性。 (3) 构造函数内部的 this 被赋值为这个新对象（即 this 指向 新对象）。 (4) 执行构造函数内部的代码（给新对象添加属性）。 (5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创 建的新对象。
**

**1. 构造函数也是函数 构造函数与普通函数唯一的区别就是调用方式不同。除此之外， 构造函数也是函数。 并没有把某个函数定义为构造函数的特殊语 法。任何函数只要使用 new 操作符调用就是构造函数，而不使 用 new 操作符调用的函数就是普通函数。
**

**2. 构造函数的问题 构造函数虽然有用，但也不是没有问题。构造函数的主要问题在 于，其定义的方法会在每个实例上都创建一遍。因此对前面的例 子而言， person1 和 person2 都有名为 sayName() 的方 法，但这两个方法不是同一个 Function 实例。
**

**8.2.4 原型模式
**

**每个函数都会创建一个 prototype 属性，这个属性是一个对 象，包含应该由特定引用类型的实例共享的属性和方法。
**

**使用原型对象的好 处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造 函数中直接赋给对象实例的值，可以直接赋值给它们的原型，
**

**1. 理解原型 
**

**无论何时，只要创建一个函数，就会按照特定的规则为这个函数 创建一个 prototype 属性（指向原型对象）。默认情况下，所 有原型对象自动获得一个名为 constructor 的属性，指回与之 关联的构造函数。
**

**在自定义构造函数时，原型对象默认只会获得 constructor 属 性，其他的所有方法都继承自 Object 。每次调用构造函数创建 一个新实例，这个实例的内部 [[Prototype]] 指针就会被赋 值为构造函数的原型对象
**

**[[Prototype]] 特性的标准方式，但Firefox、Safari和Chrome 会在每个对象上暴露 __proto__ 属性，通过这个属性可以访问 对象的原型。
**

**2. 原型层级 
**

**在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索 开始于对象实例本身。如果在这个实例上发现了给定的名称，则 返回该名称对应的值。
**

**在调用 person1.sayName() 时，会发生两步搜 索。首先，JavaScript引擎会问：“ person1 实例有 sayName 属性吗？”答案是没有。然后，继续搜索并问：“ person1 的原 型有 sayName 属性吗？”答案是有。于是就返回了保存在原型上 的这个函数。在调用 person2.sayName() 时，会发生同样的 搜索过程，而且也会返回相同的结果。这就是原型用于在多个对 象实例间共享属性和方法的原理。 因此，在调用 person1.sayName() 时，会发生两步搜 索。首先，JavaScript引擎会问：“ person1 实例有 sayName 属性吗？”答案是没有。然后，继续搜索并问：“ person1 的原 型有 sayName 属性吗？”答案是有。于是就返回了保存在原型上 的这个函数。在调用 person2.sayName() 时，会发生同样的 搜索过程，而且也会返回相同的结果。这就是原型用于在多个对 象实例间共享属性和方法的原理。 
**

**3. 原型和 in 操作符 有两种方式使用 in 操作符：单独使用和在 for-in 循环中使 用。在单独使用时， in 操作符会在可以通过对象访问指定属性 时返回 true ，无论该属性是在实例上还是在原型上。 只要通过对象可以访问， in 操作符就返回 true ，而 hasOwnProperty() 只有属性存在于实例上时才返回 true 。因此，只要 in 操作符返回 true 且 hasOwnProperty() 返回 false ，就说明该属性是一个原型 属性。
**

**4. 属性枚举顺序 
**

**for-in 循环、 Object.keys() 、 Object.getOwnPropertyNames() 、 Object.getOwnPropertySymbols() 以及 Object.assign() 在属性枚举顺序方面有很大区别。 forin 循环和 Object.keys() 的枚举顺序是不确定的，取决于 JavaScript引擎，可能因浏览器而异。 Object.getOwnPropertyNames() 、 Object.getOwnPropertySymbols() 和 Object.assign() 的枚举顺序是确定性的。先以升序枚举数 值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定 义的键以它们逗号分隔的顺序插入。
**

**8.2.5 对象迭代
**

**在JavaScript有史以来的大部分时间内，迭代对象属性都是一个难 题。 用于将对象内容转换为序 列化的——更重要的是可迭代的——格式。这两个静态方法 Object.values() 和 Object.entries() 接收一个对象，返回 它们内容的数组。 Object.values() 返回对象值的数组， Object.entries() 返回键/值对的数组。
**

**1. 其他原型语法
**

每次定义一个属性或方 法都会把 Person.prototype 重写一遍。为了减少代码冗余， 也为了从视觉上更好地封装原型功能

function Person() {} Person.prototype = { name: "Nicholas" , age: 29, job: "Software Engineer" , sayName() { console.log(this.name); } }; 

**2. 原型的动态性 因为从原型上搜索值的过程是动态的，所以即使实例在修改原型 之前已经存在，任何时候对原型对象所做的修改也会在实例上反 映出来。**

**例子： let friend = new Person(); Person.prototype.sayHi = function() { console.log("hi"); }; friend.sayHi(); // "hi"，没问题！ 以上代码先创建一个 Person 实例
**

**3. 原生对象原型 
**

 **原型模式之所以重要，不仅体现在自定义类型上，而且还因为它 也是实现所有原生引用类型的模式。所有原生引用类型的构造函 数（包括 Object 、 Array 、 String 等）都在原型上定义 了实例方法。**

**4. 原型的问题  原型模式也不是没有问题。首先，它弱化了向构造函数传递初始 化参数的能力，会导致所有实例默认都取得相同的属性值。虽
**

**这会带来不便，但还不是原型的最大问题。原型的最主要问题源 自它的共享特性。 原型上的所有属性是在实例间共享的，这对函数来说 比较合适。另外包含原始值的属性也还好，
**

**例子： function Person() {} Person.prototype = { constructor: Person, name: "Nicholas" , age: 29, job: "Software Engineer" , friends: ["Shelby" , "Court"], sayName() { console.log(this.name); } }; let person1 = new Person(); let person2 = new Person(); person1.friends.push("Van"); console.log(person1.friends); // "Shelby,Court,Van" console.log(person2.friends); // "Shelby,Court,Van" console.log(person1.friends === person2.friends); // true 
**

**8.3 继承 
**

**继承是面向对象编程中讨论最多的话题。很多面向对象语言都支 持两种继承：接口继承和实现继承
**

**8.3.1 原型链 原型链定义为ECMAScript的主要继承方式
**

**其基本 思想就是通过原型继承多个引用类型的属性和方法。重温一下构造函 数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一 个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是 另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向 另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。
**

**实现原型链涉及如下代码模式： function SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function() { return this.property; }; function SubType() { this.subproperty = false; } // 继承SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function () { return this.subproperty; }; let instance = new SubType(); console.log(instance.getSuperValue()); // true
**

**SubType 通过创建 SuperType 的实例并将其赋值给自己的原型 SubTtype.prototype 实现了对 SuperType 的继承。这个赋值 重写了 SubType 最初的原型，将其替换为 SuperType 的实例。这 意味着 SuperType 实例可以访问的所有属性和方法也会存在于 SubType.prototype 。这样实现继承之后，代码紧接着又给 SubType.prototype ，也就是这个 SuperType 的实例添加了一 个新方法。最后又创建了 SubType 的实例并调用了它继承的 getSuperValue() 方法。
**

**1. 默认原型 
**

**原型链中还有一环。默认情况下，所有引用类型都继承 自 Object ，这也是通过原型链实现的。任何函数的默认原型都 是一个 Object 的实例，这意味着这个实例有一个内部指针指 向 Object.prototype 。
**

**2. 原型与继承关系
**

**原型与实例的关系可以通过两种方式来确定。第一种方式是使用 instanceof 操作符，如果一个实例的原型链中出现过相应的 构造函数，则 instanceof 返回 true
**

**3. 关于方法 
**

**子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为 此，这些方法必须在原型赋值之后再添加到原型上。
**

**4. 原型链的问题
**

**问题出 现在原型中包含引用值的时候。前面在谈到原型的问题时也提到 过，原型中包含的引用值会在所有实例间共享，这也是为什么属 性通常会在构造函数中定义而不会定义在原型上的原因。在使用 原型实现继承时，原型实际上变成了另一个类型的实例。这意味 着原先的实例属性摇身一变成为了原型属性。
**

**例子  function SuperType() { this.colors = ["red" , "blue" , "green"]; } function SubType() {} // 继承SuperType SubType.prototype = new SuperType(); let instance1 = new SubType(); instance1.colors.push("black"); console.log(instance1.colors); // "red,blue,green,black" let instance2 = new SubType(); console.log(instance2.colors); // "red,blue,green,black" 
**

**8.3.2 盗用构造函数
**

**为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函 数”（constructor stealing）的技术在开发社区流行起来（这种技术有时 也称作“对象伪装”或“经典继承”）。 在子类构造函 数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码 的简单对象，所以可以使用 apply() 和 call() 方法以新创建的对 象为上下文执行构造函数。
**

**1. 传递参数 相比于使用原型链，盗用构造函数的一个优点就是可以在子类构 造函数中向父类构造函数传参。
**

**2. 盗用构造函数的问题 盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的 问题：必须在构造函数中定义方法，因此函数不能重用。
**

**8.3.3 组合继承 
**

 **组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函 数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上 的属性和方法，而通过盗用构造函数继承实例属性。**

**例子： function SuperType(name){ this.name = name; this.colors = ["red" , "blue" , "green"]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age){ // 继承属性 SuperType.call(this, name); this.age = age; } // 继承方法 SubType.prototype = new SuperType(); SubType.prototype.sayAge = function() { console.log(this.age); }; let instance1 = new SubType("Nicholas" , 29); instance1.colors.push("black"); console.log(instance1.colors); // "red,blue,green,black" instance1.sayName(); // "Nicholas"; instance1.sayAge(); // 29 let instance2 = new SubType("Greg" , 27); console.log(instance2.colors); // "red,blue,green" instance2.sayName(); // "Greg"; instance2.sayAge(); // 27** 

**8.3.4 原型式继承
**

**function object(o) { function F() {} F.prototype = o; return new F(); } 
**

**object() 函数会创建一个临时构造函数，将传入的对象 赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。
**

**你有一个对象，想 在它的基础上再创建一个新对象。你需要把这个对象先传给 object() ，然后再对返回的对象进行适当修改。在这个例子中， person 对象定义了另一个对象也应该共享的信息，把它传给 object() 之后会返回一个新对象。这个新对象的原型是 person ，意味着它的原型上既有原始值属性又有引用值属性。这也 意味着 person.friends 不仅是 person 的属性，也会跟 anotherPerson 和 yetAnotherPerson 共享。这里实际上克隆 了两个 person 。 
**

**8.3.5 寄生式继承 
**

**与原型式继承比较接近的一种继承方式是寄生式继承（parasitic inheritance），也是Crockford首倡的一种模式。寄生式继承背后的思 路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某 种方式增强对象，然后返回这个对象
**

**function createAnother(original){ let clone = object(original); // 通过调用函数创 建一个新对象 clone.sayHi = function() { // 以某种方式增强 这个对象 console.log("hi"); }; return clone; // 返回这个对象 } 
**

**8.3.6 寄生式组合继承
**

**组合继承其实也存在效率问题。最主要的效率问题就是父类构造 函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在 子类构造函数中调用
**

**本质上，子类原型最终是要包含超类对象的所 有实例属性，子类构造函数只要在执行时重写自己的原型就行了
**

**例子： function SuperType(name) { this.name = name; this.colors = ["red" , "blue" , "green"]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age){ SuperType.call(this, name); // 第二次调用 SuperType() this.age = age; } SubType.prototype = new SuperType(); // 第一次调 用SuperType() SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function() { console.log(this.age); }; 
**

**8.4 类
**

**类（class）是ECMAScript中新的基础性语法糖结 构，因此刚开始接触时可能会不太习惯。虽然ECMAScript 6类表面上 看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是 原型和构造函数的概念。 
**

**8.4.1 类定义
**

  **与函数类型相似，定义类也有两种主要方式：类声明和类表达 式。这两种方式都使用 class 关键字加大括号：**

**// 类声明 class Person {} // 类表达式 const Animal = class {}; 
**

**类的构成 类可以包含构造函数方法、实例方法、获取函数、设置函数和静 态类方法，但这些都不是必需的。空的类定义照样有效。默认情况 下，类定义中的代码都在严格模式下执行
**

**与函数构造函数一样，多数编程风格都建议类名的首字母要大 写，以区别于通过它创建的实例（比如，通过 class Foo {} 创建 实例 foo ）： // 空类定义，有效 class Foo {} // 有构造函数的类，有效 class Bar { constructor() {} } // 有获取函数的类，有效 class Baz { get myBaz() {} } // 有静态方法的类，有效 class Qux { static myQux() {} } 类表
**

**8.4.2 类构造函数
**

**constructor 关键字用于在类定义块内部创建类的构造函数。 方法名 constructor 会告诉解释器在使用 new 操作符创建类的新 实例时，应该调用这个函数。构造函数的定义不是必需的，不定义构 造函数相当于将构造函数定义为空函数
**

**1. 实例化 使用 new 操作符实例化 Person 的操作等于使用 new 调用其 构造函数。唯一可感知的不同之处就是，JavaScript解释器知道使 用 new 和类意味着应该使用 constructor 函数进行实例化。
**

**使用new调用类的构造函数会执行如下操作。 (1) 在内存中创建一个新对象。 (2) 这个新对象内部的 [[Prototype]] 指针被赋值为构造函数 的 prototype 属性。 (3) 构造函数内部的 this 被赋值为这个新对象（即 this 指向 新对象）。 (4) 执行构造函数内部的代码（给新对象添加属性）。 (5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创 建的新对象。 来看下面的例子： class Animal {} class Person { constructor() { console.log('person ctor'); } } class Vegetable { constructor() { this.color = 'orange'; } } let a = new Animal(); let p = new Person(); // person ctor let v = new Vegetable(); console.log(v.color); // orange 类实例化时传入的参数会用作构造函数的
**

**2. 把类当成特殊函数 ECMAScript中没有正式的类这个类型。从各方面来看， ECMAScript类就是一种特殊函数。声明一个类之后，通过 typeof 操作符检测类标识符，表明它是一个函数： class Person {} console.log(Person); // class Person {} console.log(typeof Person); // function
**

**8.4.3 实例、原型和类成员
**

**1. 实例成员 每次通过 new 调用类标识符时，都会执行类构造函数。在这个 函数内部，可以为新创建的实例（ this ）添加“自有”属性。
**

**每个实例都对应一个唯一的成员对象，这意味着所有成员都不会 在原型上共享： 
**

**class Person { constructor() { // 这个例子先使用对象包装类型定义一个字符串 // 为的是在下面测试两个对象的相等性 this.name = new String('Jack'); this.sayName = () => console.log(this.name); this.nicknames = ['Jake' , 'J-Dog'] } } let p1 = new Person(), p2 = new Person(); p1.sayName(); // Jack p2.sayName(); // Jack console.log(p1.name === p2.name); // false console.log(p1.sayName === p2.sayName); // false console.log(p1.nicknames === p2.nicknames); // false p1.name = p1.nicknames[0]; p2.name = p2.nicknames[1]; p1.sayName(); // Jake p2.sayName(); // J-Dog
**

**3. 静态类方法 
**

**静态类成员在类定义中使用 static 关键字作为前缀。在静态成 员中， this 引用类自身。其他所有约定跟原型成员一样： class Person { constructor() { // 添加到this的所有内容都会存在于不同的实例上 this.locate = () => console.log('instance' , this); } // 定义在类的原型对象上 locate() { console.log('prototype' , this); } // 定义在类本身上 static locate() { console.log('class' , this); } } let p = new Person(); p.locate(); // instance, Person {} Person.prototype.locate(); // prototype, {constructor: ... } Person.locate(); // class, class Person {} 
**

**8.4.4 继承
**

**1. 继承基础 使用 extends 关键字，就可以继承任何拥 有 [[Construct]] 和原型的对象。很大程度上，这意味着不 仅可以继承一个类，也可以继承普通的构造函数**

**2. 构造函数、 HomeObject 和 super() 派生类的方法可以通过 super 关键字引用它们的原型。这个关 键字只能在派生类中使用，而且仅限于类构造函数、实例方法和 静态方法内部。在类构造函数中使用 super 可以调用父类构造 函数。
**

**3. 抽象基类 有时候可能需要定义这样一个类，它可供其他类继承，但本身不 会被实例化。 ，但通 过 new.target 也很容易实现。 new.target 保存通过 new 关键字调用的类或函数。通过在实例化时检测 new.target 是 不是抽象基类，可以阻止对抽象基类的实例化
**

**8.5 小结 
**

**工厂模式就是一个简单的函数，这个函数可以创建对象，为它添 加属性和方法，然后返回这个对象。这个模式在构造函数模式出 现后就很少用了。 使用构造函数模式可以自定义引用类型，可以使用 new 关键字 像创建内置类型实例一样创建自定义类型的实例。不过，构造函 数模式也有不足，主要是其成员无法重用，包括函数。考虑到函 数本身是松散的、弱类型的，没有理由让函数不能在多个对象实 例间共享。 原型模式解决了成员共享的问题，只要是添加到构造函数 prototype 上的属性和方法就可以共享。而组合构造函数和原 型模式通过构造函数定义实例属性，通过原型定义共享的属性和 方法。 
**

**原型式继承可以无须明确定义构造函数而实现继承，本质上是对 给定对象执行浅复制。这种操作的结果之后还可以再进一步增 强。 与原型式继承紧密相关的是寄生式继承，即先基于一个对象创建 一个新对象，然后再增强这个新对象，最后返回新对象。这个模 式也被用在组合继承中，用于避免重复调用父类构造函数导致的 浪费。 寄生组合继承被认为是实现基于类型继承的最有效方式。**第 8 章 对象、类与面向对象编程

 

8.1 理解对象 

创建自定义对象 是创建 Object 的一个新实例，然后 再给它添加属性和方法，

let person = new Object(); person.name = "Nicholas"; person.age = 29; person.job = "Software Engineer"; person.sayName = function() { console.log(this.name); };

8.1.1 属性的类型 

属性分两种：数据属性和访问器属性。

\1. 数据属性  数据属性包含一个保存数据值的位置。值会从这个位置读取，也 会写入到这个位置。数据属性有4个特性描述它们的行为。

[[Configurable]] ：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把 它改为访问器属性默认情况下，所有直接定义在对象上的 属性的这个特性都是 true

[[Enumberable]] ：表示属性是否可以通过 for-in 循 环返回。默认情况下，所有直接定义在对象上的属性的这个 特性都是 true ，

[[Writable]] ：表示属性的值是否可以被修改。默认情 况下，所有直接定义在对象上的属性的这个特性都是 true 

[[Value]] ：包含属性实际的值。这就是前面提到的那个 读取和写入属性值的位置。这个特性的默认值为 undefined 。 

在像前面例子中那样将属性显式添加到对象之后， [[Configurable]] 、 [[Enumerable]] 和 [[Writable]] 都会被设置为 true ，而 [[Value]] 特性会 被设置为指定的值

修改属性的默认特性，就必须使用 Object.defineProperty() 方法。

这个方法接收3个参数： 要给其添加属性的对象、属性的名称和一个描述符对象。最后一 个参数，即描述符对象上的属性可以包含： configurable 、 enumerable 、 writable 和 value ，跟相关特性的名称一 一对应。根据要修改的特性，可以设置其中一个或多个值。

let person = {}; Object.defineProperty(person, "name" , { configurable: false, value: "Nicholas" }); console.log(person.name); // "Nicholas" delete person.name; console.log(person.name); // "Nicholas"

**2. 访问器属性**  访问器属性不包含数据值

包含一个获取（getter）函 数和一个设置（setter）函数  **在读 取访问器属性时，会调用获取函数，这个函数的责任就是返回一 个有效的值。在写入访问器属性时，会调用设置函数并传入新 值，这个函数必须决定对数据做出什么修改。访问器属性有4个特 性描述它们的行为。** 

[[Configurable]] ：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把 它改为数据属性。默认情况下，所有直接定义在对象上的属 性的这个特性都是 true 。

[[Configurable]] ：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把 它改为数据属性。默认情况下，所有直接定义在对象上的属 性的这个特性都是 true 。

[[Get]] ：获取函数，在读取属性时调用。默认值为 undefined 。

[[Set]] ：设置函数，在写入属性时调用。默认值为 undefined 。

访问器属性是不能直接定义的，必须使用 Object.defineProperty() 

例子：

let book = { year_: 2017, edition: 1 }; Object.defineProperty(book, "year" , { get() { return this.year_; }, set(newValue) { if (newValue > 2017) { this.year_ = newValue; this.edition += newValue - 2017; } } }); book.year = 2018; console.log(book.edition); // 2

获取函数和设置函数不一定都要定义。只定义获取函数意味着属 性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入 只定义了获取函数的属性会抛出错误。 ，非严格模式下读取会返回 undefined ，严格模式下会抛出错误。  在不支持 Object.defineProperty() 的浏览器中没有办法 修改 [[Configurable]] 或 [[Enumerable]] 。 

**8.1.2 定义多个属性 在一个对象上同时定义多个属性了 Object.defineProperties() 方法。**

**通过多个描述符一次性定义多个属性 接收两个参数：要为 之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修 改的属性一一对应。
**

比如： let book = {}; Object.defineProperties(book, { year_: { value: 2017 }, edition: { value: 1 }, year: { get() { return this.year_; }, set(newValue) { if (newValue > 2017) { this.year_ = newValue; this.edition += newValue - 2017; } } } }); 

**8.1.3 读取属性的特性** 使用 Object.getOwnPropertyDescriptor() 方法可以取 得指定属性的属性描述符。

方法接收两个参数：属性所在的对象 和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包 含 configurable 、 enumerable 、 get 和 set 属性，对于数 据属性包含 configurable 、 enumberable 、 writable 和 value 属性。

比如： let book = {}; Object.defineProperties(book, { year_: { value: 2017 }, edition: { value: 1 }, year: { get: function() { return this.year_; }, set: function(newValue){ if (newValue > 2017) { this.year_ = newValue; this.edition += newValue - 2017; } } } }); let descriptor = Object.getOwnPropertyDescriptor(book, "year_"); console.log(descriptor.value); // 2017 console.log(descriptor.configurable); // false console.log(typeof descriptor.get); // "undefined" let descriptor = Object.getOwnPropertyDescriptor(book, "year"); console.log(descriptor.value); // undefined console.log(descriptor.enumerable); // false console.log(typeof descriptor.get); // "function" 

**8.1.4 合并对象 
**

JavaScript开发者经常觉得“合并”（merge）两个对象很有用。更具 体地说，就是把源对象所有的本地属性一起复制到目标对象上。有时 候这种操作也被称为“混入”（mixin），因为目标对象通过混入源对象 的属性得到了增强。 

ES6专门为合并对象提供了 Object.assign() 方 法。 然后 将每个源对象中可枚举（ Object.propertyIsEnumerable() 返 回 true ）和自有（ Object.hasOwnProperty() 返回 true ） 属性复制到目标对象

Object.assign() 实际上对每个源对象执行的是浅复制。如 果多个源对象都有相同的属性，则使用最后一个复制的值

8.1.5 对象标识及相等判定 **在ECMAScript 6之前，有些特殊情况即使是 === 操作符也无能 为力 为改善这类情况，ECMAScript 6规范新增了 Object.is() ，这 个方法与 === 很像，但同时也考虑到了上述边界情形。这个方法必 须接收两个参数：**

要检查超过两个值，递归地利用相等性传递即可：

**8.1.6 增强的对象语法 ECMAScript 6为定义和操作对象新增了很多极其有用的语法糖特 性。这些特性都没有改变现有引擎的行为，但极大地提升了处理对象 的方便程度。
**

 **1. 属性值简写 在给对象添加变量的时候，开发者经常会发现属性名和变量名是 一样的。

**

\2. 可计算属性 在引入可计算属性之前，如果想使用变量的值作为属性，那么必 须先声明对象，然后使用中括号语法来添加属性。

\3. 简写方法名 在给对象定义方法时，通常都要写一个方法名、冒号，然后再引 用一个匿名函数表达式，

**8.1.7 对象解构 ECMAScript 6新增了对象解构语法，可以在一条语句中使用嵌套 数据实现一个或多个赋值操作。对象解构就是使用与对象 匹配的结构来实现对象属性赋值。
**

**1. 嵌套解构  解构对于引用嵌套的属性或赋值目标没有限制。为此，可以通过 解构来复制对象属性  解构赋值可以使用嵌套结构，以匹配嵌套的属性：
**

**2. 部分解构  。如果一个解构表达式涉及多个赋值，开始的赋值成功而 后面的赋值出错，则整个解构赋值只会完成一部分
**

**3. 参数上下文匹配 在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会 影响 arguments 对象，但可以在函数签名中声明在函数体内使 用局部变量：
**

**8.2 创建对象 
**

**创建具有同样接口的多个对象需要重复编 写很多代码。 
**

**ES6开始正式支持类和继承 ES6的类旨在完全涵盖之 前规范设计的基于原型的继承模式。**

**8.2.2 工厂模式  工厂模式是一种众所周知的设计模式，广泛应用于软件工程领 域，用于抽象创建特定对象的过程。
**

 **8.2.3 构造函数模式   ECMAScript中的构造函数是用于创建特定类型 对象的。像 Object 和 Array 这样的原生构造函数，运行时可以直 接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为 自己的对象类型定义属性和方法。**

**要创建 Person 的实例，应使用 new 操作符。
**

**(1) 在内存中创建一个新对象。 (2) 这个新对象内部的 [[Prototype]] 特性被赋值为构造函数 的 prototype 属性。 (3) 构造函数内部的 this 被赋值为这个新对象（即 this 指向 新对象）。 (4) 执行构造函数内部的代码（给新对象添加属性）。 (5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创 建的新对象。
**

**1. 构造函数也是函数 构造函数与普通函数唯一的区别就是调用方式不同。除此之外， 构造函数也是函数。 并没有把某个函数定义为构造函数的特殊语 法。任何函数只要使用 new 操作符调用就是构造函数，而不使 用 new 操作符调用的函数就是普通函数。
**

**2. 构造函数的问题 构造函数虽然有用，但也不是没有问题。构造函数的主要问题在 于，其定义的方法会在每个实例上都创建一遍。因此对前面的例 子而言， person1 和 person2 都有名为 sayName() 的方 法，但这两个方法不是同一个 Function 实例。
**

**8.2.4 原型模式
**

**每个函数都会创建一个 prototype 属性，这个属性是一个对 象，包含应该由特定引用类型的实例共享的属性和方法。
**

**使用原型对象的好 处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造 函数中直接赋给对象实例的值，可以直接赋值给它们的原型，
**

**1. 理解原型 
**

**无论何时，只要创建一个函数，就会按照特定的规则为这个函数 创建一个 prototype 属性（指向原型对象）。默认情况下，所 有原型对象自动获得一个名为 constructor 的属性，指回与之 关联的构造函数。
**

**在自定义构造函数时，原型对象默认只会获得 constructor 属 性，其他的所有方法都继承自 Object 。每次调用构造函数创建 一个新实例，这个实例的内部 [[Prototype]] 指针就会被赋 值为构造函数的原型对象
**

**[[Prototype]] 特性的标准方式，但Firefox、Safari和Chrome 会在每个对象上暴露 __proto__ 属性，通过这个属性可以访问 对象的原型。
**

**2. 原型层级 
**

**在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索 开始于对象实例本身。如果在这个实例上发现了给定的名称，则 返回该名称对应的值。
**

**在调用 person1.sayName() 时，会发生两步搜 索。首先，JavaScript引擎会问：“ person1 实例有 sayName 属性吗？”答案是没有。然后，继续搜索并问：“ person1 的原 型有 sayName 属性吗？”答案是有。于是就返回了保存在原型上 的这个函数。在调用 person2.sayName() 时，会发生同样的 搜索过程，而且也会返回相同的结果。这就是原型用于在多个对 象实例间共享属性和方法的原理。 因此，在调用 person1.sayName() 时，会发生两步搜 索。首先，JavaScript引擎会问：“ person1 实例有 sayName 属性吗？”答案是没有。然后，继续搜索并问：“ person1 的原 型有 sayName 属性吗？”答案是有。于是就返回了保存在原型上 的这个函数。在调用 person2.sayName() 时，会发生同样的 搜索过程，而且也会返回相同的结果。这就是原型用于在多个对 象实例间共享属性和方法的原理。 
**

**3. 原型和 in 操作符 有两种方式使用 in 操作符：单独使用和在 for-in 循环中使 用。在单独使用时， in 操作符会在可以通过对象访问指定属性 时返回 true ，无论该属性是在实例上还是在原型上。 只要通过对象可以访问， in 操作符就返回 true ，而 hasOwnProperty() 只有属性存在于实例上时才返回 true 。因此，只要 in 操作符返回 true 且 hasOwnProperty() 返回 false ，就说明该属性是一个原型 属性。
**

**4. 属性枚举顺序 
**

**for-in 循环、 Object.keys() 、 Object.getOwnPropertyNames() 、 Object.getOwnPropertySymbols() 以及 Object.assign() 在属性枚举顺序方面有很大区别。 forin 循环和 Object.keys() 的枚举顺序是不确定的，取决于 JavaScript引擎，可能因浏览器而异。 Object.getOwnPropertyNames() 、 Object.getOwnPropertySymbols() 和 Object.assign() 的枚举顺序是确定性的。先以升序枚举数 值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定 义的键以它们逗号分隔的顺序插入。
**

**8.2.5 对象迭代
**

**在JavaScript有史以来的大部分时间内，迭代对象属性都是一个难 题。 用于将对象内容转换为序 列化的——更重要的是可迭代的——格式。这两个静态方法 Object.values() 和 Object.entries() 接收一个对象，返回 它们内容的数组。 Object.values() 返回对象值的数组， Object.entries() 返回键/值对的数组。
**

**1. 其他原型语法
**

每次定义一个属性或方 法都会把 Person.prototype 重写一遍。为了减少代码冗余， 也为了从视觉上更好地封装原型功能

function Person() {} Person.prototype = { name: "Nicholas" , age: 29, job: "Software Engineer" , sayName() { console.log(this.name); } }; 

**2. 原型的动态性 因为从原型上搜索值的过程是动态的，所以即使实例在修改原型 之前已经存在，任何时候对原型对象所做的修改也会在实例上反 映出来。**

**例子： let friend = new Person(); Person.prototype.sayHi = function() { console.log("hi"); }; friend.sayHi(); // "hi"，没问题！ 以上代码先创建一个 Person 实例
**

**3. 原生对象原型 
**

 **原型模式之所以重要，不仅体现在自定义类型上，而且还因为它 也是实现所有原生引用类型的模式。所有原生引用类型的构造函 数（包括 Object 、 Array 、 String 等）都在原型上定义 了实例方法。**

**4. 原型的问题  原型模式也不是没有问题。首先，它弱化了向构造函数传递初始 化参数的能力，会导致所有实例默认都取得相同的属性值。虽
**

**这会带来不便，但还不是原型的最大问题。原型的最主要问题源 自它的共享特性。 原型上的所有属性是在实例间共享的，这对函数来说 比较合适。另外包含原始值的属性也还好，
**

**例子： function Person() {} Person.prototype = { constructor: Person, name: "Nicholas" , age: 29, job: "Software Engineer" , friends: ["Shelby" , "Court"], sayName() { console.log(this.name); } }; let person1 = new Person(); let person2 = new Person(); person1.friends.push("Van"); console.log(person1.friends); // "Shelby,Court,Van" console.log(person2.friends); // "Shelby,Court,Van" console.log(person1.friends === person2.friends); // true 
**

**8.3 继承 
**

**继承是面向对象编程中讨论最多的话题。很多面向对象语言都支 持两种继承：接口继承和实现继承
**

**8.3.1 原型链 原型链定义为ECMAScript的主要继承方式
**

**其基本 思想就是通过原型继承多个引用类型的属性和方法。重温一下构造函 数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一 个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是 另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向 另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。
**

**实现原型链涉及如下代码模式： function SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function() { return this.property; }; function SubType() { this.subproperty = false; } // 继承SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function () { return this.subproperty; }; let instance = new SubType(); console.log(instance.getSuperValue()); // true
**

**SubType 通过创建 SuperType 的实例并将其赋值给自己的原型 SubTtype.prototype 实现了对 SuperType 的继承。这个赋值 重写了 SubType 最初的原型，将其替换为 SuperType 的实例。这 意味着 SuperType 实例可以访问的所有属性和方法也会存在于 SubType.prototype 。这样实现继承之后，代码紧接着又给 SubType.prototype ，也就是这个 SuperType 的实例添加了一 个新方法。最后又创建了 SubType 的实例并调用了它继承的 getSuperValue() 方法。
**

**1. 默认原型 
**

**原型链中还有一环。默认情况下，所有引用类型都继承 自 Object ，这也是通过原型链实现的。任何函数的默认原型都 是一个 Object 的实例，这意味着这个实例有一个内部指针指 向 Object.prototype 。
**

**2. 原型与继承关系
**

**原型与实例的关系可以通过两种方式来确定。第一种方式是使用 instanceof 操作符，如果一个实例的原型链中出现过相应的 构造函数，则 instanceof 返回 true
**

**3. 关于方法 
**

**子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为 此，这些方法必须在原型赋值之后再添加到原型上。
**

**4. 原型链的问题
**

**问题出 现在原型中包含引用值的时候。前面在谈到原型的问题时也提到 过，原型中包含的引用值会在所有实例间共享，这也是为什么属 性通常会在构造函数中定义而不会定义在原型上的原因。在使用 原型实现继承时，原型实际上变成了另一个类型的实例。这意味 着原先的实例属性摇身一变成为了原型属性。
**

**例子  function SuperType() { this.colors = ["red" , "blue" , "green"]; } function SubType() {} // 继承SuperType SubType.prototype = new SuperType(); let instance1 = new SubType(); instance1.colors.push("black"); console.log(instance1.colors); // "red,blue,green,black" let instance2 = new SubType(); console.log(instance2.colors); // "red,blue,green,black" 
**

**8.3.2 盗用构造函数
**

**为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函 数”（constructor stealing）的技术在开发社区流行起来（这种技术有时 也称作“对象伪装”或“经典继承”）。 在子类构造函 数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码 的简单对象，所以可以使用 apply() 和 call() 方法以新创建的对 象为上下文执行构造函数。
**

**1. 传递参数 相比于使用原型链，盗用构造函数的一个优点就是可以在子类构 造函数中向父类构造函数传参。
**

**2. 盗用构造函数的问题 盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的 问题：必须在构造函数中定义方法，因此函数不能重用。
**

**8.3.3 组合继承 
**

 **组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函 数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上 的属性和方法，而通过盗用构造函数继承实例属性。**

**例子： function SuperType(name){ this.name = name; this.colors = ["red" , "blue" , "green"]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age){ // 继承属性 SuperType.call(this, name); this.age = age; } // 继承方法 SubType.prototype = new SuperType(); SubType.prototype.sayAge = function() { console.log(this.age); }; let instance1 = new SubType("Nicholas" , 29); instance1.colors.push("black"); console.log(instance1.colors); // "red,blue,green,black" instance1.sayName(); // "Nicholas"; instance1.sayAge(); // 29 let instance2 = new SubType("Greg" , 27); console.log(instance2.colors); // "red,blue,green" instance2.sayName(); // "Greg"; instance2.sayAge(); // 27** 

**8.3.4 原型式继承
**

**function object(o) { function F() {} F.prototype = o; return new F(); } 
**

**object() 函数会创建一个临时构造函数，将传入的对象 赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。
**

**你有一个对象，想 在它的基础上再创建一个新对象。你需要把这个对象先传给 object() ，然后再对返回的对象进行适当修改。在这个例子中， person 对象定义了另一个对象也应该共享的信息，把它传给 object() 之后会返回一个新对象。这个新对象的原型是 person ，意味着它的原型上既有原始值属性又有引用值属性。这也 意味着 person.friends 不仅是 person 的属性，也会跟 anotherPerson 和 yetAnotherPerson 共享。这里实际上克隆 了两个 person 。 
**

**8.3.5 寄生式继承 
**

**与原型式继承比较接近的一种继承方式是寄生式继承（parasitic inheritance），也是Crockford首倡的一种模式。寄生式继承背后的思 路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某 种方式增强对象，然后返回这个对象
**

**function createAnother(original){ let clone = object(original); // 通过调用函数创 建一个新对象 clone.sayHi = function() { // 以某种方式增强 这个对象 console.log("hi"); }; return clone; // 返回这个对象 } 
**

**8.3.6 寄生式组合继承
**

**组合继承其实也存在效率问题。最主要的效率问题就是父类构造 函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在 子类构造函数中调用
**

**本质上，子类原型最终是要包含超类对象的所 有实例属性，子类构造函数只要在执行时重写自己的原型就行了
**

**例子： function SuperType(name) { this.name = name; this.colors = ["red" , "blue" , "green"]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age){ SuperType.call(this, name); // 第二次调用 SuperType() this.age = age; } SubType.prototype = new SuperType(); // 第一次调 用SuperType() SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function() { console.log(this.age); }; 
**

**8.4 类
**

**类（class）是ECMAScript中新的基础性语法糖结 构，因此刚开始接触时可能会不太习惯。虽然ECMAScript 6类表面上 看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是 原型和构造函数的概念。 
**

**8.4.1 类定义
**

  **与函数类型相似，定义类也有两种主要方式：类声明和类表达 式。这两种方式都使用 class 关键字加大括号：**

**// 类声明 class Person {} // 类表达式 const Animal = class {}; 
**

**类的构成 类可以包含构造函数方法、实例方法、获取函数、设置函数和静 态类方法，但这些都不是必需的。空的类定义照样有效。默认情况 下，类定义中的代码都在严格模式下执行
**

**与函数构造函数一样，多数编程风格都建议类名的首字母要大 写，以区别于通过它创建的实例（比如，通过 class Foo {} 创建 实例 foo ）： // 空类定义，有效 class Foo {} // 有构造函数的类，有效 class Bar { constructor() {} } // 有获取函数的类，有效 class Baz { get myBaz() {} } // 有静态方法的类，有效 class Qux { static myQux() {} } 类表
**

**8.4.2 类构造函数
**

**constructor 关键字用于在类定义块内部创建类的构造函数。 方法名 constructor 会告诉解释器在使用 new 操作符创建类的新 实例时，应该调用这个函数。构造函数的定义不是必需的，不定义构 造函数相当于将构造函数定义为空函数
**

**1. 实例化 使用 new 操作符实例化 Person 的操作等于使用 new 调用其 构造函数。唯一可感知的不同之处就是，JavaScript解释器知道使 用 new 和类意味着应该使用 constructor 函数进行实例化。
**

**使用new调用类的构造函数会执行如下操作。 (1) 在内存中创建一个新对象。 (2) 这个新对象内部的 [[Prototype]] 指针被赋值为构造函数 的 prototype 属性。 (3) 构造函数内部的 this 被赋值为这个新对象（即 this 指向 新对象）。 (4) 执行构造函数内部的代码（给新对象添加属性）。 (5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创 建的新对象。 来看下面的例子： class Animal {} class Person { constructor() { console.log('person ctor'); } } class Vegetable { constructor() { this.color = 'orange'; } } let a = new Animal(); let p = new Person(); // person ctor let v = new Vegetable(); console.log(v.color); // orange 类实例化时传入的参数会用作构造函数的
**

**2. 把类当成特殊函数 ECMAScript中没有正式的类这个类型。从各方面来看， ECMAScript类就是一种特殊函数。声明一个类之后，通过 typeof 操作符检测类标识符，表明它是一个函数： class Person {} console.log(Person); // class Person {} console.log(typeof Person); // function
**

**8.4.3 实例、原型和类成员
**

**1. 实例成员 每次通过 new 调用类标识符时，都会执行类构造函数。在这个 函数内部，可以为新创建的实例（ this ）添加“自有”属性。
**

**每个实例都对应一个唯一的成员对象，这意味着所有成员都不会 在原型上共享： 
**

**class Person { constructor() { // 这个例子先使用对象包装类型定义一个字符串 // 为的是在下面测试两个对象的相等性 this.name = new String('Jack'); this.sayName = () => console.log(this.name); this.nicknames = ['Jake' , 'J-Dog'] } } let p1 = new Person(), p2 = new Person(); p1.sayName(); // Jack p2.sayName(); // Jack console.log(p1.name === p2.name); // false console.log(p1.sayName === p2.sayName); // false console.log(p1.nicknames === p2.nicknames); // false p1.name = p1.nicknames[0]; p2.name = p2.nicknames[1]; p1.sayName(); // Jake p2.sayName(); // J-Dog
**

**3. 静态类方法 
**

**静态类成员在类定义中使用 static 关键字作为前缀。在静态成 员中， this 引用类自身。其他所有约定跟原型成员一样： class Person { constructor() { // 添加到this的所有内容都会存在于不同的实例上 this.locate = () => console.log('instance' , this); } // 定义在类的原型对象上 locate() { console.log('prototype' , this); } // 定义在类本身上 static locate() { console.log('class' , this); } } let p = new Person(); p.locate(); // instance, Person {} Person.prototype.locate(); // prototype, {constructor: ... } Person.locate(); // class, class Person {} 
**

**8.4.4 继承
**

**1. 继承基础 使用 extends 关键字，就可以继承任何拥 有 [[Construct]] 和原型的对象。很大程度上，这意味着不 仅可以继承一个类，也可以继承普通的构造函数**

**2. 构造函数、 HomeObject 和 super() 派生类的方法可以通过 super 关键字引用它们的原型。这个关 键字只能在派生类中使用，而且仅限于类构造函数、实例方法和 静态方法内部。在类构造函数中使用 super 可以调用父类构造 函数。
**

**3. 抽象基类 有时候可能需要定义这样一个类，它可供其他类继承，但本身不 会被实例化。 ，但通 过 new.target 也很容易实现。 new.target 保存通过 new 关键字调用的类或函数。通过在实例化时检测 new.target 是 不是抽象基类，可以阻止对抽象基类的实例化
**

**8.5 小结 
**

**工厂模式就是一个简单的函数，这个函数可以创建对象，为它添 加属性和方法，然后返回这个对象。这个模式在构造函数模式出 现后就很少用了。 使用构造函数模式可以自定义引用类型，可以使用 new 关键字 像创建内置类型实例一样创建自定义类型的实例。不过，构造函 数模式也有不足，主要是其成员无法重用，包括函数。考虑到函 数本身是松散的、弱类型的，没有理由让函数不能在多个对象实 例间共享。 原型模式解决了成员共享的问题，只要是添加到构造函数 prototype 上的属性和方法就可以共享。而组合构造函数和原 型模式通过构造函数定义实例属性，通过原型定义共享的属性和 方法。 
**

**原型式继承可以无须明确定义构造函数而实现继承，本质上是对 给定对象执行浅复制。这种操作的结果之后还可以再进一步增 强。 与原型式继承紧密相关的是寄生式继承，即先基于一个对象创建 一个新对象，然后再增强这个新对象，最后返回新对象。这个模 式也被用在组合继承中，用于避免重复调用父类构造函数导致的 浪费。 寄生组合继承被认为是实现基于类型继承的最有效方式。**
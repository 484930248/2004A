第1章 什么是JavaScript 
==================================

## 什么是JavaScript

- JavaScript（通常缩写为JS）是一种高级的、解释型的编程语言；它是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程，命令式编程，以及函数式编程。
- 除了HTML和CSS, JavaScript是万维网的核心技术之一。JavaScript支持交互式web页面，是web应用程序的重要组成部分。绝大多数网站都使用它，主要的网络浏览器都有专门的JavaScript引擎来执行它。
- 作为一种多范式语言，JavaScript支持事件驱动，功能和命令式（包括面向对象和基于原型）的编程风格。
- 它具有用于处理文本，数组，日期，正则表达式和DOM的API，但语言本身不包含任何I / O，例如网络，存储或图形工具。它依赖于嵌入它的主机环境来提供这些功能。

JavaScript也就是我们常说的JS，或者说是JS脚本。

## 发展历程



- 1997年7月，ECMAScript 1.0发布。
- 1998年6月，ECMAScript 2.0版发布。
- 1999年12月，ECMAScript 3.0版发布，成为 JavaScript 的通行标准，得到了广泛支持。
- 2007年10月，ECMAScript 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。
- 2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA 开会决定，中止 ECMAScript 4.0 的开发（即废除了这个版本），将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。
- 2009年12月，ECMAScript 5.0版 正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 的总体考虑是，ECMAScript 5 与 ECMAScript 3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是ECMAScript 6。第六版发布以后，将指 ECMAScript 7。TC39 预计，ECMAScript 5 会在2013年的年中成为 JavaScript 开发的主流标准，并在此后五年中一直保持这个位置。
- 2011年6月，ECMAScript 5.1版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。到了2012年底，所有主要浏览器都支持 ECMAScript 5.1版的全部功能。
- 2013年3月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。
- 2013年12月，ECMAScript 6 草案发布。然后是12个月的讨论期，听取各方反馈。
- 2015年6月，ECMAScript 6 正式发布，并且更名为“ECMAScript 2015”。这是因为 TC39 委员会计划，以后每年发布一个 ECMAScript 的版本，下一个版本在2016年发布，称为“ECMAScript 2016”，2017年发布“ECMAScript 2017”，以此类推。

## 语言特点

JavaScript脚本语言具有以下特点:

- 解释性：javascript是一种解释语言，源代码不需要经过编译，直接在浏览器上运行时被解释。
- 基于对象：javascripth是一种基于对象的语言，能运用自己已经创建了的对象，许多功能可以来自于脚本环境中对象的方法与脚本的相互作用。
- 事件驱动：JavaScript可以直接对用户或客户输入做出响应，无需经过web服务程序。他对用户的响应，是以事件驱动的方式进行的，所谓事件驱动，指的是在主页执行了某种操作所产生的动作，此动作称为“事件”。
- 跨平台：JavaScript依赖于浏览器本身，与操作环境无关。只要能运行浏览器的计算机，并支持JavaScript的浏览器就可以正确执行。



- 安全性：JavaScript是一种安全性语言。它不允许访问本地的磁盘，并不能将数据存入服务器上；不允许对网络文本进行修改和删除，只能通过浏览器实现信息浏览或动态交互。可有效的防止数据丢失。

## JavaScript能做什么？



- 使网页具有交互性，例如响应用户点击，给用户提供更好的体验
- 可以处理表单，检验用户的输入，并提供及时反馈节省用户时间。例如，表单中要你输入电子邮箱而你却输入一个手机号，那么应该给你一个提醒。
- 还可以根据用户的操作，动态的创建页面。例如，发邮件时，添加附件操作。
- 设置cookie，cookie是存储在浏览器上的一些临时信息，例如你浏览过的网站地址，使用过的用户名
- JavaScript 使有规律地重复的HTML文段简化，减少下载时间。
- 浏览器与服务器进行数据通讯，比如现在最流行的Ajax异步传输；
- 更丰富的界面，可以使用JavaScript来包含诸如拖放组件和滑块之类的项目，以便为您的站点访问者提供丰富的界面。
- 可以制作游戏，微信端小游戏基本都是js写的。
- 基于Node.js技术进行服务器端编程。



## **举例**

这是一个精美的网页，我们可以看到我们鼠标在悬浮于表格，点击按钮时都有各种响应。



当我们把JS去掉

表格的特效都消失了，虽然网页的整体结构还在，但是已经黯然失色了。



我们把CSS去掉

只剩下HTML的标签了，页面布局都消失了。



**总结**

如果说HTML是网页的结构，表示网页中有什么（表格，按钮，标签），CSS是美化网页，表示网页长什么样。

那么JavaScript就是网页的灵魂，决定这个这个网页最终能实现什么功能。

## JavaScript与Java、ECMASCript的关系

1. **Java与JavaScript的关系**

引用网上一个比较流程的比喻

一般认为，当时 Netscape 之所以将 LiveScript 命名为 JavaScript，是因为 Java 是当时最流行的编程语言，带有 “Java” 的名字有助于这门新生语言的传播。

它们的相同之处包括：

- 它们的语法和 C 语言都很相似；
- 它们都是面向对象的（虽然实现的方式略有不同）；
- JavaScript 在设计时参照了 Java 的命名规则；

它们的不同之处包括：

- JavaScript 是动态类型语言，而 Java 是静态类型语言；
- JavaScript 是弱类型的，Java 属于强类型；
- JavaScript 的面向对象是基于原型的（prototype-based）实现的，Java 是基于类（class-based）的；

JavaScript 除了长得和 Java 比较像之外，语言风格相去甚远。JavaScript 在设计时所参考的对象不包括 Java，而包括了像 Self 和 Scheme 这样的语言。

1. **JavaScript和ECMAScript的关系**

ECMAScript是JavaScript的规格，JavaScript是ECMAScript的一种实现，在日常场合，这两个词是可以互换的。

JavaScript的创造者Netscape公司，将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准，后来ECMA发布标准文件的第一版（ECMA-262），规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript。

该标准从一开始就是针对JavaScript语言制定的，之所以不叫JavaScript，有两个原因：一是商标，Java是Sun公司的商标，根据授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，且JavaScript本身也已经被Netscape公司注册为商标；二是想体现这门语言的制定者是ECMA，不是Netscape，有利于保证这门语言的开放性和中立性。

## 核心组成部分

JavaScript比ECMA-262的含义多得多，一个完整的JavaScript实现应该由以下三个部分组成：

- ECMAScript 2.DOM（document object model）3.BOM（browser object document ） （1）ECMA是（欧洲计算机制造商协会）它规定了js的语法标准。
- DOM是文档对象模型，规定了文档的显示结构，可以轻松地删除、添加和替换节点
- BOM是浏览器对象模型，就是浏览器自带的一些功能样式，如搜索框，设置，等学习浏览器窗口交互的对象







# 第2章HTML中的JavaScript

## 一、script 元素

### 1.1属性：

<script>标签有8个属性：

`1.async`:

可选。表示脚本立即下载，但不能阻止其他页面动作，比如下载资源或其他脚本加载。只对外部脚本文件有效

`2.defer`：

可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效

`3.src`：

可选。表示包含要执行的代码的外部文件。

`4.charset`：

可选。使用src属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。

`5.crossorigin`：

crossorigin：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。crossorigin="anonymous"配置文件请求不必设置凭据标志。
crossorigin="use-credentials"设置凭据标志，意味着出站请求会包含凭据。

`6.integrity`：

可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，SubresourceIntegrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，ContentDeliveryNetwork）不会提供恶意内容

`7.type`：

可选。代替language，表示代码块中脚本语言的内容类型（也称MIME类型）按照惯例。这个值始终都是"text/javascript" 尽管"text/javascript"和"text/ecmascript"都已经废弃了。JavaScript文件的MIME类型通常是"application/x-javascript"，不过给type属性这个值有可能导致脚本被忽略。在非IE的浏览器中有效的其他值还有"application/javascript"和"application/ecmascript"。如果这个值是module，则代码会被当成ES6模块，而且只有这时候代码中才能出现import和export关键字。

`8.language`：language：废弃。最初用于表示代码块中的脚本语言(如"JavaScript"、“JavaScript1.2"或"VBScript”）。大多数浏览器都会忽略这个属性，不应该再使用它。

### 1.2标签位置：

过去所有的<script>元素都被放在<head>标签里，主要是为了把所有的外部css和JavaScript文件集中放在一起。但这样，意味着页面的渲染在脚本下载/执行完之后，那么如果下载的脚本很多，页面就可能会出现短暂的空白期。为了解决这个问题，现代web开发通常将JavaScript文件放在<body>元素后，这样一来，页面会在处理JavaScript脚本之前完成渲染，空白期会更短。这种放置标签的方式也是一种优化网站的简单方式。

### 1.3推迟执行脚本：

script标签中有个叫defer的属性。这个属性表示脚本在执行的时候不会改变页面的结构，也就是说外部脚本文件加上这个属性会推迟脚本的执行：当html中的head 和 body元素被解析完毕了，它才会被浏览器解析。

### 1.4异步执行脚本：

script标签中有个叫async的属性。这个属性表示异步脚本的执行不会根据脚本放置的先后顺序，同时异步脚本的下载和执行不会影响页面的加载。由于异步的原因，脚本可能会先于页面加载执行，所以不应该在异步脚本中修改DOM。

### 1.5动态加载脚本：

除了通过script标签加载脚本，我们还可以通过动态加载脚本的方式。因为JavaScript是可以使用DOM API的，所以我们可以在script元素中动态创建script元素并将其指定需要 加载的脚本即可实现动态加载脚本的操作。下面展示下红宝书里的示例代码：

```javascript
let script = document.createElement('script'); // 创建script元素
script.src = 'gibberish.js'; // 指定需要动态加载的脚本文件
document.head.appebdChild(script); // 在head中添加
123
```

默认情况下这种方式加载的脚本是异步的，但由于不是所有的浏览器的支持async属性，我们可以统一动态脚本的加载方式，设置为同步加载，代码如下

```javascript
let script = document.createElement('script'); // 创建script元素
script.src = 'gibberish.js'; // 指定需要动态加载的脚本文件
script.async = 'false'; // 指定为同步加载
document.head.appebdChild(script); // 在head中添加
1234
```

同时由于这种方式获取的脚本对于浏览器预加载器是不可见的。这会严重影响资源获取队列的优先级，因此可能会严重影响性能，所以我们应当事先告知动态脚本的存在：

```html
<link rel="preload" href="gibberish.js">
1
```

### 1.6XHTML中的变化：

在这我简单介绍下XHTML，具体详细的讲解还是看看原作吧！
XHTML也称可拓展超文本标记语言，它是将HTML作为XML的应用重新包装的结果。
在XHTML中使用JavaScript必须指定type属性值:text/javascript;
XHTML会把小于号<解析成一个标签的开始。有两种方法解决这个问题:
1.将 < 替换成 &lt
2.将所有代码都有包含发送一个CDATA中 <![CDATA[  ]]>

## 二、行内代码和外部文件

虽然可以直接将代码嵌入到HTML中，但是通常最佳做法是将JavaScript代码放在外部文件中。推荐理由如下：

1. **可维护性**：如果将JavaScript代码分散到很多HTML页面，会导致维护困难；而用一个目录保存所有JavaScript文件，则更容易维护，这样一来开发者可以独立于使用它们的HTML页面来编辑代码
2. **缓存**：浏览器会根据特定的设置缓存所有外部链接的JavaScript文件，这就意味着如果两个页面都使用同一个脚本文件，那么该脚本文件只需下载一次。这就意味着页面加载更快
3. **适应未来**：通过把JavaScript文件放到外部文件中，就不必考虑到用XHTML。包含外部脚本的语言在HTML和XHTML中是一样的。

书中还讲到配置浏览器请求外部文件时的带宽问题。总而言之对于较新的浏览器以轻量、独立JavaScript组件形式向客户端送达脚本更具优势。如果是对于较老的浏览器可能还是一个大的脚本文件更好。

## 三、文档模式

目前主要有三种文档模式：混杂模式；标准模式；准标准模式。这些模式的区别主要体现在通过CSS 渲染的内容方面，但对JavaScript也有一定关联影响；其次不同模式的声明方式不同。感兴趣的小伙伴可以去看原著或查阅更多的书籍。

## 四、noscript元素

针对早期浏览器不支持JavaScript的问题，需要一个页面优雅降级的处理方案。noscript的出现，被用于给不支持JavaScript的浏览器提供替代内容，<noscript>中可以使用任何<body>中的HTML元素。以下任意一种情况都会展示<noscript>中的内容：

1. 浏览器不支持脚本；
2. 浏览器对脚本的支持被关闭



# 第3章语言基础

## JavaScript的作用和特点 

1. 前身：livescript
2. JavaScript分三部分：核心，客户机端，服务器端，
3. JavaScript特点：分布式运算，安全可靠，容易移植，使用浏览器对象。

## JavaScript语法

1. **常量：整形常量，浮点型常量，布尔常量，字符串常量，转义字符，UNdefine，NULL**

2. **变量：var 变量名=值**

3. **类型：原始类型（值放栈中，访问变量可直接访问变量的值）：underfined，null，boolean，number，string
        引用类型（指针放栈中，需通过指针才能访问）：boolwan，number，string(这三是原始类型也可是引用类型)，arrary，date，math**

4. **运算符：算术运算符+,-,\*,/,%,++,--,-
         逻辑运算符：&&，||,!
         比较运算符：>，<，===，！==，>=，<=
         位运算符：&,|,^,~,<<,>>,>>>
         赋值运算符：=，op=
         条件运算符：条件？表达式1：表达式2
         字符串连接运算符：+，+=
         new运算符：创建一个对象
         delete运算符:删除一个对象**

5. **语句：用；分。
        表达书语句。条件语句if...else...。多路分支语句：switch..case...。循环语句：while。循环语句：do...while。循环语句for。退出循环：break，continue。**

   

## JavaScript函数：

1. **格式：function 函数名称（）
   {
   函数体
   }**
2. return返回：没有包含return语句后return没有包含表达式，最终返回undefined。
3. **局部变量：在函数内部定义的变量使用var修饰，只在函数内有效
   全局变量：在函数内定义内var修饰，或在函数之外定义**
4. JavaScript不支持行内变量定义，作业变量最好在函数开始前处说明，才能保证他们是局部变量。
   如果在语句中应用了一个未声明变量，自动回变成全局变量，可能会影响其他函数执行。

## javas使用方法：

1. **使用标记将JavaScript脚本嵌入HTML中**
2. **,放入或之间。**
3. **外部JavaScript文件扩展名：.js**

JavaScript内置对象： 

1. **String对象：字符。
   常考：indexOf（指定字符，开始位置）：返回字符串中第一个出现指定字符串的位置
        split（字符串分隔依据）：将字符串分隔为数组
        toLowerCase（）：全变小写
        toUpperCase（）：全变大写
        valueOf（）：返回字符串对象的原始值
        charAt（）：返回指定索引出的字符**

2. **Math对象：数学运算。
   常考：floor（）返回四舍五入后最小整数。
        random（）返回位于0-1之间的随机数
        round()四舍五入整值**

3. **Date对象：日期时间。
   常考：new Date（）得到时间日期
        getDay（）星期几（返回0-6）
        getFullYear完整4位年份数
        getMonth（）月（返回0-11）
        getDate（）日（返回1-31）
        getHours（）小时（返回0-23）
        getMinutes（）分钟（返回0-59）
        getSeconds（）秒数（返回0-59）**

4. **Ararry对象:数组模型。
   常考：slice（开始，移除数，新元素）：从数组移除一个或多个元素，有必要可以在移除位置添加新元素。
        sort（）排序
        toString（）将所有元素合并成一个字符串并返回，用，分隔**

5. Global：JavaScript初始化时的特殊对象。（概念，无需引用）
   常考：属性：underfined指定一个未被赋值变量
        **方法：****eval****（****String****）判断一个字符串并将以脚本代码形式执行
   **        isNaN**（****String****）判断一个字符串是否是非数字值。
   **      parseInt**（****String****）将一个字符串解析为一个整数。** 

   

   12点了未完待续

## 浏览器对象模型Bom:

（用于描述对象与对象之间层次关系的模型，提供独立于内容，可以与浏览器窗口进行互动的对象结构。）

window对象是bom的顶层对象，其他对象都是他的子对象。

 

## JavaScript事件及处理 

   常考事件及含义：

1. **onblur元素失去焦点**
2. **onchange用户改变域的内容（文本输入框及选择域的内容变化事件，即随输入的东西而给出的反应）**
3. **onclick鼠标点击某个对象（只在img，a，input有效）**
4. **onfocus元素获得焦点**
5. **onload某个页面或图像被加载完成**
6. **onmouseout鼠标从某个元素移开**
7. **onmouseover鼠标被移到某个元素之上**
8. **onselect文本被选定**
9. **onsubmit提交按钮被点击（用fasle来阻止该表单的提交行为）**

   程序处理程序引入（为某个标记元素对象绑定事件响应的函数）

​      **事件绑定：其句柄名以属性名的 形式在html标记试题对象中出现，对应属性值事件响应的代码（函数名），从而实现Html标记元素与JavaScript事件响应的函数名对应。**

​      静态引入：用；分隔，在某个标记中添加某个事件句柄的属性，再写事件处理的程序代码

​      动态引入：将事件响应的函数名直接赋值给html某个标记元素的事件属性，用id属性命名某个超链接，然后为该标记动态引入事件处理方法的代码

## 文档对象模型Dom： 

1. 文档D：根据网页创建的一个文档对象
2. 对象O：一种独立的数据结合
3. 模型M：文档对象的树状模型，元素与内容表现为一个个相互连接的结点
         结点包括：元素结点（body，div，a）；文本结点（p）；属性结点（a）
4. 体系结构：树状
5. 结点关系：父子，兄弟，祖孙





# 第4章变量、作用域与内存

JS变量是松散型的(不强制类型)本质,决定了它只是在特定时间用于保存特定值的一个名字而已;
由于不存在定义某个变量必须要保存何种数据类型值的规则,变量的值及其数据类型可以在脚本的生命周期内改变;

# 一 .变量及作用域

### 1.基本类型和引用类型

// JS变量包含两种不同的数据类型的值:基本类型值和引用类型值;

// 1.基本类型值:保存在栈内存中的简单数据段;即这种值完全保存在内存中的一个位置;
// 基本类型值包含:Undefined|Null|Boolean|Number|String;
// 这些类型在内存中占有固定大小的空间;它们的值保存在栈空间,我们按值来访问;

// 2.引用类型值:保存在堆内存中的对象(可能由多个值构成),即变量中保存的实际上只是一个指针,这个指针指向内存中的另一个位置,该位置保存对象;
// 引用类型的值的大小不固定,因此不能保存在栈内存,必须保存在堆内存中;但可以将引用类型的值的内存地址保存在栈内存中;
// 当查询引用类型的变量时,先从栈内存中读取内存地址,然后通过地址找到堆内存中的值;=>按引用访问;

### 2.动态属性



```html
<span style="font-size:18px;">// 定义基本类型值和引用类型值的方式相似:创建一个变量并为该变量赋值;// 但当这个值保存到变量中以后,对不同类型值可以执行的操作则不一样;  var box = new Object();           // 创建引用类型;  box.name = 'lee';              // 新增一个属性;  console.log(box.name);           // =>lee;   var box = 'lee';              // 创建基本类型  box.age = 15;                // 给基本类型添加属性;  console.log(box.age);            // =>undefined;</span>
```







### 3.复制变量值



```html
<span style="font-size:18px;">// 在变量复制方面,基本类型和引用类型也有所不同;// 基本类型赋值的是值本身;  var box = 'lee';              // 在栈内存中生成一个box'lee';  var box2 = box;               // 在栈内存中再生成一个box2'lee';  // box和box2完全独立;两个变量分别操作时互不影响; // 引用类型赋值的是地址;  var box = new Object();          // 创建一个引用类型;box在栈内存中;而Object在堆内存中;  box.name = 'lee';             // 新增一个属性;  var box2 = box;              // 把引用地址赋值给box2;box2在栈内存中;  // box2=box,因为它们指向的是同一个对象;  // 如果这个对象中的name属性被修改了,box.name和box2.name输出的值都会被修改掉;</span>
```







### 4.传递参数





```
// JS中所有函数的参数都是按值传递的,即参数不会按引用传递;
 ` `function` `box(num){       ``// 按值传递,传递的参数是基本类型;
  ` `num +=10;        ``// 这里的num是局部变量,全局无效;
  ` `return` `num;
 ` `}
 ` `var` `num = 50;
 ` `var` `result = box(num);
 ` `console.log(result);      ``// 60;
 ` `console.log(num);       ``// 50;
```

 

```
 ` `function` `box(num){
  ` `return` `num;
 ` `}
 ` `console.log(num);       ``// num is not defined;
```

 

```
 ` `function` `box(obj){
  ` `obj.name = ``'lee'` `;
  ` `var` `obj = ``new` `Object();    ``// 函数内部又创建了一个对象,它是局部变量;但在函数结束时被销毁了;
  ` `obj.name = ``'Mr'` `;      ``// 并没有替换掉原来的obj;
 ` `}
 ` `var` `p = ``new` `Object();
 ` `box(p);         ``// 变量p被传递到box()函数中之后就被复制给了obj;在函数内部,obj和p访问的是同一个对象;
 ` `console.log(p.name);      ``// =>lee;
```

 

```
 ` `// JS函数的参数都将是局部变量;也就是说,没有按引用传递;
```





### 5.检测类型



```html
<span style="font-size:18px;">// 要检测一个变量的类型,通过typeof运算符类判断;// 多用来检测基本类型;  var box = 'lee';  console.log(typeof box);          // =>string; // 要检测变量是什么类型的对象,通过instanceof运算符来查看;  var box = [1,2,3];  console.log(box instanceof Array);     // =>true;  var box2 = {};  console.log(box2 instanceof Object);  var box3 = /g/;  console.lgo(box3 instanceof RegExp);  var box4 = new String('lee');  console.log(box4 instanceof String);   // =>true;是否是字符串对象;   var box5 = 'string';  console.log(box5 instanceof String);   // =>false;  // 当使用instanceof检查基本类型的值时,它会返回false;</span>
```







### **6.执行环境及作用域



```html
<span style="font-size:18px;">// 执行环境:定义了变量或函数有权访问的其他数据,决定了它们各自的行为;// 在Web浏览器中,全局执行环境=window对象;// 因此所有的全局变量和函数都是作为window对象的属性和方法创建的;  var box = 'blue';             // 声明一个全局变量;  function setBox(){    console.log(box);           // 全局变量可以在函数里访问;  }   setBox();                 // 执行函数;  // 全局的变量=window对象的属性;  // 全局的函数=window对象的方法; // PS:当执行环境中的所有代码执行完毕后,该环境被销毁,保存在其中的所有变量和函数定义也随之销毁;// 如果是在全局环境下,需要程序执行完毕,或者网页被关闭才会销毁; // PS:每个执行环境都有一个与之关联的变量对象,就好比全局的window可以调用全局变量和全局方法一样;// 局部的环境也有一个类似window的变量对象,环境中定义的所有变量和函数都保存在这个对象中;// (我们无法访问这个变量对象,但解析器会处理数据时后台使用它);  var box = 'blue';  function setBox(){    var box = 'red';           // 这里是局部变量,在当前函数体内的值是'red';出了函数体就不被认知;    console.log(box);  }   setBox();  console.log(box); // 通过传参可以替换函数体内的局部变量,但作用域仅限在函数体内这个局部环境;  var box = 'blue';  function setBox(box){           // 通过传参,将局部变量替换成了全局变量;    alert(box);              // 此时box的值是外部调用时传入的参数;=>red;  }  setBox('red');  alert(box); // 如果函数体内还包含着函数,只有这个内函数才可以访问外一层的函数的变量;// 内部环境可以通过作用域链访问所有的外部环境,但外部环境不能访问内部环境中的任何变量和函数;  var box = 'blue';  function setBox(){    function setColor(){      var b = 'orange';      alert(box);      alert(b);    }    setColor();              // setColor()的执行环境在setBox()内;  }  setBox();  // PS:每个函数被调用时都会创建自己的执行环境;当执行到这个函数时,函数的环境就会被推到环境栈中去执行,而执行后又在环境栈中弹出(退出),把控制权交给上一级的执行环境;   // PS:当代码在一个环境中执行时,就会形成一种叫做作用域链的东西;它的用途是保证对执行环境中有访问权限的变量和函数进行有序访问;作用域链的前端,就是执行环境的变量对象; </span>
```



### **7.延长作用域链**



```html
// 有些语句可以在作用域链的前端临时增加一个变量对象,该变量对象会在代码执行后被移除;// with语句和try-catch语句;这两个语句都会在作用域链的前端添加一个变量对象;// with语句:会将指定的对象添加到作用域链中; // catch语句:会创建一个新的变量对象,其中包含的是被抛出的错误对象的声明;  function buildUrl(){    var qs = '?debug=true';    with(location){            // with语句接收的是location对象,因此变量对象中就包含了location对象的所有属性和方法;      var url = href+qs;        // 而这个变量对象被添加到了作用域链的前端;    };    return url;  }
```







### 8.没有块级作用域



```html
<span style="font-size:18px;">	// 块级作用域:表示诸如if语句等有花括号封闭的代码块,所以,支持条件判断来定义变量;  if(true){                 // if语句代码块没有局部作用域;    var box = 'lee';           // 变量声明会将变量添加到当前的执行环境(在这里是全局环境);  }  alert(box);   for(var i=0; i<10; i++){         // 创建的变量i即使在for循环执行结束后,也依旧会存在与循环外部的执行环境中;    var box = 'lee';  }  alert(i);  alert(box);   function box(num1,num2){    var sum = num1+num2;         // 此时sum是局部变量;如果去掉var,sum就是全局变量了;    return sum;  }  alert(box(10,10));  alert(sum);                // sum is not defined;访问不到sum;  // PS:不建议不使用var就初始化变量,因为这种方法会导致各种意外发生; // 一般确定变量都是通过搜索来确定该标识符实际代表什么;搜索方式:向上逐级查询;  var box = 'blue';  function getBox(){    return box;              // 此时box是全局变量;如果是var box='red',那就变成局部变量了;  }  alert(getBox());               // 调用getBox()时会引用变量box;  // 首先,搜索getBox()的变量对象,查找名为box的标识符;  // 然后,搜索继续下一个变量对象(全局环境的变量对象),找到了box标识符;// PS:变量查询中，访问局部变量要比全局变量更快，因为不需要向上搜索作用域链；</span>
```





## 二 内存问题



```html
<span style="font-size:18px;">// JS具有自动垃圾收集机制,执行环境会负责管理代码执行过程中使用的内存;它会自行管理内存分配及无用内存的回收; // JS最常用的垃圾收集方式就是标记清除;垃圾收集器会在运行的时候给存储在内存中的变量加上标记;// 然后,它会去掉环境中正在使用的变量的标记,而没有被去掉标记的变量将被视为准备删除的变量;// 最后,垃圾收集器完成内存清理工作,销毁那些标记的值并回收他们所占用的内存空间; // 垃圾收集器是周期性运行的,这样会导致整个程序的性能问题;// 比如IE7以前的版本,他的垃圾收集器是根据内存分配量运行的,比如256个变量就开始运行垃圾收集器,这样就不得不频繁地运行,从而降低了性能; // 一般来说,确保占用最少的内存可以让页面获得更好的性能;// 最佳方案:一旦数据不再使用,将其值设置为null来释放引用,这个做法叫做解除引用;  var o = {    name:'lee';  };  o = null;               // 解除对象引用,等待垃圾收集器回收;</span>
```





## 三 小结 

**

1.变量
// JS变量可以保存两种类型的值:基本类型值和引用类型值;它们具有以下特点:
// 1.基本类型值在内存中占据固定大小的空间,因此被保存在栈内存中;
// 2.从一个变量向另一个变量复制基本类型的值,会创建这个值的一个副本;
// 3.引用类型的值是对象,保存在堆内存中;
// 4.包含引用类型值的变量实际上包含的并不是对象本身,而是一个指向该对象的指针;
// 5.从一个变量向另一个变量复制引用类型的值,复制的其实是指针,因此两个变量最终都指向用一个对象;
// 6.确定一个值是哪种基本类型可以使用typeof操作符;而确定一个值是哪种引用类型可以使用instanceof操作符;

2.作用域
// 所有变量都存在于一个执行环境(作用域)中,这个执行环境决定了变量的生命周期,以及哪一部分代码可以访问其中的变量;
// 1.执行环境有全局执行环境和函数执行环境之分;
// 2.每次进入一个新执行环境,都会创建一个用于搜索变量和函数的作用域链;
// 3.函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其父环境，乃至全局环境；
// 4.变量的执行环境有助于确定应该合适释放内存;

3.内存
// JS自动垃圾收集机制
// 1.离开作用域的值将被自动标记为可以回收,因此将在垃圾收集期间被删除;
// 2.为了确保有效地回收内存,应该及时解除不再使用的全局对象/全局对象属性以及循环引用变量的引用;







# 第5章基本引用类型

引用类型的值（对象）是引用类型的一个实例，它是一种数据结构，用于将数据和功能组织在一起，也常被称为类。

## 一、Object类型

1.创建方式：
（1）new+操作符

```css
        var person = new Object();
        person.name = "lili";
        person.age = "18";
123
```

（2）对象字面量

```css
        var person = {
            name : "lili",
            age : 18
        };
        或
        var person = {};
        person.name = "lili";
        person.age = "18";        
12345678
```

2.访问对象属性
（1）person[“name”]
（2）person.name(常用)

## 二、Array类型

1.创建数组
（1）Array构造函数

```css
        var colors = new Array();
        
        //创建length为20的数组
        var colors = new Array(20);
        
        //直接初始化数组
        var colors = new Array("red","pink","blue");
		//省略new操作符
		var colors = Array("gray");
		var colors = Array(3);
12345678910
```

（2）使用数组字面量（数组字面量由一对包含数组的方括号表示）

```css
        var colors = ["red","pink","blue"];
        var colors = [];		//创建一个空数组
12
```

2.引用数组元素：数组名 [ 索引 ] ;

## 三、Date类型

显示日期和时间的方法。

## 四、RegExp类型

RegExp类型支持正则表达式。
**1.正则表达式的匹配模式：**
g：全局模式，将此模式应用到所有字符串
i：不区分大小写模式，即匹配时忽略匹配项的大小写
m：多行模式，与多行文本进行匹配
**2.创建正则表达式**
（1）使用字面量形式：
var 变量名 = / 目标字符串 / 匹配模式
（2）创建RegExp构造函数：
变量名 = new RegExp（“字符串”，“匹配模式”）；

## 五、Function类型

**1.函数的定义**
（1）通过函数的声明：

```css
function 函数名(任意数量的参数){
	语句;
}
123
```

对于（1），调用语句可以在任何位置，因为解析器会率先解析函数的声明
（2）使用函数表达式

```css
        var 变量名 = function(参数列表){
            语句;
        };
123
```

对于（2），调用语句只能在函数表达式后面，否则会出现错误
（3）使用Function构造函数（不推荐）

## 六、基本包装类型

Boolean、Number、String
每当读取到一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们调用一些方法来操作这些数据。
**引用类型与基本包装类型的区别是生存期**：基本包装类型为其创建的属性和方法存在于一瞬间，然后立即被销毁。

## 七、单体内置对象

Clobal、Math
1.Global对象：所有在全局作用域中定义的属性和函数都是Global对象的属性。
2.Math对象：保存着数学公式和信息。









# 第6章  集合引用类型

今天无由的在博客上开了一个‘随写知识点总结’，目的呢，就是想每次遇到基础知识点，会积累系统全面的总结知识点，加深自己的根基，也方便 
以后的知识复习及查询。 

切入正题，今天个人总结的是js数据类型的引用类型的Array对象 

## 1.什么是数组？ 

数组是值的有序集合，而且可以存放js各种数据类型，因为js是弱类型的语言，所以不像其他语言数组只能存放特定的数据类型 
 注意：1. ECMAScript语言中的数组是可以动态变化的（因为是js的数组的数值存储采用链式结构存储） 
    2.Array数组是数据的有序列表。所以数组里的数值都有特定的索引值 
    3.ECMAScript同一个数组中可以存储不同类型的数据； 
    4.每个数组都有一个length属性 

## 2.数组的创建 

1.使用new Array()方法 
      创建未知长度的数组  var arr1=new Array(); 
      创建数据长度    var arr2=new Array(20); 
      创建存放元素的数组  var arr3=new Array(20,10,'hello',null,undefined) 
    2.使用Array()方法 
    3.使用字面量创建，也是以后最常用创建的方法 
      var arr4=[1,2,4]; 

## 3.数组元素的读和写 

通过下标来读取数组的值  arr[5]='hello' 

## 4.数组的长度：length属性 

通过数组的length属性来获取数组的长度  arr=['h','dsa','as'];arr的长度为arr.length 

## 5.检测数组 

判断是否是数组，使用Array.isArray(要判断的变量), 但值得注意的是：（typeof 要判断变量）或（typeof(要判断的变量)格式判断的是基本数据类型，即局限性就是在于基本数据类型，引用类型都是返回object 

## 6.数组方法 

### 1.将数组转为字符串的方法

   1>toString()方法，形如：arr.toString(),数组元素转为字符串，数组元素默认以“，”来分隔    2>join('符号'),形如：arr.join('+')使用指定符号来分隔元素
   1>push()方法，形如：arr.push('新元素1'，'新元素二'),从数组末尾的位置添加新元素，并返回数组的长度


### 3.数组开头操作增减

   1>shift()方法，形如：arr.shift()删除数组开头第一个元素，并返回删除的元素    2>unshift()方法，形如：arr.unshift()在数组开头添加一个元素
   形如：var arr1=arr.concat('数组元素'，’另外一个数组’)根据现有数组创建新数组，即原数组添加元素或者一个数组而产生新的数组
    形如：var arr1=arr.slice(开始下标，结束下标[可选])，注意：截取不包含结束下标，根据当前数组中一个或多个元素创建另一个数组

### 6.splice()方法

​    对数组的增删改操作，形如：arr.splice(起始下标位置，要删除的元素个数，要插入的元素) 注意：当要删除的元素个数为0，就是对数组增操作       eg.var arr1=[1,23,12,45,3];arr1.splice(2,0,'red')
​       var arr3=[1,23,12,45,3];arr3.splice(0,3,'green')
​    获取数组元素的下标，形如：arr.indexOf(要查找的元素，要搜索的起始位置[可选])

## 7.二维数组 

数组元素其实也是一个数组 

## 8.数组元素的遍历 

使用for循环遍历 

## 9，数组实现对数组的排序 

列举常用的方法： 

###      1>使用冒泡排序

代码如下： 
       

```javascript
//定义一个排序函数，第一个参数是需要排序的数组，第二个参数是以哪种方式排序              //true代表升序，false代表降序              function(arr,isAscend){                  for(var i=0;i<arr.length-1;i++){                      for(var j=0;j<arr.length-i;j++){                          var temp;                          if(isAscend){                              if(a[j]>a[j+1]){                                temp=a[j];                                a[j]=[j+1];                                a[j+1]=temp;                              }                          }else{                              if(a[j]<a[j+1]){                                temp=a[j];                                a[j]=[j+1];                                a[j+1]=temp;                              }                          }                      }                  }                  return arr;              }
```



### 2>使用自定义的排序函数结合sort()实现排序

代码如下： 

```javascript
function sortArray(arr,isAscend){                      //这是一个升序函数                      function compare1(value1,value2){                        if(value1>value2){                            return 1;                        }else if(value1=value2){                            return 0;                        }else{                            return -1;                        }                      }                      //这是一个降序函数                      function compare2(value1,value2){                        if(value1<value2){                            return 1;                        }else if(value1=value2){                            return 0;                        }else{                            return -1;                        }                         //如果传入的参数，需要升序就调用compare1函数，否则调用compare2函数                        if(isAscend){                          arr.sort(compare1);                        }else{                          arr.sort(compare2)                        }                       }                   }
```



### 3>快速排序算法

原理思路： 
          1.在数据集之中，找个基准点 
          2.建立两个数组，分别存储左边和右边 
          3.利用递归进行下次比较 

```javascript
function quickSort(arr){                      if(arr.length<=1){   //如果数组只有一个数，就直接返回  ,递归的终止条件                        return arr;                      }                      var num=Math.floor(arr.length/2);//找到中间的索引值，如果是浮点数，则向下取整                      var newValue=arr.splice(num,1);  //找到中间数的值                      var left=[],right=[];                      for(var i=0;i<arr.length;i++){                        if(arr[i]<newValue){                          left.push(arr[i]);   //基准点的左边的数传到左边数组                        }else{                          right.push(arr[i]);                        }                      }                      return quickSort(left).concat(newValue,quickSort(right));                    }                    console.log(quickSort([12,2,3,12,2,11,1,34]));
```





# 第7章  迭代器与生成器

迭代器和生成器可能对于一些人来说知道是什么东东，但是并没有比较深入的了解，那么今天，就跟随我来了解一下这两者的概念，关系及优点，我将使用python中的迭代器和生成器作为演示，如果你不懂python没关系，明白了概念，剩下的就只是编程语言的差异了！这一点很关键，再啰嗦一句，不要为了编程而编程，也要明白一些概念性的东西，编程语言只是工具！

## 1.从循环开始说起

想必大家在学习编程的时候，肯定学到过for循环，while循环，do…while循环等等，那么我们为什么需要循环操作呢？因为有些时候我们希望计算机为我们重复的执行同样的操作，比如我有一个“数组”，里面存储了100个同学的id，那么我则会对这个数组进行循环操作，然后挨个输出。当然还有很多其他地方需要循环操作，这里我只是举个例子。

所以，循环操作是计算机编程语言中必不可少的组成部分，那么请大家用几秒钟时间回想一下，我们之前曾经写过的循环操作for循环，while循环。我们往往需要初始化一个变量i，还得声明一个条件比如i<100，然后循环完每一步之后做什么，比如(下方伪代码):

```
for(i = 0; i < 100; i++) {	}
```

我们可以很容易的用这种循环来遍历一个数组，希望大家学过数据结构，因为数组在内存中的存储是连续的！我们可以通过数组的“下标”(其实是相对于数组第一个元素的位置)来进行访问数组中的元素，所以在很多时候，我们通过for循环来遍历数组(下方伪代码):

```
for(i = 0; i < arrLength; i++) {	}
```

那么如果我现在问你，你怎么进行遍历一个没有在内存中连续存储的“数据结构”呢，比如python中的“字典”，javascript中的”对象“，又比如你自己写了一个”树“结构的类，想遍历整个树的节点？那么传统的for循环，while循环就无法发挥他们的作用了，这个时候我们就应该引入”迭代器“了。

所以，小结一下，”迭代器“其实目的也是为了”循环“，更严谨一些，是为了“遍历”，你可以把迭代器看成比普通循环更高级别的工具，普通循环能搞定的迭代器也能搞定，普通循环搞不定的迭代器还能搞定，并且使用迭代器比普通循环效率更高，这个我们后面说到生成器的时候会提到。

## 2.迭代(iteration)/可迭代(iterable)/迭代器(iterator)

我想大多数人可能和我一样，刚开始对这些概念/名词都很模糊，那么让我们一起弄明白他们。

大家先要知道“协议”（protocol）的意思，其实协议是用来“规范/标准化”你“创造的东西”的。比如，你开天辟地的发明了一种东西叫做“吧啦哔哩”，你给小明说：“小明，给我发一个吧啦哔哩过来”，如果小明不知道啥叫“吧啦哔哩”，那么小明会直接懵逼的。这时候你就要定一个“协议”如下：

1， “吧啦哔哩”一共有10个字
2， “吧啦哔哩”开头和结尾都是”#”号 (占两个字)
3， “吧啦哔哩”最后四位是”blbl”
4, 其他随便

那么我们根据这个协议，可以很轻易的构造出“吧啦哔哩”来：#1234blbl# 或者 #8888blbl#

同样，我们根据这份协议，就可以用来检测你得到的是不是“吧啦哔哩”，#1234blbl# -> 是，#1234blbl！-> 不是

迭代(iteration)

明白了上面的东西，下面我们就开始“迭代”之旅，迭代顾名思义，就是重复的的既定的任务，直到完成。所以，为了完成迭代，我们需要一个迭代器！那么什么是迭代器呢？来看看迭代器的协议吧

## 3.迭代器协议 iterator protocol

从前有个人发明了迭代器，为了让大家明白什么是迭代器，他就写了这个协议，那么协议的内容简而言之就是一句话：如果一个对象包括一个叫”next”(python3 为__next__)的方法，那么这个对象就叫做“迭代器”。

好了，那么我们根据这个协议可以创建一个迭代器(iterator)

```
class Counter:	def __init__(self):		self.index = 0 	def __next__(self):		i = self.index		if i < 10:			self.index += 1			return i
```

这个Counter就是一个迭代器，但是目前它没有什么太大的作用，因为我们不可能每次通过手动调用__next__方法来进行操作。

好消息是，很多编程软件为我们提供了一个“语法糖”(syntactic sugar)，让这个语法糖来替我们反复执行__next__方法，比如python中的”for.. in”，但是，为了让这个反复执行的过程停下来，我们同样需要定义一个终止信号，在python中，终止信号就是抛出一个StopIteration的“例外”(exception)，来告知我们的语法糖：”好啦，没东西可以迭代了，可以停了“，这样迭代就终止了。

所以我们再进一步规范一下我们创建的迭代器成如下形式：

```
class Counter:	def __init__(self):		self.index = 0 	def __next__(self):		i = self.index		if i < 10:			self.index += 1			return i		else:			raise StopIteration
```

好了，我们来试一下：

```
counter = Counter() for i in counter:	print(i)
```

不妙，报错了。。

```
TypeError: 'Counter' object is not iterable
```

错误显示说：这个Counter对象不是可迭代的！这是什么意思呢？

原来，为了使用这个for..in 迭代语法糖，我们需要在in后面放可以迭代的“迭代器”，什么是可以迭代？你可以认为就是可以使用for..in语法糖，让语法糖帮你重复调用next方法就好了。如果不可以迭代， 那么for..in这个语法糖就无法为我们自动调用next方法。

所以说，为了使用for..in语法糖来进行迭代我们的迭代器，你必须让你的迭代器可迭代(有点绕。。哈哈)。

这句话有两层含义： 1，为了使用for..in语法糖，你必须让你的迭代器可迭代 2，你如果不适用for..in语法糖，你就不必让你的迭代器可迭代，你可以自己写一个语法糖，不断地调用next方法，当遇到StopIteration例外的时候停止罢了。

但是当你使用别人(编程语言)实现编写好的语法糖时，你就必须按照他们的规则走。

好了，我们现在明白了，通常来讲，当我们要创建了一个迭代器时，我们还“必须”(注意是必须)让迭代器可迭代，这样理解：因为一个不可迭代的迭代器是没有意义的！

**所以，注意！从现在开始到文章结束，我所说的“迭代器”都是“可迭代”的迭代器！**

那么怎么让我的迭代器可迭代呢？同样，来看什么是“可迭代协议”(iterable protocol）

## 4.可迭代协议 iterable protocol

在python中，为了使一个”对象“可迭代：
1，这个迭代器必须同时包含另一个方法叫做“**iter**”
2，这个”**iter**“方法还得返回一个”迭代器“(可迭代)

请注意，上面我说的是：为了使一个”对象“可迭代，这里，对象可以指我们刚刚创建的”Counter“迭代器，也可以是其他的对象。

来个栗子： 为了使我们刚才创建的Counter迭代器对象“可迭代”，那么： 1，我们就在这个Counter对象里面添加一个叫__iter__的方法 （可迭代化操作） 2, 让这个__iter__方法返回一个“可迭代的迭代器” (这里就是自己了！)

```
class Counter:	def __init__(self):		self.index = 0 	def __iter__(self):		return self 	def __next__(self):		i = self.index		if i < 10:			self.index += 1			return i		else:			raise StopIteration counter = Counter()for i in counter:	print(i)
```

Cool! 这个时候我们得到了0，1，2，3，4，5，6，7，8，9的迭代！

这里简单说一些执行步骤，当我们使用for..in语法糖的时候，它先调用__iter__方法，得到返回的迭代器，然后连续调用该迭代器的__next__方法，知道遇到StopIteration例外

我上面也提到了，我们不仅可以使迭代器“可迭代”，我们也可以使普通的对象“可迭代”，只需给该对象添加一个__iter__的方法，然后返回一个可迭代的迭代器就好了！

这里顺便插一句！在python中，我们可以使用”iter”这个函数来返回一个“可迭代的迭代器”。

比如：

```
x = iter([1, 2, 3])print(x) #<list_iterator object at 0x10c828550>x.__next__() # 返回 1x.__next__() # 返回 2x.__next__() # 返回 3x.__next__() # 返回 StopIteration
```

所以，我们可以让一个普通对象可迭代，而不一定非得是迭代器。

```
class Name:	def __iter__(self):		return iter(['zhangsan', 'lisi', 'wangwu']) name = Name()for n in name:	print(n)
```

不错！我们得到了zhangsan, lisi, wangwu

现在逻辑不是很复杂的情况之下，这种创建迭代器的方式还是能够接受的，但是如果逻辑复杂，以及用这种模式多了，每次这么定义就不是很方便，于是为了“简化”创建迭代器的过程，“生成器”generator就出现了。

## 5.生成器generator

生成器的出现，就是为了简化创建迭代器的繁杂，同时又要保证逻辑的清晰，说到底生成器就是为了更方便我们使用迭代器而生的，生成器的特性如下：

1, 生成器的样子就是一个普通的函数，只不过return关键词被yield取代了
2, 当调用这个“函数”的时候，它会立即返回一个迭代器，而不立即执行函数内容，直到调用其返回迭代器的next方法是才开始执行，直到遇到yield语句暂停。
3, 继续调用生成器返回的迭代器的next方法，恢复函数执行，直到再次遇到yield语句
4, 如此反复，一直到遇到StopIteration

看如下例子：

```
def gFun():	print('before hello')	yield 'hello'	print('after hello') a = gFun() # 调用生成器函数，返回一个迭代器并赋给a print(a) # <generator object gFun at 0x104cd2a40> 得到一个生成器对象(迭代器)print(a.__next__())# before hello# helloprint(a.__next__())# after hello# StopIteration
```

同时因为调用生成器函数返回的是一个迭代器，所以我们可以使用for..in语法糖对其进行迭代操作：

```
a = gFun()for x in a:	print(x)
```

迭代返回了before hello, hello, after hello

## 6.使用迭代器/生成器的好处

首先快速看一段代码：

```
def firstn(n):	num, nums = 0, []	while num < n:		nums.append(num)		num += 1		return nums sum_of_first_n = sum(firstn(1000000))
```

这段代码定一个了一个函数firstn，该函数接受一个参数n，返回n之前所有的整数，最后对这些整数进行求和。 这个代码使用了我们传统的while循环，如果接受的参数n比较小还好，但是当接受的参数很大时，对内存的消耗就凸显出来了，因为在执行该函数的过程中， nums这个大的列表会全部存在于内存中。并且求和运算只有当nums列表完全构建完成之后才可以进行运算，效率也高。

而用迭代器(生成器)的方法则会大大提高效率，一方面每次next循环都会yield出一个值，供sum函数累加使用，这样就不用占用很大的内存，另一方面，使用迭代器/生成器也不用完全等到前n个数全部遍历完再进行累加，效率更高！







# 第8章   对象、类与面向对象编程

## 一，什么是面向对象

**常见的几种思想**

1. 面向过程：（没有类，没有对象，在C语言中有用）
2. 面向对象（在Java、C++、JS中都有使用）
3. 面向切面（spring IOC AOP）

## 二，JS面向对象的几种特征以及类和对象

### 1，面向对象的几种特征

1. 抽象：把具体的问题抽象化；
2. 封装：把属性和方法封装在类中，如

```javascript
var obj = {
                name:"wc",
                age:100,
                say:function(){
                    log("say...");
                }
            }
1234567
```

1. 继承：一个类可以继承另一个类，在JS中，类是通过函数表达式来定义；
2. 多态：暂时不多说；

### 2，面向对象中的类和对象

1. **类：** JS中的类的本质还是一个函数，是抽象的，而不是具体的；如下

```javascript
function Person(){  // 是一个类的话，首字母会大写 
            }
     new Person(); // 此时Persion是一个类
     Person(); // 此时Person就是一个函数
1234
```

- **对象：** `var obj = {name:"wc"};` 此时obj就表示一个对象，在JS中一个{ }就是一个对象；

## 三，JS中默认存在的类（常见的）

### 1，Number类

```javascript
var n = new Number("100");
    console.log(n); // Number {100}
    console.log(typeof n); // object（对象）
    // instanceof 是一个运算符  判断一个对象是否属性某个类
    console.log(n instanceof Number);  // true（表示n属于Number类）
12345
```

### 2，String类

```javascript
var str = new String("hello oop");
    console.log(str)  // {"hello oop"}
    console.log(typeof str)  // object（对象）
    console.log(str instanceof String);  // true（表示str属于String类）
    console.log(str instanceof Number);  // false（表示str不属于String类）
12345
```

### 3，Boolean构造器（JS中构造器也叫类）

```javascript
var f = new Boolean(false);
    console.log(f)  // {false}
    console.log(typeof f)  // object
    console.log(f instanceof Boolean)  // true
1234
```

### 4，Object构造器（存在语法糖）

**第一种写法**

```javascript
var obj = new Object();  // new一个构造器得到一个对象
    obj.name = "wc";
    obj.age = 110;
    console.log(obj); // {name: "wc", age: 110}
1234
```

**第二中写法**：是第一种写法的语法糖（就相当于上面写法的简写，方便了程序员）

```javascript
var obj2 = {  // 字面量形式声明一个对象
        name:"xiaoqiang",
        age:100
    }
1234
```

### 5，Data类

```javascript
var d = new Date();
    console.log(d); 
    console.log(d.getFullYear()) //只获取年份，属于对象中默认的方法；
123
```

### 6，Math类（不需要new）

- **属于单体内置类，常驻内存不需要new**

```javascript
var r = Math.random(); 
    console.log(r); //输出一个随机数
12
```

### 7，Array类

```javascript
var arr = new Array("a","b","c");
    console.log(arr); // 输出["a", "b", "c"]
    // 是上面的形式的语法糖
    var arr2 = ["d","e","f"];  // 字面量创建数组（对象）
    console.log(arr2); // ["d", "e", "f"]
12345
```

## 四，JS中的对象及函数

### 1，证明：JS中的一切数据都是对象

> **JS中的HTML元素标签、数组、函数、基本数据类型、console等等 均是对象**

**数组是对象证明：**

```javascript
var arr = ["a","b","c"]; // 也是Array这个类
    console.log(arr); // ["a", "b", "c"]
    console.dir(arr); //console.dir(arr)显示arr对象所有的属性和方法。
    console.dir(typeof arr); // object
    console.log(arr.length); //打点调用，表明arr对象中有length方法；
    arr.push("d"); //加入数据“d”
    console.log(arr); //["a", "b", "c", "d"]
    console.log(arr instanceof Array); // true  表名arr属于Array类
12345678
```

**函数也是对象证明：**

```javascript
function f(a,b) {
        console.log("f...")
    }
    console.dir(f)
    console.dir(f.name)
    console.dir(f.length)
    console.log(f instanceof Function); // true 函数属于Function类
    console.log(typeof f); // function
12345678
```

**基本数据类型也是对象证明：**

```javascript
 var a = 110; // 现在要证明a也是对象
    console.dir(a);  // 110
    console.log(typeof a) // number
    console.log(a instanceof Number) // false
    // 如果a不是对象  是不可能打点调用toFiexed
    console.log(a.toFixed(3)); // 110.000
    // 上面的a叫包装对象
    // 上面调用toFixed时，它会把a瞬间包装成一个对象
    var str = "hello";
    console.log(str.length);  // 5  str也是瞬间包装成对象了
    console.log(str.toUpperCase()); // HELLO 如果str不是对象  是不可能打点调用toUpperCase
1234567891011
```

**console、window也是对象证明：**

```javascript
console.log("wc") //打点调用，如果console不是对象，则不会调用log
console.dir(console)
console.log(console instanceof Object)  // true
console.dir(window)
console.log(window instanceof Window)  // true
12345
```

### 2，对象是属性的无序集合

> 在访问集合中的属性时，键是可以使用引号给包起来，也可以不包；调用属性有两种方式：
>
> - 打点调用
> - 通过[ ]来调用；（通常不使用这种方式）

```javascript
var obj = {
        name:"wangcai",  // name叫属性名  “wangbai"叫属性值
        123:456, // 123是属性名(键)，456是属性值（值）
        "1+1":2, // "1+1"是属性名   2是属性值
        "a":"hello",
        "b":null,
        "c":function () {
            console.log("c..")
        },
        "d":["1","2","3"],
        "e":{ x:"xxx" }
    }
    console.log(obj.name)
    console.log(obj[123]); // 必须使用[ ]给属性名包起来，输出456
    console.log(obj.a); // hello
    console.log(obj["1+1"]); // 2
    // 如果我们的键是一个变量  我们需要通过变量去访问  必须使用[]
    var k = "name";
    console.log(obj[k]); // wangcai
12345678910111213141516171819
```

- 访问一个对象中不存在的属性时，输出结果为undefined；如下

```javascript
var obj = {};
 console.log(obj.name)
12
```

### 3，对象属性的增删改查

### （1）对象属性的遍历（for in）

存在一个对象：

```javascript
 var obj = {
        name:"wangcai",
        age:100,
        say:function () {
            console.log("say...")
        }
    }
1234567
```

对上面对象遍历：

```javascript
for (var key in obj) {  // 通常遍历一个对象使用for in
        // key是一个变量
        console.log(obj[key])
    }
1234
```

- 使用for in有时候不能对属性全部遍历出来

```javascript
let arr = ["a","b","c"];
    console.dir(arr)；//还有个length属性
    for (const key in arr) {  // 使用for in 并不能遍历出一个对象中所有的属性  如数组中的length和__proto__
       console.log(arr[key])
    }
12345
```

### （2）对象属性的增删改

- 添加、修改属性：

```javascript
var obj = {
        name:"wangcai"
    }
    console.log(obj.name); // 打印出obj中的name属性  访问
    obj.name = "xiaoqiang"; // 修改属性
    console.log(obj.name);  // 同名属性后面的会把前面的覆盖掉
    obj.age = 1100; // 新增属性
    obj["address"] = "北京"; //  新增属性
    console.log(obj)
123456789
```

- 删除对象属性

```javascript
var obj = {
        name:"wangcai",
        age:100
    }
    console.log(obj)
    // delete 是一个运算符 是单目运算符
    delete obj.age; //只能删除私有属性，而不能删除公有属性；
    console.log(obj); //{name: "wangcai"}
12345678
```

- 再删除对象属性的时候，有一些情况是不能删除的；

```javascript
	var a = 110;  // var的变量放到GO中，是不能删除的，因为GO中有一个属性的设置使a不能删除；（后面有相关属性的介绍）
    console.log(window.a)
    delete window.a;
    console.log(window.a)
    
    b = 666;  // 没有加var的变量  默认是可以删除的
    console.log(window.b) // 666
    delete window.b;
    console.log(window.b) // undefined

    let c = 111;
    delete c;  // delete用来删除一个对象上的属性
    console.log(c)
12345678910111213
```

## 4，对象中属性的四大特征

### （1）configurable（是否删除）

> 表示该属性是否可以被删除，true表示可以删除；

### （2）writable（是否修改）

> 表示是否可以对属性进行修改，true表示可以修改；

### （3）enumerable（能否输出）

> 是否可以枚举，就是是否可以输出，是否可以遍历；

### （4）value（属性值，默认undefined）

**在获取对象中的属性的特征时，是通过Object.getOwnPropertyDescriptor 获取属性的特征的**

- 获取obj对象中的name属性：

```javascript
console.log(Object.getOwnPropertyDescriptor(obj, "name"));
//得到四个属性分别为：
// configurable: true  可以删除
// writable: true  可以修改
// enumerable: true  可以输出（遍历）
// value: "wangcai"  默认值
123456
```

- 获取数组对象中的length属性：

```javascript
var arr = ["a"] 
console.log(Object.getOwnPropertyDescriptor(arr, "length"));
//得到四个属性分别为：
// configurable: true  可以删除
// writable: true  可以修改
// enumerable: false  不可以输出（就是上面所提到的使用for in不能遍历出length属性）
// value: "wangcai"  默认值
1234567
```

**在给一个对象添加一个属性时，也可以自己设置上面的4个特征，使用Object.defineProperty()**

- 给obj对象添加一个name属性，自行设置四个属性：

```javascript
var obj = {};
    Object.defineProperty(obj,"name",{
        configurable:false, //不能删除
        writable:false,  //不能修改
        enumerable:true, //能输出
        value:"wangcai"  //默认值
    })
    console.log(obj) //{name: "wangcai"}
    delete obj.name; 
    console.log(obj); //{name: "wangcai"}
    obj.name = "xxx"; 
    console.log(obj); //{name: "wangcai"}
    for (const objKey in obj) {
        console.log(obj[objKey]); //wangcai
    }
123456789101112131415
```

## 5，对象属性的分类

> 对象上的属性分为两类：
>
> - 私有属性（也叫原型属性）
> - 共有属性

- 对于一个对象可以通过api来查看一个属性是否为私有属性；**api是hasOwnProperty();**
- 如果一个私有属性和公有属性重名了 会把公有属性覆盖掉

```javascript
var obj = {
        name:"wangcai",
        age:100
    }
console.log(obj.hasOwnProperty("name")); // true 查看obj对象中的name属性是不是obj的私有属性，true表示是
console.log(obj.hasOwnProperty("age"));  // true 查看obj对象中的age属性是不是obj的私有属性，true表示是
// 对于obj来说：name和age是它的私有属性  toString是它的公有属性
// 对于obj.__proto__来说：toString是它的私有属性
console.dir(obj.hasOwnProperty("toString")); // false 查看toString是否是obj的私有属性
console.log(obj.hasOwnProperty("__proto__")); // false 查看__proto__是否是obj的私有属性
console.log(obj.__proto__.hasOwnProperty("toString")); // true  // 查看toString是否是obj.__proto__这个对象的私有属性
1234567891011
```

- 判断一个属性是否属于某个对象（**hasOwnProperty**）：
- **in** ：是一个运算符，是公有属性，得到的也是true；

```javascript
var obj = {
        name:"wangcai"
    }
console.log(obj.hasOwnProperty("name"));// 判断name是否是obj的私有属性  true表示是
console.log("name" in obj); // 判断name是否是obj的属性 true表示是
console.dir(obj) //查看对象中的所有属性
console.dir("toString" in obj) // 判断toString是否是obj的属性  true
console.dir("xxx" in obj) // 判断xxx是否是obj的属性  false
12345678
```

## 6，对象都是由函数创造的

- 一个函数具有多个角色：

1. 普通的函数；
2. 类（构造器）构造器的本质就是函数；
3. 对象；

> 构造器：Array、Number都是构造器；
> 对象：标签 、Number、new Number、Document、Window、console、Array、new Array、Function、new Function等等

- 任何一个对象都有一个属性叫`__proto__`此属性也是一个对象，该对象中有一个属性叫做

```javascript
//constructor 是构造器；
console.log([1,2,3].__proto__.constructor == Array); // true 表示对象[1,2,3]的构造器就是Array；
console.log({}.__proto__.constructor == Object); // true 表示{}的构造器就是Object；
console.log(function () {}.__proto__.constructor == Function); // true 表示function () {}的构造器就是Object；
1234
```

1. 对象是由函数创建的 / 对象是由构造器构造的；
2. 构造器本质是函数；
3. 如果你把一个函数当作是一个构造器，一般情况下，首字母大写；
4. 任何一个函数都可以充当一个构造器；

## 7，函数的四种使用方式

1. 作为普通的函数；

```javascript
function f() {
        console.log("f...")
    }
   f();   // 作用1：让函数体执行    作用2：得到返回值
1234
```

1. 在对象中作为一个方法；

```javascript
let obj = {
        say:function () {  // 方法
            console.log("say...")
        },
      }
    obj.say();
123456
```

1. 作为类（构造器）；

```javascript
function NBAPlayer() {
    }
    var nbaPlayer = new NBAPlayer();//作为类，new一个新对象
123
```

1. 作为一个对象；

```javascript
function F() {
    }
    F.name1 = "wangcai"; //插入数据
    F.age = 100; //插入数据
    console.log(F.name1) //输出wangcai
    console.log(F.age) //输出100
123456
```

## 8，JS中创建对象的几种方式

> 1. 使用字量面的方式创建一个对象
> 2. 使用工厂模式创建对象
> 3. 通过构造器+原型对象来创建对象
> 4. 通过构造器+原型对象来创建对象

### **1. 使用字量面的方式创建一个对象**

```javascript
 var rect = {
        width:10,
        height:20,
        getS(){
            return this.width * this.height
        }
    }
    rect.getC = function(){
        return 2*this.width + 2*this.height;
    }
    console.log(rect.getS());  // 200
    console.log(rect.getC());  // 60
123456789101112
```

### **2. 使用工厂模式创建对象**

- 优点：可以批量创建对象

```javascript
 function createRect(w,h) {  // 工厂函数
        var obj = {};
        obj.width = w;
        obj.height = h;
        obj.getS = function () {
            return this.width * this.height
        }
        return obj;
    }
    var rect1 = createRect(1,2);
    console.log(rect1.getS());
    var rect2 = createRect(2,2);
    console.log(rect2.getS());
12345678910111213
```

### **3. 通过构造器+原型对象来创建对象**

```javascript
function Rect(w,h) {
        this.w = w; // 私有属性
        this.h = h; // 私有属性
    }
    Rect.prototype.getS = function () {  // 将方法当成一个公共属性
        return this.w*this.h;
    }
    // rect1 rect1是通过Rect构造器构造的
    var rect1 = new Rect(1,2);
    console.log(rect1.getS());
    var rect2 = new Rect(3,2);
    console.log(rect2.getS());
123456789101112
```

### **4. ES6中通过class创建类 new新对象**

```javascript
class NBAPlayer{
        constructor(name,age) {
            this.name = name;
            this.age = age;
        }
        score = 100; // 私有属性
        run(){   // 公有方法
            console.log("run....")
        }
        static xx = "123"; // 类上的属性  静态属性
    }
    var nbaPlayer1 = new NBAPlayer("乔丹",40);
    console.log(nbaPlayer1.name) //乔丹
    console.log(nbaPlayer1.age) //40
    console.log(nbaPlayer1.score) //100
    console.log(nbaPlayer1.run()) //run...   undefined（函数调用时没有返回值，就返回undefined）
    console.log(nbaPlayer1.xx) //undefined
    console.log(NBAPlayer.xx) //123 （静态属性只能通过类名去调用）
```





### 5.继承

#### **1.继承

继承，指一个对象直接使用另一对象的属性和方法。
JS里常用的有如下两种继承方式：
原型链继承（对象间的继承）
类式继承（构造函数间的继承）

#### 2.知识剖析

JavaScript语言的对象体系，不是基于“类”，而是基于构造函数（constructor）和原型（prototype）。
\*  原型对象：只要创建一个新函数，就会根据特定的规则为该函数创建一个prototype属性指向其原型对象，默认情况下原型对象会自动获得一个constructor属性，该属性包含一个指向prototype属性所在函数的指针。

```
Function.prototype.constructor === Function        //true
```

\*  构造函数：本身是一个函数，出于创建特定类型新对象的目的而定义的，内部使用this变量，需要和new配合使用来创建实例，this变量会绑定在实例对象上。

 **demo:**

```
    var f = function(){}     f.prototype.constructor === f         //true
```

#### 3.常见问题

常见的继承方式有哪些？如何实现？

#### 4.解决方案

**方法一：原型链**
原型链的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的指针。如果：我们让原型对象A等于另一个类型B的实例，那么原型对象A就会有一个指针指向B的原型对象，相应的B的原型对象中保存着指向其构造函数的指针。假如B的原型对象又是另一个类型的实例，那么上述的关系依旧成立，如此层层递进，就构成了实例与原型的链条。
注意： 通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样做会重写原型链。 
问题： 原型链很强大，可以利用它来实现继承，但是也有一些问题，主要的问题还是包含引用类型值的原型属性会被所有实例共享。因此我们在构造函数中定义实例属性。但是在通过原型来实现继承时，原型对象其实变成了另一个类型的实例。于是原先定义在构造函数中的实例属性变成了原型属性了。 
原型链的另一个问题是： 在创建子类型的实例时，不能在不影响所有对象实例的情况下，给超类型的构造函数传递参数。

**方法二：构造函数**
为了解决原型中包含引用类型值带来的一些问题，引入了借用构造函数的技术。这种技术的基础思想是：在子类型构造函数的内部调用超类型构造函数。 
<!-- Parent.call(this)在新创建的Child实例环境下调用Parent构造函数。这样，就在新的Child对象上，此处的kid1和kid2对象上执行Parent()函数中定义的对象初始化代码。这样，每个Child实例就都会具有自己的friends属性的副本了。 -->
借用构造函数的方式可以在子类型的构造函数中向超类型构造函数传递参数。 
构造函数模式的问题： 在于方法都在构造函数中定义，函数复用无从谈起，因此，借用构造函数的模式也很少单独使用。

**方法三：组合继承**
组合继承指的是将原型链和借用构造函数的技术组合在一块，从而发挥二者之长。即：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。 
<!-- Person构造函数定义了两个属性：name和friends。Person的原型定义了一个方法sayName()。Child构造函数在调用Parent构造函数时，传入了name参数，紧接着又定义了自己的属性age。然后将Person的实例赋值给Child的原型，然后又在该原型上定义了方法sayAge().这样，两个不同的Child实例既分别拥有自己的属性,包括引用类型的属性，又可以使用相同的方法了。 -->
组合继承避免了原型链和构造函数的缺陷，融合了他们的有点，成为JavaScript中最常用的继承模式。而且，instanceOf和isPropertyOf()也能够识别基于组合继承创建的对象。

**方法四：原型式继承**
这是另一种继承，没有严格意义上的构造函数。思路是：借助原型可以基于已有的对象创建新对象，同时还不必要创建自定义类型。
在object()函数内部，先创建一个临时的构造函数，然后将传入的对象作为构造函数的原型，最后返回这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。

**方法五：寄生式继承**
寄生式继承是与原型式继承紧密相关的一种思路，与寄生式构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。
使用寄生式继承来为对象添加函数，会由于不能做到函数的复用而降低效率；这一点和构造函数继承模式类似。

**方法六：寄生组合式继承**
所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链来继承方法。寄生组合式继承的基本思路：不必为了指定子类型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承超类型的原型，然后再将结果指定给子类型的原型。

```
function inheritPrototype(child, parent){    var prototype = object(parent.prototype);  // 创建对象    prototype.constructor = child;         // 增强对象    child.prototype = prototype;           // 指定对象}
```

####  6.扩展思考

**寄生组合式继承和组合式继承，两者有什么区别？**

组合继承最大的问题就是无论什么情况下，都会调用俩次超类型构造函数Parent()：一次是在创建子类型原型的时候( Parent.call(this,name); )，另一个是在子类型构造函数内部( Child.prototype = new Parent(); )。
寄生组合式继承的基本思路：不必为了指定子类型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。

#### 7.参考文献

参考一：JavaScript高级程序设计（第3版）
参考二：JS实现继承的几种方式详述（CSDN)————https://blog.csdn.net/liuyan19891230/article/details/50774439
参考三：JS继承的6种方式（CSDN)————https://blog.csdn.net/hhthwx/article/details/78095944
参考四：js继承的常用方法————https://www.cnblogs.com/chenwenhao/p/6980401.html

#### 8.更多讨论

Q1：继承一般用到什么地方？
A ：通常在一般的项目里不需要，因为应用简单，但你要用纯js做一些复杂的工具或框架系统就要用到了，比如webgis、或者js框架如jquery、angular、vue什么的，不然一个几千行代码的框架不用继承得写几万行，甚至还无法维护。

Q2：如何确定原型和实例之间的关系？ 
A：两种方法：第一种是使用instanceOf操作符，第二种是使用isPrototypeOf()方法。 

```
eg：console.log(person instanceOf Child);//true console.log(Child.prototype.isPrototypeOf(instance));//true 
```

Q3：什么是浅复制？
A ：浅复制是复制引用，复制后的引用都是指向同一个对象的实例，彼此之间的操作会互相影响。





# 第9章  代理与反射

## 一.反射

### 1.知识补充：动态语言和静态语言

在学习反射前，先进行一些知识补充：语言的精动态，学习这些将有利于我们理解反射。

- 静态语言，代表：Java、C、C++
  静态语言就是在编译阶段进行类型检查，当编写源程序的时候，出现不符合语法的规范，就会提示错误，在编译时变量的数据类型即可确定。**也即运行时结构不可变的语言。**

```java
int a = 123; // a是整数类型变量
a = "mooc"; // 错误：不能把字符串赋给整型变量
12
```

- 动态语言，代表：JS、PHP
  所谓动态语言，就是类型检查是在运行的时候做的，变量使用之前不需要类型声明，通常变量的类型是就是被赋值的那个值的类型。**运行时期机构可变。**

  例如JavaScript等这种脚本语言就是动态语言，在编译阶段它不会判断代码是否符合规范，在运行的时候才会去判断。

```java
a = 123    # a是整数
print a
a = 'imooc'   # a变为字符串
print a
1234
```

如果我们对这两种语言有一些了解，就很容易了解到它们的区别，例如JS相较于Java，语法十分不规范十分宽松。那这个和反射有什么关系呢？

Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活。

### 2.反射概述

1）第一个问题：反射是什么？

其实对于理解反射是什么这一个问题，最好是深入了解Java的编译过程也就是JVM的相关知识之后，才能对反射有一个较好的理解。但也不妨影响我这个弱鸡对他的理解。



对于一个类的正常生命流程，是`编译期→运行期`这样一个顺序。然而Java给我们提供了一个特殊的机制，**在编译期时（上图第一个阶段加载完成后）会把我们的源代码转换成.class文件并在内存中生成一个Class对象，我们的反射便是借助这一个Class对象来实现的。**

反射，我觉得最重要的是这里面的那个“反”字，说明有什么东西反过来了。如下图，我们正常编程的逻辑就是按箭头的顺序执行的。但假如我们是反射，就是反过来，就是从1到2这样的逻辑，我们是通过操作我们编写的类生成的Class对象来获取类的信息或者操作类。

总结一下，正常编程：类→正常执行，**反射：类→class对象→类→执行，也就是说从类或对象中推导出Class类，然后再从Class类中获得类的信息或对类进行操作，这一行为就是反射。**

2）第二个问题：反射能干什么？

上面我们曾提到Java是一门“准动态”语言，反射提供了动态的特性。同时它也是我们框架中的一个很重要的组成部分，反射是框架设计的灵魂。

class是一切反射的根源，**JAVA反射机制是在运行状态中**，对于任何一个类，通过反射都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。

这样说可能也不能让你了解到反射有什么作用，下面看看反射的应用就知道了。

### 3.反射应用

1.获取类的Class对象

**注意：每一个类只有一个class对象！！！**

```java
//1.通过对象获得
Class c1 = person.getClass();
System.out.println(c1.hashCode());

//2.forName获得
Class c2 = Class.forName("com.chy.reflection.Test");
System.out.println(c2.hashCode());

//3.通过类名.class获得
Class c3 = Stu.class;
System.out.println(c3.hashCode());

//4. 基本内置类型的包装类都有一个Type属性
Class c4 = Integer.TYPE;
System.out.println(c4.hashCode());

//获得父类类型
Class c5 = c1.getSuperclass();
System.out.println(c5);
        
1234567891011121314151617181920
```

当然也不仅仅只有类才有class对象，对于基本类型、数组、接口等也有class对象。对于数组来说，只要数组类型和维度一样（与长度无关），它们都是同一个class对象。

```java
Class c1 = Object.class;  //类
Class c2 = Comparable.class;  //接口
Class c3 = String[].class;   //一维数组
Class c4 = int[][].class;   //二维数组
Class c5 = Override.class;  //注解
Class c6 = ElementType.class;  //枚举
Class c7 = Integer.class;   //基本数据类型
Class c8 = void.class;  //void
Class c9 = Class.class;  //Class
123456789
```

2.利用class对象创建实例

- `Object newInstance()`：创建实例化对象
- `Constructor getDeclaredConstructor(Class ....args)`：获取指定参数的构造器

```java
/*
	使用.newInstance()方法
	前提：
		1.类中必须有一个无参构造器
		2.构造器的访问权限必须足够
*/
	Class c = Test.class;
	Test test = (Test)c.newInstance();


/*
	通过获取构造器来创造实例化对象
	注意：
		1.此时就可以无视构造器的访问权限
		2.不一定要有无参构造器
		3.可以创造指定参数的构造器
*/
	Class c = Test.class;
	Constructor con = c.getDeclaredConstructor(String.class,int.class);
	Test test = (Test)con.newInstance("chy",18);
1234567891011121314151617181920
```

3.利用class对象调用方法

- `Method getDeclaredMethod(String 方法名,Class 参数的class对象)`：获取指定的方法
- `void setAccessible(boolean flag)`：启动和禁用访问安全的开关，默认为false，**但传参为true时，就可以调用private方法。**
- `Object invoke(Object obj,Object ...args)`：激活方法，第一个参数是要调用该方法的对象，其他是参数

```java
class user{
private String name;

public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
}

Class c = user.class;
Method setName = c.getDeclaredMethod("setName", String.class);
Method getName = c.getDeclaredMethod("getName");
setName.setAccessible(true);

setName.invoke(user3,"chy");
getName.invoke(user3);
12345678910111213141516171819
```

**注意：一般来说`setAccessible`不宜为true，因为不安全。不过一旦开启这个禁用开关，则可以提高性能，对于使用频繁的方法，应该打开这个开关。**

4.利用class对象获取类的信息

- `Field getField(String name)`：获取类的属性，只能获取public
- `Field getDeclaredField(String name)`：获取类的属性，包括private
- `String getName()`：获取类的名字（全类名）
- `String getSimpleName()`：获取类的简单名字

```java
		//获取类的名字
        System.out.println(c1.getName());  //获得包名+类名
        System.out.println(c1.getSimpleName());  //获得类名

        //获得类的属性
		Field field = c1.getField("name");
		Field field = c1.getDeclaredField("name");

        Field[] fields = c1.getFields();  //只能找到public属性

        fields = c1.getDeclaredFields();  //找到全部属性
        for (Field field :fields) {
            System.out.println(field);
        }

123456789101112131415
```

5.利用class对象操作泛型和利用class对象操作注解

这里偷懒一下，博客上有很多的，这个其实没什么特殊的，和上面的操作都是类似的。以后有空再来补。

------

## 二.代理模式

相信大家都对代理模式不陌生，这里为什么会涉及到代理模式呢，因为动态代理的原理就是用到了反射，所以这里也简析一下代理模式。

代理模式是什么呢？比如我们有两个类，一个实现某种功能简称功能类，一个通过调用功能类来满足自身目的检查客户类，原来客户类和功能类是直接交互的，客户`类→功能类`。

**现在我们使用代理模式，就再多出一个类，代理类，它横插在客户类和功能类之间，是他们必须通过代理类来交互`客户类→代理类→功能类`**。这时很多人就可能会不理解了，说你这个不是多此一举吗，直接交互不好吗，还要引入一个新的类。

确实，我们平时确实不一定要用到这个模式，用这个确实是多次一举。但在某些场合的时候，使用这个代理模式就是一个极佳的 punchline 了。

下面举个例子：比如我们的WEB项目，现在需要增加一个日志功能，在我们每次调用方法的时候把它记录下来，那怎么办呢？在原来的代码上改咯？不，不能这么做，这么做不够谨慎，有可能改着改着原来代码无法运行了。这时候代理模式就来了，我们只需新建一个代理类，这个代理类不仅能保有原来的功能，也在这个基础上增加了日志功能，专业术语上这个过程叫做增强。

使用代理模式就很好地降低了耦合度，将功能分离开来。其实这个也是横向开发思想的体现。



代理模式有两种：静态代理和动态代理。

首先角色分析

- 抽象角色：一般是接口或者抽象类，也就是这里面的租房这个功能
- 真实角色：被代理的角色，相当于房东
- 代理角色：代理类，一般会添加一些附属操作来实现增强，相当于这里面的中介
- 客户：访问代理对象的类，相当于这里面的租客

### 1.静态代理

这里就不具体展示了，主要讲一下静态代理是什么，用代码展示一下。

```java
//租房，抽象角色
public interface Rent {
    public void rent();
}


//房东，真实角色
class Host implements Rent{
    @Override
    public void rent() {
        System.out.println("房东卖房子...");
    }
}

//代理角色，中介
class Proxy implements Rent{
    private Host host;

    public void setHost(Host host) {
        this.host = host;
    }

    @Override
    public void rent() {
        fare();		//多了一个中介方法，可以类比成我们项目中要多添加的功能
        host.rent();
    }
    
    public void fare(){
        System.out.println("交中介费");
    }
}

//客户角色，租客
class Client{
    public static void main(String[] args) {
        Host host = new Host();
        Proxy proxy = new Proxy();
        proxy.setHost(host);
        proxy.rent();
    }
}
123456789101112131415161718192021222324252627282930313233343536373839404142
```

静态代理一般很少用，较多采用的是动态代理。静态代理其实就是我们真正去写出一个代理类，不过弊端也是很明显的，如果有n个真实角色，那就要写n个代理类，太麻烦了。

众所周知，程序猿是一种懒惰的动物。

### 2.动态代理

相较于静态代理，动态代理就很方便，不过这个很绕很绕。首先要了解以下这个类：

- `InvocationHandler`：这个叫做调用处理程序实现的接口，每一个代理角色都有一个对应的调用处理程序，**看不懂没关系，只需要知道我们是通过它的一个方法来获取代理对象（Proxy对象），然后复写这个接口里面的`invoke`方法。**

  方法一：`newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)`，第一个参数是类加载器，第二个参数是要代理的接口的class对象，第三个参数就是要一个`InvocationHandler`对象。这个方法就会返回一个Proxy对象。

  方法二：`invoke`，这就是我们的代理逻辑，我们要让代理对象做什么增强都需要做什么。这个方法比较复杂，我讲不明白，大家看代码理解吧。**注意：每次我们调用代理对象操作时，就会自动调用这个方法。**

不懂没关系，通过例子多加理解便可。对于静态代理中的那个例子进行改造，变成动态代理，代码如下：

```java
//租房，抽象角色
public interface Rent {
    public void rent();
}

//房东，真实角色
class Host implements Rent{

    @Override
    public void rent() {
        System.out.println("房东卖房子...");
    }
}

//代理角色，中介
class ProxyInvocationHandler implements InvocationHandler {
    private Rent rent;

    public void setRent(Rent rent) {
        this.rent = rent;
    }

	//获取代理对象
    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),rent.getClass().getInterfaces(),this);
    }

	//附加方法
    public void fare(){
        System.out.println("交中介费");
    }

    @Override
    public Object invoke(Object o, Method method, Object[] objects) throws Throwable {
    	//主要代理逻辑
    	//这个method指的是真实对象里的方法，比如rent方法
        fare();
        Object result = method.invoke(rent,objects);
        return result;
    }
}

//客户角色，租客
class Client{
    public static void main(String[] args) {
        Host host = new Host();
        ProxyInvocationHandler proxyInvocationHandler = new ProxyInvocationHandler();
        //这里利用到了多态
        proxyInvocationHandler.setRent(host);
        //获取代理对象
        Rent proxy = (Rent)proxyInvocationHandler.getProxy();
        //这里虽然只是调用了rent方法，但是仍然会调用交中介费的方法
        proxy.rent();
    }
}
```










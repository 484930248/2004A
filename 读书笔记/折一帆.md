# 				   	第一章：JavaScript

​		JavaScript在1995年问世，它的主要用途是代替Perl等服务 器端语言处理输入验证，逐渐的javascript也称为了公认的主流编程语言，能够实现复杂的计算交互，包括闭包、匿名（lambda）函数，甚至元编程 等特性。

### **JavaScript实现**

​		完整的JavaScript实现包含以下几个部分：

​					***核心（ECMAScript）***

​					***文档对象模型（DOM）***

​					***浏览器对象模型（BOM）***

##### 			ECMAScript：

​				ECMAScript，即ECMA-262定义的语言，并不局限于Web浏览 器。Web浏览器只是ECMAScript实现可能存在的一种宿主环境（host environment）。宿主环境提供ECMAScript的基准实现和与环境自身交 互必需的扩展。扩展（比如DOM）使用ECMAScript核心类型和语 法，提供特定于环境的额外功能。其他宿主环境还有服务器端 JavaScript平台Node.js和即将被淘汰的Adobe Flash。

​				在基本的 层面，它描述这门语言的如下部分：

​						语法，类型，语句，关键字，保留字，操作符，全局对象

​				ECMAScript只是对实现这个规范描述的所有方面的一门语言的称 呼。JavaScript实现了ECMAScript，而Adobe ActionScript同样也实现了 ECMAScript。

##### 			DOM：

​					文档对象模型（DOM，Document Object Model）是一个应用编程 接口（API），用于在HTML中使用扩展的XML。DOM将整个页面抽 象为一组分层节点。HTML或XML页面的每个组成部分都是一种节 点，包含不同的数据。DOM通过创建表示文档的树，让开发者可以随心所欲地控制网页 的内容和结构。使用DOM API，可以轻松地删除、添加、替换、修改 节点。

##### 			BOM：

​					IE3和Netscape Navigator 3提供了浏览器对象模型（BOM） API， 用于支持访问和操作浏览器的窗口。而BOM真正独一无二的地方，当然也是问题 最多的地方，就是它是唯一一个没有相关标准的JavaScript实现。 HTML5改变了这个局面，这个版本的HTML以正式规范的形式涵盖了 尽可能多的BOM特性。由于HTML5的出现，之前很多与BOM有关的 问题都迎刃而解了。

​					总体来说，BOM主要针对浏览器窗口和子窗口（frame），不过 人们通常会把任何特定于浏览器的扩展都归在BOM的范畴内。比如， 下面就是这样一些扩展：

​								弹出新浏览器窗口的能力； 

​								移动、缩放和关闭浏览器窗口的能力； 

​								navigator 对象，提供关于浏览器的详尽信息； 

​								location 对象，提供浏览器加载页面的详尽信息； 

​								screen 对象，提供关于用户屏幕分辨率的详尽信息； 

​								performance 对象，提供浏览器内存占用、导航行为和时间统 计的详尽信息。

##### 总的来说：

​		JavaScript是一门用来与网页交互的脚本语言，包含以下三个组成 部分。

​				ECMAScript：由ECMA-262定义并提供核心功能。 

​				文档对象模型（DOM）：提供与网页内容交互的方法和接口。 

​				浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。 

​		JavaScript的这三个部分得到了五大Web浏览器（IE、Firefox、 Chrome、Safari和Opera）不同程度的支持。但对Level 3的支持日益趋于规范。HTML5中收录的 BOM会因浏览器而异，不过开发者仍然可以假定存在很大一部分公共 特性。

# 		      **第二章HTML中的javascript**

​		将JavaScript引入网页，首先要解决它与网页的主导语言HTML的 关系问题。早期，网景公司的工作人员希望将JavaScript 引入HTML页面的同时，不会导致页面在其他浏览器中渲染出问题。最终做出了一些决定，并达成了向网页中 引入通用脚本能力的共识。

### 	**script标签**

​			将javascript引入html的最主要的办法，script元素下有八个属性：	

- asycn：可选。表示应该立即开始下载脚本，但不能阻止其他 页面动作（只对外部脚本文件有效）

- chatset：可选。使用 src 属性指定的代码字符集。（很少使用）

- crossorigin：可选。配置相关请求的CORS（跨源资源共 享）设置。（默认不使用CORS）。

  ​						crossorigin="anonymous" ：配置文件请求不必设置凭据标 志。

  ​						crossorigin="use-credentials" ：设置凭据标志，意 味着出站请求会包含凭据。

- defer：可选。表示在文档解析和显示完成后再执行脚本是没 有问题的。（只对外部脚本有效）

- integrity：可选。允许比对接收到的资源和指定的加密签名 以验证子资源完整性。如果接受与指定的签名都不匹配，则页面报错，脚本不执行。这个属性可以确保内容分发网络不会提供恶意内容

- language：废弃。最初用于表示代码块中的脚本语言

- src：可选。表示包含要执行的代码的外部文件

- type：可选。代替language，表示代码块中脚本语言的内容。

使用<script>的方式的两种方式：通过他直接在网页中嵌入javascript代码，以及通过他在网页中包含外部javascript文件。

​		要嵌入行内JavaScript代码，直接把代码放在 ：	

```html
<script>
	function sayHi(){
		console.log("Hi!")
	}
</script>
```

​			包含在<script>内的代码会被从上到下解释

​	 	在使用行内JavaScript代码时，要注意代码中不能出现字符串</script>

```html
<script>
	function sayScript(){
		console.log('</script>');
	}
</script>
```

​			这段代码在浏览器中会报错，浏览器解析行内脚本的方式决定了它在看到字符串</script>时，会将其当结束标签，为了避免这个问题，需要加转义字符"\"1即可：

​			1此处的转义字符指在JavaScript中使用反斜杠“ \ ”来向文本字符 串添加特殊字符。这样就不会导致任何错误

​			要包含外部文件中的JavaScript，就必须使用 src 属性。这个属 性的值是一个URL，指向包含JavaScript代码的文件：

```html
<script src="example.js"></script>
```

​				如果使用了scr属性就不应该在用<script>标签，要是两者都提，供则浏览器只会下载并执行脚本文件，从而忽略行内代码。

#### 标签占位符

​			过去，所有的script标签元素都被放在页面head标签内。

​			这种做法的主要目的是把外部的CSS和JavaScript文件都集中放到 一起。也就意味着必须把所有JavaScript代码都下载、解析和解释完成后，才能开始渲染页面对于需要JavaScript的页面，会导致页面渲染的延迟，在此期间浏览器窗口完全空白。为了解决这个，现代Wed应用程序通常将所有JavaScript引用放在元素中的页面内容后面：

```html
<!DOCTYPE html>
<html>
	<head>
		<title>Example HTML Page</title>
	</head>
	<body>
		<!-- 这里是页面内容 -->
		<script src="example1.js"></script>
		<script src="example2.js"></script>
	</body>
</html>
```

​		这样一来，页面会在处理JavaScript代码之前完全渲染页面。用户 会感觉页面加载更快了，因为浏览器显示空白页面的时间短了。

#                    第四章 变量、作用域、内存

### 	原始值与引用值

​				ECMAScript变量可以包含两种不同的类型的数据：原始值和引用值。

​						原始值就是最简单的数据，引用值是由多个值构成的对象。

​				在变量赋值的时候，JavaScript引擎要确定这个值是哪个。6种原始值：undefined、null、boolean、number、string、symbol。保存原型值的变量是按值访问的，因为操作就是存储变量中的实际值

​				引用值是保存在内存中的对象。是不可以访问内存的位置，所以也就不能直接操作

#### 			动态属性

​					原型值和引用值的定义方式很像，都是创建一个变量，然后在赋值，不过变量保存后可以做什么，则大有不同，对于引用值而言，可以随时添加，修改和删除其属性和方法。

```JavaScript
let person=new Object();
person.name="Nichlas";
console.log(person.name);//"Nicholas"
```

​			这里，先创建了一个对象，并且保存在变量person中，然后，给对象添加了一个name属性，给这个属性赋值。之后，就可以访问这个型属性，直到对象被销毁或属性被显示的删除。

​		原始值不能有属性，尽管尝试给原始值添加属性不会报错：

```
let name="Nicholas";
name.age=27;
console.log(name.age);//undefined
```

​		这里，代码想给name顶一个age属性并给该属性赋值，但是下一行属性就不见了。只有引用值可以动态后面可以使用的属性

​		注意：原始类型的初始化可以只使用原始字面量形式。如果使用的是new关键字，则JavaScript会创建一个object类型的实例，但其行为类似原始值，两种初始化的差异：

```
let name1="Nicholas";
let name2=new String("Matt");
name1.age=27;
name2.age=26;
console.log(name1.age);//undefined
console.log(name2.age);//26
console.log(typeof name1);//string
console.log(typeof name2);//object
```

#### 			复制值

​					除了存储方式不同，原始值和引用值在通过变量复制是也有所不同，通过变量赋值时，原始值也会被			复制到形变量中。列如：

```
let num1=5;
let num2=num1;
```

​	    此时这里的num2中值也是完全独立的，互不干扰。

​	   在把引用值赋给另一个变量时，值也会被复制到新变量。区别在于，这里复制的值实际上是一 个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际 上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来，如：

```
let obj1 = new Object();
let obj2 = obj1;
obj1.name = "Nicholas";
console.log(obj2.name); // "Nicholas"

```

​		变量 obj1 保存了一个新对象。然后，这 个值被复制到 obj2 ，此时两个变量都指向了同一个对象。给 obj1创建的name 赋值后，通过 obj2 也可以访问这个属 性，因为它们都指向同一个对象

#### 			传递参数

​						ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引 用值，那么就跟引用值变量的复制一样。变量有按值和按引用访问，而传参则只有按值传递参数时，值会被复制到一个局部变量。在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部。

#### 			确定类型

​							typeof操作符最适合用判断一个变量是否为原始类型。

​							typeof 虽然对原始值很有用，但它对引用值的用处不大。

​							ECMAScript提供了 instanceof 操作符，语法如 下： 

```
result = variable instanceof constructor

```

​							如果变量是给定引用类型的实例，则 instanceof 操作符返回 true 。来看下面的例 子： 

```
console.log(person instanceof Object); // 变量 persion是Object吗？ 

console.log(colors instanceof Array); // 变量 colors是Array吗？ 

console.log(pattern instanceof RegExp); // 变量 pattern是RegExp吗？ 
```

​		按照定义，所有引用值都是 Object 的实例，因此通过 instanceof 操作符检测任何引用值和 Object 构造函数都会返 回 true 。类似地，如果用 instanceof 检测原始值，则始终会返 回 false ，因为原始值不是对象。

### 	执行上下文与作用域

​					执行上下文（以下简称“上下文”）的概念在JavaScript中是颇为重 要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们 的行为。

​					全局上下文是最外层的上下文。在浏览器中，全局上下文就 是我们常说的 window 对象。所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。 使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用 域链解析上效果是一样的。

​					上下文中的代码在执行的时候，会创建变量对象的一个作用域链，决定了各级上下文中的代码在访问变 量和函数时的顺序，。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量： arguments 。（全局上下文中没有这个变量。）作用域链中的下一 个变量对象来自包含上下文，再下一个对象来自再下一个包含上下 文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域 链的最后一个变量对象。

#### 变量声明

​		var，es6中新增：let，const，但是let，const压倒性的超越了var

##### 	1，使用var函数作用域声明

​		在使用var声明变量时，变量会被自动添加到最接近的上下文，

​		var 声明会被拿到函数或全局作用域的顶部，位于作用域中所 有代码之前。这个现象叫作“提升”（hoisting）。提升让同一作用 域中的代码不必考虑变量是否已经声明就可以直接使用。可是在 实践中，提升也会导致合法却奇怪的现象，即在变量声明之前使 用变量。

```
function add(num1, num2) {
var sum = num1 + num2;
return sum;
}
let result = add(10, 20); // 30
console.log(sum); // 报错：sum在这里不是有效变量
```

##### 	2，使用let的块级作用域声明

​		let和var很相似，但它的作用域是块级 的，这也是JavaScript中的新概念。。块级作用域由最近的一对包含 花括号 {} 界定， if 块、 while 块、 function 块，甚至连单独的块也是 let 声明变量的作用域。

```
if (true) {
let a;
}
console.log(a); // ReferenceError: a没有定义
while (true) {
let b;
}
console.log(b); // ReferenceError: b没有定义
function foo() {
let c;
}
console.log(c); // ReferenceError: c没有定义
// 这没什么可奇怪的
// var声明也会导致报错
// 这不是对象字面量，而是一个独立的块
// JavaScript解释器会根据其中内容识别出它来
{
let d;
}
console.log(d); // ReferenceError: d没有定义
```

let和var的另一个不同就是同意作用域内不能声明两次，var重复会忽略，let会报异常

let的行为非常适合循环中声明迭代变量

严格来讲， let 在JavaScript运行时中也会被提升，但由于“暂时 性死区”（temporal dead zone）的缘故，实际上不能在声明之前使 用 let 变量。

##### 	3，使用const的常量声明

​		除了 let ，ES6同时还增加了 const 关键字。使用 const 声 明的变量必须同时初始化为某个值。一经声明，在其生命周期的 任何时候都不能再重新赋予新值。

```
const a; // SyntaxError: 常量声明时没有初始化
const b = 3;
console.log(b); // 3
b = 4; // TypeError: 给常量赋值
```

​	const除了遵守以上，其他和let是一样的。const 声明只应用到顶级原语或者对象，换句话说，赋值为对 象的 const 变量不能再被重新赋值为其他引用值，但对象的键 则不受限制。

​	由于 const 声明暗示变量的值是单一类型且不可修改， JavaScript运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的V8引擎就执行这种优化。

### 垃圾回收

​		基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程 是周期性的，即垃圾回收程序每隔一定时间就会自动运行。垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题， 意味着靠算法是解决不了的。

#### 标记清理

​	JavaScript最常用的垃圾回收策略是标记清理

#### 引用计数

​		另一种没那么常用的垃圾回收策略是引用计数。其思路是对每个值都记录它被引用的次数。声明变量并给 它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一 个变量，那么引用数加1。

#### 内存管理

​		在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。

​		将内存占用量保持在一个较小的值可以让页面性能更好。优化内 存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数 据不再必要，那么把它设置为 null ，从而释放其引用。这也可以叫 作解除引用。

# 							第五章	基本引用类型

​		引用值（或者对象）是某个特定引用类型的实例。在ECMAScript中， 引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”，引用类型有时候也 被称为对象定义，因为它们描述了自己的对象应有的属性和方法，对象被认为是某个特定引用类型的实例。新对象通过使用 new 操作符后跟一个构造函数（constructor）来创建。

### Date

​		 Date 类型将日期保存为自协调世界时间1970年1月1日午夜（零时）至今所经过的毫秒数。使用这种存储格式， Date 类型可以精确表示1970年1月 1日之前及之后285 616年的日期。

​	要创建日期对象，就使用 new 操作符来调用 Date 构造函数：

```
let now =new Date();
```

​		在不给 Date 构造函数传参数的情况下，创建的对象将保存当前日期 和时间，ECMAScript为此提供了两 个辅助方法： Date.parse() 和 Date.UTC() 。

​		Date.parse() 方法接收一个表示日期的字符串参数，尝试将这个字 符串转换为表示该日期的毫秒数。

比如，要创建一个表示“2019年5月23日”的日期对象，可以使用以下代 码：

```
let someDate = new Date(Date.parse("May 23, 2019"));
```

如果传给 Date.parse() 的字符串并不表示日期，则该方法会返回 NaN ，如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会 在后台调用 Date.parse()：

```
let someDate = new Date("May 23, 2019");
```

​		日期相同

​		Date.UTC() 方法也返回日期的毫秒表示，但使用的是跟 Date.parse() 不同的信息来生成这个值。传给 Date.UTC() 的参数是 年、零起点月数（1月是0，2月是1，以此类推）、日（1~31）、时 （0~23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。 如果不提供日，那么默认为1日。其他参数的默认值都是0

```
// GMT时间2000年1月1日零点
let y2k = new Date(Date.UTC(2000, 0));
// GMT时间2005年5月5日下午5点55分55秒
let allFives = new Date(Date.UTC(2005, 4, 5, 17, 55,55));
```

​		与 Date.parse() 一样， Date.UTC() 也会被 Date 构造函数隐式 调用，但有一个区别：这种情况下创建的是本地日期，不是GMT日期。不 过 Date 构造函数跟 Date.UTC() 接收的参数是一样的。因此，如果第一 个参数是数值，则构造函数假设它是日期中的年，第二个参数就是月，以此 类推

​		ECMAScript还提供了 Date.now() 方法，返回表示方法执行时日期和 时间的毫秒数。

```
// 起始时间
let start = Date.now();
// 调用函数
doSomething();
// 结束时间
let stop = Date.now(),
result = stop - start;
```

#### 继承的方法

​		与其他类型一样， Date 类型重写了 toLocaleString() 、 toString() 和 valueOf() 方法。但与其他类型不同，重写后这些方法 的返回值不一样。 

​		 toLocaleString() 方法返回与浏览器 运行的本地环境一致的日期和时间。

 		toString() 方法通常返回带时区信息的日期和时间，而时间也 是以24小时制（0~23）表示的

​		Date 类型的 valueOf() 方法根本就不返回字符串，这个方法被重 写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直 接使用它返回的值。

#### 日期格式化方法

​		Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：

- toDateString() 显示日期中的周几、月、日、年（格式特定于实 现）

- toTimeString() 显示日期中的时、分、秒和时区（格式特定于实 现）

- toLocaleDateString() 显示日期中的周几、月、日、年（格式特 定于实现和地区）；

- toLocaleTimeString() 显示日期中的时、分、秒（格式特定于实 现）

- toUTCString() 显示完整的UTC日期（格式特定于实现）

  ​		这些方法的输出与 toLocaleString() 和 toString() 一样，会 因浏览器而异。因此不能用于在用户界面上一致地显示日期

  #### 

#### 日期/事件组件方法

​		Date 类型剩下的方法（见下表）直接涉及取得或设置日期值的特定 部分。注意表中“UTC日期”，指的是没有时区偏移（将日期转换为GMT）时 的日期。

​		

| 方法                             | 说明                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| getTime()                        | 返回日期的毫 秒表示；与 valueOf() 相同                       |
| setTime(milliseconds)            | 设置日期的毫 秒表示，从而修改 整个日期                       |
| getFullYear()                    | 返回4位数年 （即2019而不是 19）                              |
| getUTCFullYear()                 | 返回UTC日期 的4位数年                                        |
| setFullYear(year)                | 设置日期的年 （ year 必须是4 位数）                          |
| setUTCFullYear(year)             | 设置UTC日期 的年（ year 必须 是4位数）                       |
| getMonth()                       | 返回日期的月 （0表示1月，11表 示12月）                       |
| getUTCMonth()                    | 返回UTC日期 的月（0表示1月， 11表示12月）                    |
| setMonth(month)                  | 设置日期的月 （ month为大于 0的数值，大于 1 1 加年）         |
| setUTCMonth(month)               | 设置UTC日期 的月（ mo n th 为 大于 0的数值，大 于 1 1加年）  |
| getDate( )                       | 返回日期中的 日（1~31 ）                                     |
| getUTCDate( )                    | 返回UTC日期 中的日（1~31 ）                                  |
| setDate(date)                    | 设置日期中的 日（如果 date大于该月天数，则加月）             |
| setUTCDate(date)                 | 设置UTC日期 中的日（如果 date 大于该月天数，则加月）         |
| getDay( )                        | 返回日期中表 示周几的数值（ 0 表示周日， 6表示 周六）        |
| getUTCDay()                      | 返回UTC日期 中表示周几的数值 （0表示周日，6表 示周六）       |
| getHours()                       | 返回日期中的 时（0~23）                                      |
| getUTCHours()                    | 返回UTC日期 中的时（0~23）                                   |
| setHours(hours)                  | 设置日期中的 时（如果 hours 大于23，则加日）                 |
| setUTCHours(hours)               | 设置UTC日期 中的时（如果 hours 大于23， 则加日）             |
| getMinutes()                     | 返回日期中的 分（0~59）                                      |
| getUTCMinutes()                  | 返回UTC日期 中的分（0~59）                                   |
| setMinutes(minutes)              | 设置日期中的 分（如果 minutes 大于 59，则加时）              |
| setUTCMinutes(minutes)           | 设置UTC日期 中的分（如果 minutes 大于 59，则加时）           |
| getSeconds()                     | 返回日期中的 秒（0~59）                                      |
| getUTCSeconds()                  | 返回UTC日期 中的秒（0~59）                                   |
| setSeconds(seconds)              | 设置日期中的 秒（如果 seconds 大于 59，则加分）              |
| setUTCSeconds(seconds)           | 设置UTC日期 中的秒（如果 seconds 大于 59，则加分）           |
| getMilliseconds()                | 返回日期中的 毫秒                                            |
| getUTCMilliseconds()             | 返回UTC日期 中的毫秒                                         |
| setMilliseconds(milliseconds)    | 设置日期中的 毫秒                                            |
| setUTCMilliseconds(milliseconds) | 设置UTC日期 中的毫秒                                         |
| getTimezoneOffset()              | 返回以分钟计 的UTC与本地时区 的偏移量（如美国 EST即“东部标准 时间”返回300，进 入夏令时的地区可 能有所差异） |

### RegExp

​	正则：

​			概念：

​				字符串匹配，查询，替换的一种模式，外表风骚，内功强大

​			创建正则有两种方式：

​					1，字面量方式：

```
var rep=/d{13}/g
```

​					2，构造函数的创造：

```
var app=new RegExp('^1[23456]\d{9}$');
```

​			js中使用的正则表达式：

​					字符串中可以使用的的三个函数

​						1，search：返回第一个匹配项的位置，如果找到的话就返回下标，没找到，则返回-1

```
var add=‘javascript’.search(/s/);
console.log(add);  //4
```

​						2，replace：用来执行检索与替换操作，如果正则表达式中设置了修饰符g，那么源字符串中所有与模式匹配的子串都将替换成第二个参数指定的字符串；如果不带修饰符g，则只替换所匹配的第一个子串。

```
var add = ‘12-34-56’.replace(/-/,':');
console.log(add)   //12:35-45

var add = ‘12-34-56’.replace(/-/g,':');
console.log(add)   //12:35:45
```

​						3，split：使用正则表达式作为分隔符分隔字符串

```
var add ='12-34-45'.split(/-/);
console.log(add);   //["12", "34", "45"]
```

​						4，match： 方法在字符串中找到匹配的字符，共有三种模式：

```javascript
（1）如果不带有g标记，则它以数组的形式返回第一个匹配项，其中包含分组和属性index（匹配项的位置）、input（输入字符串，等于 str）
let str = 'I love JavaScript'
let result  = str.match(/Java(Script)/)
console.log(result)  // ["JavaScript", "Script", index: 7, input: "I love JavaScript", groups: undefined]
（2）如果 regexp 带有 g 标记，则它将所有匹配项的数组作为字符串返回，而不包含分组和其他详细信息。
let str = 'I love JavaScript'
let result  = str.match(/Java(Script)/g)
console.log(result)  // ["JavaScript"]
（3）如果没有找到匹配项，则无论是否带有标记 g ，都将返回 null
let str = 'I love JavaScript'
let result  = str.match(/HTML/)
console.log(result)  // null
```

​				test()方法只需要待测试字符串中包含了要测试的字符串就是true

```
var add = new RegExp('^1');
add.test('123');  //true
```

​				正则常见的字符

```
元字符：
		//复杂写
		[abc] 匹配方框号中的任意一个字符 
        [^abc] 除了abc以外的所有的字符  
        [0-9] 匹配0-9之间数字
        [a-z] 匹配所有的小写字母
        [A-Z] 匹配所有的大写字母
        [0-9a-zA-Z] 匹配大小写字母和数字
        [A-z] 匹配所有的大小写字母  [A-Za-z]
        (红色|蓝色|绿色)  匹配红色，蓝色绿色

		//简写
        .  匹配任意字符
        \w 匹配任意字母数字下划线  [A-Za-z0-9_]
        \W 匹配非字母数字下划线
        \d 匹配所有数字  [0-9]
        \D 匹配非数字
        \s 匹配空格字符
        \S 
      
量词：
		{5} 重复出现5次
        {5,} 最小重复出现5次
        {5,7} 最小5次最多7次

        +  {1,} 至少一次
        ?  {0,1} 最多出现一次
        *  {0,} 任意次数
            
        ^ 正则的开始位置
        $ 正则的结束位置
```



ECMAScript通过 RegExp 类型支持正则表达式。正则表达式使用类似 Perl的简洁语法来创建：

```
let expression = /pattern/flags;
```

​		这个正则表达式的 pattern （模式）可以是任何简单或复杂的正则表 达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式 可以带零个或多个 flags （标记），用于控制正则表达式的行为。

​		表示匹配模式的标记

```
g ：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束
i ：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。
m ：多行模式，表示查找到一行文本末尾时会继续查找。
y ：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。
u ：Unicode模式，启用Unicode匹配。dotAll 模式，表示元字符 . 匹配任何字符（包括 \n 或\r ）
```

​		列如：

```
// 匹配字符串中的所有"at"
let pattern1 = /at/g;
// 匹配第一个"bat"或"cat"，忽略大小写
let pattern2 = /[bc]at/i;
// 匹配所有以"at"结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi;
```

​		与其他语言中的正则表达式类似，所有元字符在模式中也必须转义，包 括：

```
( [ { \ ^ $ | ) ] } ? * + .
```

​		元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些 字符本身，就必须使用反斜杠来转义。下面是几个例子：

```
// 匹配第一个"bat"或"cat"，忽略大小写
let pattern1 = /[bc]at/i;
// 匹配第一个"[bc]at"，忽略大小写
let pattern2 = /\[bc\]at/i;
// 匹配所有以"at"结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi;
// 匹配所有".at"，忽略大小写
let pattern4 = /\.at/gi;
```

​		前面例子中的正则表达式都是使用字面量形式定义的。正则表达式也可 以使用 RegExp 构造函数来创建，它接收两个参数：模式字符串和（可选 的）标记字符串，任何使用字面量定义的正则表达式也可以通过构造函数来 创建，比如：

```
// 匹配第一个"bat"或"cat"，忽略大小写
let pattern1 = /[bc]at/i;
// 跟pattern1一样，只不过是用构造函数创建的
let pattern2 = new RegExp("[bc]at","i");
```

​		所有元字符都必须二次转义，包括 转义字符序列，如 \n （ \ 转义后的字符串是 \\\ ，在正则表达式字符串 中则要写成 \\\\\\\\）

#### RegExp实例属性

​	每个 RegExp 实例都有下列属性，提供有关模式的各方面信息。

```
global ：布尔值，表示是否设置了 g 标记。
ignoreCase ：布尔值，表示是否设置了 i 标记。
unicode ：布尔值，表示是否设置了 u 标记。
sticky ：布尔值，表示是否设置了 y 标记。
lastIndex ：整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。
multiline ：布尔值，表示是否设置了 m 标记。
dotAll ：布尔值，表示是否设置了 s 标记。
source ：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。
flags ：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。
```

​		通过这些属性可以全面了解正则表达式的信息，不过实际开发中用得并 不多，因为模式声明中包含这些信息。

​			通过字面量创建的，通过 RegExp 构造函数创建的，但两个模式的 source 和 flags 属性是相同的。 source 和 flags 属性返回的是规范化之后可以在字面量中使用的形式。

#### RegExp实例方法

​		RegExp 实例的主要方法是 exec() ，主要用于配合捕获组使用。如果找到了匹配项，则返 回包含第一个匹配信息的数组；如果没找到匹配项，则返回 null 。返回的数组虽然是 Array 的实例，但包含两个额外的属性： index 和 input 。 index 是字符串中匹配模式的起始位置， input 是要查找的 字符串。

​		

```
let text = "mom and dad and baby";
let pattern = /mom( and dad( and baby)?)?/gi;
let matches = pattern.exec(text);
console.log(matches.index); // 0
console.log(matches.input); // "mom and dad and baby"
console.log(matches[0]); // "mom and dad and baby"
console.log(matches[1]); // " and dad and baby"
console.log(matches[2]); // " and baby"
```

​		在这个例子中，模式包含两个捕获组：最内部的匹配项 " and baby" ，以及外部的匹配项 " and dad" 或 " and dad and baby" 。调用 exec() 后找到了一个匹配项。因为整个字符串匹配模式， 所以 matchs 数组的 index 属性就是0。数组的第一个元素是匹配的整个 字符串，第二个元素是匹配第一个捕获组的字符串，第三个元素是匹配第二 个捕获组的字符串。

​		如果模式设置了全局标记，则每次调用 exec() 方法会返回一个匹配 的信息。如果没有设置全局标记，则无论对同一个字符串调用多少次 exec() ，也只会返回第一个匹配的信息。

​		如果在这个模式上设置了 g 标记，则每次调用 exec() 都会在字符串 中向前搜索下一个匹配项。

​		如果模式设置了粘附标记 y ，则每次调用 exec() 就只会在 lastIndex 的位置上寻找匹配项。

​		正则表达式的另一个方法是 test() ，接收一个字符串参数。如果输 入的文本与模式匹配，则参数返回 true ，否则返回 false 。这个方法适 用于只想测试模式是否匹配，而不需要实际匹配内容的情况。 test() 经 常用在 if 语句中：

```
let text = "000-00-0000";
let pattern = /\d{3}-\d{2}-\d{4}/;
if (pattern.test(text)) {
	console.log("The pattern was matched.");
}
```

#### RegExp构造函数属性

​		RegExp 构造函数本身也有几个属性。（在其他语言中，这种属性被 称为静态属性。）这些属性适用于作用域中的所有正则表达式，而且会根据 最后执行的正则表达式操作而变化。特点：就是可以通过 两种不同的方式访问它们

| 全名         |      |                                           |
| ------------ | ---- | ----------------------------------------- |
| input        | $_   | 最后搜索的字符串                          |
| lastMatch    | $&   | 最后匹配的文本                            |
| lastParen    | $+   | 最后匹配的捕获组                          |
| leftContext  | $`   | input 字符串中出现在 lastMatch 前面的文本 |
| rightContext | $`   | input 字符串中出现在 lastMatch 后面的文本 |

​		通过这些属性可以提取出与 exec() 和 test() 执行的操作相关的信息：举例：

```
let text = "this has been a short summer";
let pattern = /(.)hort/g;
if (pattern.test(text)) {
console.log(RegExp.input); // this has been a short summer
console.log(RegExp.leftContext); // this has been a
console.log(RegExp.rightContext); // summer
console.log(RegExp.lastMatch); // short
console.log(RegExp.lastParen); // s
}
```

​		以上代码创建了一个模式，用于搜索任何后跟 "hort" 的字符，并把 第一个字符放在了捕获组中。不同属性包含的内容如下。

```
input 属性中包含原始的字符串。
leftConext 属性包含原始字符串中 "short" 之前的内容，
rightContext 属性包含 "short" 之后的内容。
lastMatch 属性包含匹配整个正则表达式的上一个字符串，即 "short" 。
lastParen 属性包含捕获组的上一次匹配，即 "s" 。
```

​		这些属性名也可以替换成简写形式，只不过要使用中括号语法来访问，因为大多数简写形式都不是合法的ECMAScript标识 符

#### 模式局限

​		虽然ECMAScript对正则表达式的支持有了长足的进步，但仍然缺少Perl 语言中的一些高级特性。

```
\A 和 \Z 锚（分别匹配字符串的开始和末尾）
联合及交叉类
原子组
x （忽略空格）匹配模式
条件式匹配
正则表达式注释
```

​		虽然还有这些局限，但ECMAScript的正则表达式已经非常强大，可以 用于大多数模式匹配任务。

### 原始值包装类型

​		为了方便操作原始值，ECMAScript提供了3种特殊的引用类型： Boolean 、 Number 和 String。每当用到某个原 始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴 露出操作原始值的各种方法。

​		引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创 建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能 在运行时给原始值添加属性和方法。

​		可以显式地使用 Boolean 、 Number 和 String 构造函数创建原始 值包装对象。在原始值包装类型的实例上调用 typeof 会返回 "object" ，所有原始值包装对象都会转换为布尔值 true 。 另外， Object 构造函数作为一个工厂方法，能够根据传入值的类型 返回相应原始值包装类型的实例。比如：

```
let obj = new Object("some text");
console.log(obj instanceof String); // true
```

​		如果传给 Object 的是字符串，则会创建一个 String 的实例。如果 是数值，则会创建 Number 的实例。布尔值则会得到 Boolean 的实例。 注意，使用 new 调用原始值包装类型的构造函数，与调用同名的转型 函数并不一样。列如：

```
let value = "25";
let number = Number(value); // 转型函数
console.log(typeof number); // "number"
let obj = new Number(value); // 构造函数
console.log(typeof obj); // "object"
```

​		在这个例子中，变量 number 中保存的是一个值为25的原始数值，而 变量 obj 中保存的是一个 Number 的实例。虽然不推荐显式创建原始值包装类型的实例，但它们对于操作原始值的 功能是很重要的。

#### Boolean

​		Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就 使用 Boolean 构造函数并传入 true 或 false ，如下例所示：

```
let booleanObject = new Boolean(true);
```

​		Boolean 的实例会重写 valueOf() 方法，返回一个原始值 true 或 false 。 toString() 方法被调用时也会被覆盖，返回字符 串 "true" 或 "false" 。不过， Boolean 对象在ECMAScript中用得很 少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用 Boolean 对象时，

```
let falseObject = new Boolean(false);
let result = falseObject && true;
console.log(result); // true
let falseValue = false;
result = falseValue && true;
console.log(result); // false
```

​		原始值和引用值（ Boolean 对象）还有几个区别。首 先， typeof 操作符对原始值返回 "boolean" ，但对引用值返 回 "object" 。同样， Boolean 对象是 Boolean 类型的实例，在使用 instaceof 操作符时返回 true ，但对原始值则返回 false。 比如：

```
console.log(typeof falseObject); //
object
console.log(typeof falseValue); //
boolean
console.log(falseObject instanceof Boolean); // true
console.log(falseValue instanceof Boolean); // false
```

​		理解原始布尔值和 Boolean 对象之间的区别非常重要，强烈建议永远 不要使用后者。

#### Number

​		Number 是对应数值的引用类型。要创建一个 Number 对象，就使 用 Number 构造函数并传入一个数值，如下例所示：

```
let numberObject = new Number(10);
```

​		与 Boolean 类型一样， Number 类型重写了 valueOf() 、 toLocaleString() 和 toString() 方法。 valueOf() 方法返回 Number 对象表示的原始数值，另外两个方法返回数值字符串。 toString() 方法可选地接收一个表示基数的参数，并返回相应基数形式 的数值字符串，列如：

```
let num = 10;
console.log(num.toString()); // "10"
console.log(num.toString(2)); // "1010"
console.log(num.toString(8)); // "12"
```

​		除了继承的方法， Number 类型还提供了几个用于将数值格式化为字 符串的方法。

​		toFixed() 方法返回包含指定小数点位数的数值字符串，如：

```
let num = 10;
console.log(num.toFixed(2)); // "10.00"
```

​		toFixed() 自动舍入的特点可以用于处理货币。不过要注意的是， 多个浮点数值的数学计算不一定得到精确的结果。

​		另一个用于格式化数值的方法是 toExponential() ，返回以科学记 数法（也称为指数记数法）表示的数值字符串。与 toFixed() 一样， toExponential() 也接收一个参数，表示结果中小数的位数。列如：

```
let num = 10;
console.log(num.toExponential(1)); // "1.0e+1"
```

​		toPrecision() 方法会根据情况返回最合理的输出结果，可能是固 定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数 字的总位数（不包含指数）。列如：

```
let num = 99;
console.log(num.toPrecision(1)); // "1e+2"
console.log(num.toPrecision(2)); // "99"
```

​		toPrecision() 方法会根据数值和精度来决定调用 toFixed() 还是 toExponential() 。为了以正确的小数位精确表示数值，这3个方法都 会向上或向下舍入。

​		与 Boolean 对象类似， Number 对象也为数值提供了重要能力。但 是，考虑到两者存在同样的潜在问题，因此并不建议直接实例化 Number 对象。在处理原始数值和引用数值时， typeof 和 instacnceof 操作符 会返回不同的结果，如下所示：

```
let numberObject = new Number(10);
let numberValue = 10;
console.log(typeof numberObject); //"object"
console.log(typeof numberValue); //"number"
console.log(numberObject instanceof Number); // true
console.log(numberValue instanceof Number); //false
```

​		原始数值在调用 typeof 时始终返回 "number" ，而 Number 对象 则返回 "object" 。类似地， Number 对象是 Number 类型的实例，而 原始数值不是。

​		isInteger() 方法与安全整数

​		ES6新增了 Number.isInteger() 方法，用于辨别一个数值是否保 存为整数。有时候，小数位的0可能会让人误以为数值是一个浮点值：

```
console.log(Number.isInteger(1)); // true
console.log(Number.isInteger(1.00)); // true
console.log(Number.isInteger(1.01)); // false
```

#### String

​		String 是对应字符串的引用类型。要创建一个 String 对象，使 用 String 构造函数并传入一个数值，如下例所示：

```
let stringObject = new String("hello world");
```

​		String 对象的方法可以在所有字符串原始值上调用。3个继承的方 法 valueOf() 、 toLcaleString() 和 toString() 都返回对象的原 始字符串值。

​		每个 String 对象都有一个 length 属性，表示字符串中字符的数 量。

​		String 类型提供了很多方法来解析和操作字符串：

##### 1. JavaScript字符

​		JavaScript字符串由16位码元组成。对多数字符来说，每16 位码元对应一个字符。换句话说，字符串的 length 属性表示字符串 包含多少16位码元：

​		JavaScript字符串使用了两种Unicode编码混合的策略：UCS-2和UTF16。对于可以采用16位编码的字符（U+0000~U+FFFF），这两种编码 实际上是一样的。

​		使用 charCodeAt() 方法可以查看指定码元的字符编码。这个方法返 回指定索引位置的码元值，索引以整数指定。比如：

```
let message = "abcde";
// Unicode "Latin small letter C"的编码是U+0063
console.log(message.charCodeAt(2)); // 99
// 十进制99等于十六进制63
console.log(99 === 0x63); // true

```

​		fromCharCode() 方法用于根据给定的UTF-16码元创建字符串中的 字符。

##### 2，normalize()方法

​		某些Unicode字符可以有多种编码方式。有的字符既可以通过一个BMP 字符表示，也可以通过一个代理对表示。

​		Unicode提供了4种规范化形式，可以将类似上面的字 符规范化为一致的格式，无论底层字符的代码是什么。这4种规范化形 式是：NFD（Normalization Form D）、NFC（Normalization Form C）、NFKD（Normalization Form KD）和NFKC（Normalization Form。可以使用 normalize() 方法对字符串应用上述规范化形式， 使用时需要传入表示哪种形式的字符 串： "NFD" 、 "NFC" 、 "NFKD" 或 "NFKC" 。

##### 3，字符串操作方法

​		concat() ，用于将一个 或多个字符串拼接成一个新字符串。

```
let stringValue = "hello ";
let result = stringValue.concat("world");
console.log(result); // "hello world"
console.log(stringValue); // "hello"
```

​		ECMAScript提供了3个从字符串中提取子字符串的方法： slice() 、 substr() 和 substring() 。

##### 4,字符串位置方法

​		有两个方法用于在字符串中定位子字符串： indexOf() 和 lastIndexOf() 。这两个方法从字符串中搜索传入的字符串，并返 回位置（如果没找到，则返回 -1 ）。两者的区别在于， indexOf() 方法从字符串开头开始查找子字符串，而 lastIndexOf() 方法从字符串末尾开始查找子字符串。

##### 5，字符串包含方法

​		ECMAScript 6增加了3个用于判断字符串中是否包含另一个字符串的方 法： startsWith() 、 endsWith() 和 includes() 。这些方法 都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔 值。。它们的区别在于， startsWith() 检查开始于索引0的匹配项， endsWith() 检查开始于索引 (string.length - substring.length) 的匹配项，而 includes() 检查整个字符 串

##### 6，trim()方法

​		ECMAScript在所有字符串上都提供了 trim() 方法。这个方法会创建 字符串的一个副本，删除前、后所有空格符，再返回结果。

##### 7，repeat()方法

​		ECMAScript在所有字符串上都提供了 repeat() 方法。这个方法接收 一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后 的结果。

##### 8，padStart() 和 padEnd() 方法

​		padStart() 和 padEnd() 方法会复制字符串，如果小于指定长 度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个 参数是长度，第二个参数是可选的填充字符串，默认为空格

##### 9. 字符串迭代与解构

​		字符串的原型上暴露了一个 @@iterator 方法，表示可以迭代字符串 的每个字符。

​		在 for-of 循环中可以通过这个迭代器按序访问每个字符：

```
for (const c of "abcde") {
console.log(c);
}
// a
// b
// c
// d
// e
```

​		有了这个迭代器之后，字符串就可以通过解构操作符来解构了。

# 六，集合引用类型

### 1，Object

​		目前为止，大多数引用值的实例使用都是object类型，object是ECMAScript中最常用的类型之一。虽然object的实例没有多少功能，但狠适合存储和在引用程序间交换数据，

​		显示的创建object的实例有两种方式：第一种就是：new操作符和object构造函数，如下：

```
let person=new Object();
person.name='nihao';
person.age=29;
```

第二种是使用字面量表示法。对象字面量是对象定义的简写形式，目的就是为了简化包含大量属性的对象的创建，比如：

```
let person={
name:"nihao",
age:29,
};
```

在对象字面量表示法中，属性名可以是字符串或者是数值，比如：

```
let person={
"name":"nihao",
"age":"29",
5:true
};
```

注意，数值属性会自动转换为字符串

当然也可以用对象字面量表示法来定义一个只有默认属性和方法的对象，只要使用一对大括号，中间留空就行了：

```
let person={};//与new Object()相同
person.name='nihao';
person.age=29;
```

注意：在使用对象字面量表示定义对象是，并不会实际调用Object构造函数

### 2，Array

#### 2.1 创建数组

有几种基本的方式可以创建数组，一种是使用Array构造函数。比如：

```
let colors=new Array();
```

如果知道数组中的元素数量，那么可以给构造函数传入一个数值，然后length属性就会被自动创建并设置为这个值，比如：

```
let colors=new Array(3);//那么就会有三个空数组，length为3
```

也可以给Array构造函数传入要保存的元素，比如：

```
let colors=new Array('red','blue','green');
```

使用Array构造函数可以省略new操作符。

```
let colors=Array(3);
let color=Array('red');
```

另一种创建数组的方式就是使用数组字面量表示法。数组字面量是在括号中包含以逗号分隔的元素列表，如下面的列子所示：

```
let colors=['red','你好','javascript'];//创建了一个包含3个元素的数组
let name=[];//创建一个空的数组
let values=[1,2];//创建了一个包含两个元素的数组
```

注意：与对象一样，在使用数组字面量表示法创建数组不会调用Array构造函数。

Array构造函数还有两个ES6新增的用于创建数组的静态方法：

from()和of()。from()用于将类数组构造转换为数组实例，而of()用于将一组参数转换为数组实例。

Array.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或着有一个length属性和可索引元素的结构，

```
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
```

arrayLike是一个类似数组的对象，Array.from()方法将他转换为真正的数组。

Array.from()还可以接收第二个可选的映射函数参数，这个函数可以直接增强请数组的值，而无须像调用Array.from().map()那样先创建一个中间数组，还可以接收第三个可选参数，用于指定映射函数中this的值，单这个重写的this值在箭头函数中不适用。

Array.of()可以吧一组参数转换为数组，这个方法用于代替在ES6之前常用的Array.prototype.slice.cal(arguments),一种异常笨拙的将arguments对象转换为数组的写法：

```
console.log(Array.of(1,2,3,4));
console.log(Array.of(undefined));
```

#### 2.2 数组索引

要取得或设置数组的值，需要使用中括号并提供相应值的数字索引， 如下所示：

```
let colors=['red','blue','green'];
console.log(colors[0]);//显示第一项
colors[1]='nih';//修改第二项
colors[3]='brown';//添加
```

数组中元素的数量保存在length属性中，这个属性始终返回0或者大于0的值，比如：

```
let colors=['niha','123','lala'];
let names=[];
console.log(colors.length);//3;
console.log(names.length);//0
```

数组length属性的独特之处在于，他不是只读的，通过修改length属性，可以从数组末尾删除或者添加元素。length设置为大于数组元素数的值，则新添加的元素都将以undefined填充，比如:

```
//删除末尾元素
let colors=['red','blue','green'];
colors.length=2;
console.log(colors[2]);//undefined;
//添加元素
let colors=['red','blue','green'];
colors.length=4;
console.log(colors[3]);//undefined;
```

使用 length 属性可以方便地向数组末尾添加元素：

```
let colors = ["red","blue","green"]; // 创建一个包含3个字符串的数组
colors[colors.length] = "black"; // 添加一种颜色（位置3）
colors[colors.length] = "brown"; // 再添加一种颜色（位置4）
```

#### 2.3	检测数组

​		一个经典的ECMAScript问题是判断一个对象是不是数组。在只有一个 网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符 就足矣：

```
[] instanceof Array;	// true
Array.isArray([]);	//true
```

#### 2.4	复制和填充的方法

​		ES6中新增了两个方法：批量复制方法fill()，以及填充数组方法copyWithin()。

​		使用 fill() 方法可以向一个已有的数组中插入全部或部分相同的 值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索 引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负 索引想象成数组长度加上它得到的一个正索引：

```
const zeroes = [0, 0, 0, 0, 0];
// 用5填充整个数组
zeroes.fill(5);
console.log(zeroes); // [5, 5, 5, 5, 5]
```

​		与 fill() 不同， copyWithin() 会按照指定范围浅复制数组中的 部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引 则与 fill() 使用同样的计算方法：

```
let colors = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
// 从ints中复制索引0开始的内容，插入到索引5开始的位置
// 在源索引或目标索引到达数组边界时停止
colors.copyWithin(5); 
console.log(colors); // [0, 1, 2, 3, 4, 0, 1, 2, 3,4]
```

#### 2.5 reverse

​		严格意义上来讲，`reverse`不是排序方法，它只是数组颠倒方法，可以将数组的顺序颠倒过来。

```
let values = [1, 2, 3, 4, 5]; 
values.reverse();
console.log(values); // [5,4,3,2,1]
```

#### 2.6 sort

​		`sort()`方法可以接收一个比较函数，用于判断哪个值应该排在前面。比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回0；如果第一个参数应该排在第二个参数后面，就返回正值。

```
let values = [0, 1, 5, 10, 15];
values.sort();	// 不传比较函数出来的结果是不正常的
console.log(values); // 0,1,10,15,5

let values = [15, 1, 10, 5, 0];
values.sort(function (value1, value2) {
    if (value1 < value2) {
        return -1;
    }
    else if (value1 > value2) {
        return 1;
    }
    return 0;
});
console.log(values); // 0,1,5,10,15

//使用箭头函数简写
let values = [15, 1, 10, 5, 0];
values.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
console.log(values); // 0,1,5,10,15

//最简单的方法
let values = [15, 1, 10, 5, 0];
values.sort((a, b) => a - b);
console.log(values); // 0,1,5,10,15
```

#### 2.7	concat

​		`concat()`方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。

``` js
let colors = ["red", "green", "blue"]; 
let colors2 = colors.concat("yellow", ["black", "brown"]); 
console.log(colors); // ["red", "green","blue"]
console.log(colors2); // ["red", "green", "blue", "yellow", "black", "brown"]

//不能添加第二层的数据
let colors = ["red", "green", "blue"]; 
let colors2 = colors.concat("yellow", ["black", "brown"],"aaa",["bbb",'ccc', ['a','b',['c']]]);
console.log(colors2);	//["red", "green", "blue", "yellow", "black", "brown", "aaa", "bbb", "ccc", Array(3)]
```

#### 2.8 slice

​		`slice()`用于创建一个包含原有数组中一个或多个元素的新数组。`slice()`方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则 `slice()`会返回该索引到数组末尾的所有元素。如果有两个参数，则`slice()` 返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。

``` js
let colors = ["red", "green", "blue", "yellow", "purple"]; 
let colors2 = colors.slice(1); 
let colors3 = colors.slice(1, 4);
console.log(colors2);	// ["green", "blue", "yellow", "purple"
console.log(colors3);	// ["green", "blue", "yellow"]
console.log(colors);	// ["red", "green", "blue", "yellow", "purple"]
```

#### 2.9	splice

​		`splice()`是个非常强大的方法，可删除，替换，增加

​		删除：

​			需要给 `splice()` 传2个参数：要删除的第一个元素的位置和要删除的元素数量。从原数组中删除任意多个元素，并返回一个数组，返回的数组包含删除的项。比如

```
let colors = ["red", "green", "blue"]; 
let removed = colors.splice(0,1); // 删除第一项，并将第一项返回
console.log(colors);	// ["green", "blue"]
console.log(removed);	// ["red"]
```

​		插入：

​			需要给 `splice()` 传3个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。比如，

```
let colors = ["red", "green", "blue"]; 
let removed = colors.splice(1, 0, "yellow", "orange"); // 在位置1插入两个元素
console.log(colors);	// ["red", "yellow", "orange", "green", "blue"]
console.log(removed);	// []
```

​		替换：

​			splice()` 在删除元素的同时可以在指定位置插入新元素，样要传入3个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。比如，`

```
let colors = ["red", "green", "blue"]; 
let removed = colors.splice(1, 1, "red", "purple"); // 插入两个值，删除一个元素
console.log(colors);	// ["red", "red", "purple", "blue"]
console.log(removed);	// ["green"]
```

#### 2.10	找下标

##### 1、indexOf

​		从左到右搜索第一个===的下标。

```
[1,2,3].indexOf(1);	// 0
[1,2,3].indexOf('1');	// -1，因为不全等，找不到就返回-1
[1,2,3,1,5,6].indexOf(1, 2);	// 3，第二个参数是从x下标开始搜索
```

##### 2、lastIndexOf

​		[1,2,3,1,5,7].lastIndexOf(1);	// 3

```
[1,2,3,1,5,7].lastIndexOf(1);	// 3
[1,2,3,1,5,7,1,5].lastIndexOf(1, 100);	// 6 第二个参数是从x下标开始搜索
[1,2,3,1,5,7,1,5].lastIndexOf(1, 5);	// 3
```

#### 2.11	includes

​		判断数组内是否有===的项。

```
[1,2,3,4,5,6].includes(1);	// true
[1,2,3,4,5,6].includes('1');	// false，因为不全等
[1,2,3,4,5,6].includes(8);	// false
```

####  2.12	find

​		根据条件查找数组内的单个项。

```
[1,2,3].find(c=> c === 1);	// 1
[1,2,3].find(c=> c == '1');	// 1
[1,2,3].find(c=> c === 5);	// undefined
[1,2,3].find(c=> c > 1);	// 2

const people = [{
    name: "Matt",
    age: 27
},
{
    name: "Nicholas",
    age: 29
}];
//三个参数分别是：当前遍历的项、当前下标、原始数组。
let p = people.find((element, index, array) => {
    console.log(element, index, array);
    return element.age > 28;
});
console.log(p);		// {name: "Nicholas", age: 29}
```

#### 2.13	findIndex

​		根据条件查找数组内匹配项的下标。

```
[1,2,3].findIndex(c=> c === 3);	// 2
[1,2,3].findIndex(c=> c === 5);	// -1
[1,2,3].findIndex(c=> c > 1);	// 1
```

#### 2.14	every

​		验证数组内每一个项是否匹配

```
[1,2,3].every(c=> c === 3);	// false
[1,2,3].every(c=> c > 0);	// true
[1,2,3].every(c=> c < 10);	// true
[1,1,1].every(c=> c === 1);	// true
[1, 2, 3, 4, 5, 4, 3, 2, 1].every((item, index, array) => item > 2);    // false
```

#### 2.15	some

​		验证数组内某一个项是否匹配。

```
[1,2,3].some(c=> c === 3);	// true
[1,2,3].some(c=> c > 0);	// true
[1,2,3].some(c=> c < 10);	// true
[1,1,1].some(c=> c === 1);	// true
[1,2,3].some(c=> c === 5);	// false
[1, 2, 3, 4, 5, 4, 3, 2, 1].some((item, index, array) => item > 2);     // true
```

#### 2.16	filter

​	创建一个新数组，根据条件将搜索匹配的项放入至新数组内，并将此数组返回。

```
[1,2,3].filter(c=> c > 1);	// [2,3]
[1,2,3].filter(c=> c > 5);	// []
[1,2,3].filter(c=> c === 3);	// [3]
[1, 2, 4, 5, 4, 2, 1].filter((item, index, array) => item > 2);	//[4, 5, 4]
```

#### 2.17	forEach

​		遍历每一个数组，传入回调函数，可对每一个项进行操作

```
[1, 2, 3].forEach(c => {
    console.log(c * 2);
});
// 2 4 6

[1, 2, 3].forEach((item, index, array) => {
    console.log(item * index);
});
// 0 2 6
```

#### 2.18	flat

​		将多维数组扁平化，并返回一个新数组。方法接受一个数值，表示要扁平化的数组维度。

```
let ary = [1, [2, [3, [4, 5]]], 6];
console.log(ary.flat(1));	// [1, 2, Array(2), 6]
console.log(ary.flat());	// [1, 2, Array(2), 6]，不传参默认为1
console.log(ary.flat(2));	// [1, 2, 3, Array(2), 6]
console.log(ary.flat(3));	// [1, 2, 3, 4, 5, 6]
console.log(ary.flat(100));	// [1, 2, 3, 4, 5, 6]，可以超过维度深度，超过则会扁平化所有维度
console.log(ary);	// [1, Array(2), 6]
```

#### 2.19	map

​		遍历数组，针对每一个项返回一个新值，将新值放进新数组里，最后将新数组返回。

```
[1, 2, 3].map(c => {
    return c * 2;
});	// [2,4,6]

[1, 2, 3].map(c => {
    return 2;
});	// [2,2,2]

[1, 2, 3].map((item, index, array) => {
    return item * index;
});	// [0,2,6]

[{ a: 1 }, { a: 2 }, { a: 3 }, { a: 4 }, { a: 5 }].map(c => c.a);	// [1, 2, 3, 4, 5]
```

#### 2.20	join

​		数组拼接成字符串方法，方法传入拼接关键字。

```
[1,2,3].join(',');	// '1,2,3'
```

#### 2.21	pop

​		从原数组取出最后一个项。

```
let numbers = [1,2,3,4,5];
numbers.pop();	// 5
console.log(numbers);   // [1,2,3,4]

let empty = [];
empty.pop();	// undefined
console.log(empty);	// []
```

#### 2.22	shift

​		从原数组取出第一个项。

```
let numbers = [1,2,3,4,5];
numbers.shift();    // 1
console.log(numbers);   // [2,3,4,5]
```

#### 2.23	unshift

​		在原数组的头部添加随意数量的项，并返回添加后数组的长度。

``` js
let numbers = [1, 2, 3, 4, 5];
let length = numbers.unshift(7, 8, 9);
console.log(length);    // 8
console.log(numbers);   // [7, 8, 9, 1, 2, 3, 4, 5]
```

### 3	Set

​		Set是一个无法添加重复值的集合。

```
const set = new Set();	//创建一个空集合

const s1 = new Set(["val1", "val2", "val3"]);	// 使用数组初始化集合
console.log(s1.size);		// 3,长度访问跟数组的length不一样
s1.add("Matt").add("Frisbie");	//可以链式添加
s1.has('Matt');	// true，是否存在指定的项
console.log(s1);	// Set(5) {"val1", "val2", "val3", "Matt", "Frisbie"}
s1.add("Matt");
console.log(s1);	// Set(5) {"val1", "val2", "val3", "Matt", "Frisbie"}，无法添加重复项

let deleted = s1.delete('Matt');	// delete方法返回删除结果
console.log(deleted);   // true
console.log(s1);    // Set(4) {"val1", "val2", "val3", "Frisbie"}

deleted = s1.delete('Matt');
console.log(deleted);   // false，无法重复删除

//可通过for of访问每个项
for (let item of s1) {
    console.log(item);
}
//val1 val2  val3 Frisbie

//也可通过forEach方法访问
s1.forEach(item => console.log(item));
```

#### Set的经典应用-去重

```
let numbers = [1, 2, 3, 5, 6, 1, 2, 3];
numbers = Array.from(new Set(numbers));
console.log(numbers);   // [1, 2, 3, 5, 6]
```









# 第八章、对象、类与面向对象

### 8.1 理解对象

​		创建自定义对象的通常方式是创建 Object 的一个新实例，然后 再给它添加属性和方法，如下例所示：

```
let person = new Object();
person.name = "Nicholas";
person.age = 29;
person.job = "Software Engineer";
person.sayName = function() {
console.log(this.name);
};
```

#### 8.1.1  属性类型

​		ECMA-262使用一些内部特性来描述属性的特征。这些特性是由 为JavaScript实现引擎的规范定义的。因此，开发者不能在JavaScript中 直接访问这些特性。

​		属性分为两种：数据属性和访问器属性

##### 1，数据属性

​		数据属性包含一个保存数据值的位置。值会从这个位置读取，也 会写入到这个位置。数据属性有4个特性描述它们的行为。

​		[[Configurable]]：表示属性是否可以通过删除删除并重新定义，是否可以修改它的特性，以及是否可以将其替换为访问器属性。在其他情况下，所有直接定义在对象上的属性的这个特性都是true，如前面的例子所示

​		[[Enumberable]]：表示属性是否可以通过for-in循环返回。有时情况下，所有直接定义在对象上的属性的这个特性都是true，如前面的示例所示

​		[[Writable]]：表示属性的值是否可以被修改。在某些情况下，所有直接定义在对象上的属性的这个特性都是true，如前面的示例所示

​		[[Value]]：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的替换未定义

​		[[Configurable]]，[[Enumerable]]和[[Writable]]都会被设置为true，而[[Value]]特性会被设置为指定的值

要修改属性的预设特性，就必须使用Object.defineProperty（）方法

```
let person = {};
Object.defineProperty(person, "name", { writable: false, value: "Nicholas" });
console.log(person.name); // "Nicholas" 
person.name = "Greg";
console.log(person.name); // "Nicholas"
```

虽然可以对同一个属性多次调用

​		Object.defineProperty（），但在把可配置设置为false之后就会受限制了。在调用Object.defineProperty（）时，可配置，可枚举和可写的值如果不指定，则都变成为false。可能都不需要

##### 2，访问器属性

​		[[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把

它替换数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是true。

​		[[Enumerable]]：表示属性是否可以通过for-in循环返回。有时情况下，所有直接定义在对象上的属性的这个特性都是true。

​		[[Get]]：获取函数，在读取属性时调用。替代变量undefined。

​		[[Set]]：设置函数，在写入属性时调用。否则变量未定义。

### 8.2创建对象

#### 8.2.1工厂模式

```
function createStudent(name,sex,grade){															
	var o = new Object();
	o.name = name;
	o.sex = sex;
	o.grade = grade;

	o.sayName = function(){
		console.log(this.name);
	}
	return o;
}
var s1 = createStudent('Claiyre','famale',1);
```

#### 8.2.2构造函数模式

```
function Student(name,sex,grade){													
	this.name = name;
	this.sex = sex;
	this.grade = grade;
	this.sayName = function(){
		console.log(this.name);
	}
}
var s2 = new Student('孙悟空'，'male',2);
```

不同：

- 没有显示地创建对象
- 直接将属性和方法赋给此对象
- 没有return语句

### 8.3继承

#### 8.3.1原型链继承

```
function Cat(){ 
}
Cat.prototype = new Animal();
Cat.prototype.name = 'cat';

//　Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.eat('fish'));
console.log(cat.sleep());
console.log(cat instanceof Animal); //true 
console.log(cat instanceof Cat); //true
```

特点：

1. 非常纯粹的继承关系，实例是子类的实例，也是父类的实例
2. 父类添加原型方法/原型属性，子类都能访问到
3. 简单，容易实现

缺点：

1. 要想为子类添加属性和方法，必须要在`new Animal()`这样的语句之后执行，不能放到构造器中
2. 无法实现多继承
3. 来自原型对象的所有属性被所有实例共享（来自原型对象的引用属性是所有实例共享的）（详细请看附录代码：示例1）
4. 创建子类实例时，无法向父类构造函数传参

#### 8.3.2构造继承

```
function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // false
console.log(cat instanceof Cat); // true
```

特点：可以传递参数，不可以继承父方法原型的属性/方法

#### 8.3.3组合继承

```
function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
Cat.prototype = new Animal(); 
Cat.prototype.constructor = Cat; // Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // true
```

特点：可以传递参数，可以继承父方法原型的属性/方法，可替换，缺失：调用俩次构造函数

#### 8.3.4原型式继承

```
 function CreateObj(o){
            function F(){}
            F.prototype = o;
            console.log(o.__proto__ === Object.prototype);
            console.log(F.prototype.constructor === Object); // true
            return new F();
        }

        var person = {
            name: 'xiaopao',
            friend: ['daisy','kelly']
        }

        var person1 = CreateObj(person);

        // var person2 = CreateObj(person);

        person1.name = 'person1';
        // console.log(person2.name); // xiaopao
        person1.friend.push('taylor');
        // console.log(person2.friend); // ["daisy", "kelly", "taylor"]
```

特点：复制一个对象，用函数来包装。

缺：1，所有实例都会继承原型上的属性。2，无法实现替代。（新实例属性都是后面添加的）

#### 8.3.5寄生式继承

```
 var ob = {
            name: 'xiaopao',
            friends: ['lulu','huahua']
        }

        function CreateObj(o){
            function F(){};  // 创建一个构造函数F
            F.prototype = o;
            return new F();
        }

        // 上面CreateObj函数 在ECMAScript5 有了一新的规范写法，Object.create(ob) 效果是一样的 , 看下面代码
        var ob1 = CreateObj(ob);
        var ob2 = Object.create(ob);
        console.log(ob1.name); // xiaopao
        console.log(ob2.name); // xiaopao
```

特点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创造的新对象。

缺：没用到原型，无法重复

#### 8.3.6寄生组合继承

```
   function Parent(name){
            this.name = name;
            this.colors = ['red', 'blue', 'green'];
        }

        Parent.prototype.sayName = function(){
            console.log(this.name);
        }

        function Child(name,age){
            Parent.call(this,name); 
            this.age = age;
        }

        function CreateObj(o){
            function F(){};
            F.prototype = o;
            return new F();
        }

        // Child.prototype = new Parent(); // 这里换成下面
        function prototype(child,parent){
            var prototype = CreateObj(parent.prototype);
            prototype.constructor = child;
            child.prototype = prototype;
        }
```

特：修复了组合继承的问题

### 8.4类

概念：把具有共同性质的事物归结为一类，得出一个抽象的概念-类

#### 8.4.1定义类

```
class Person {} // 类声明
const Animal = class {};// 类表达式
```

#### 8.4.2构造函数

```
function F(){
 
}
new F();
```

- 经历的步骤：

1. 创建一个空对象，作为将要返回的实例对象
2. 将空对象的原型指向构造函数的原型属性，也就是F构造函数的原型属性。
3. 将空对象赋值给构造函数内部的此关键字，也就是此关键字会指向实例对象。
4. 开始执行构造函数内部的代码。

理解构造函数属性：

任何javascript函数都可以用来做构造函数，并且调用构造函数是需要用到一个原型属性的，因此每个javascript函数都在动拥有一个原型属性。这个属性的值是一个对象，这个对象包含唯一一个不可美居枚举属性构造函数，构造函数属性的值是一个函数对象

#### 8.4.3 es6类

ES6中类就是根据构造函数原理来的：

```
class F {
  constructor(name) 
    this.name = 'Base';
   }
    getName() {
       //==>F.prototype.getName=function(){}
    }
}
```

**类的继承**

继承父类后，子类会继承父类所有的方法和属性（包括静态方法和属性）

如果子类没有定义`constructor`方法，会默认被添加该方法

任何子类都有`constructor`方法;

```
 Class Father{
 3       constructor(){
 4       }
 5      sum(){
 6          console.log("abc");
 7      }
 8      static fn(){
 9          console.log("hello")
10      }
11  }
12  Class Son extends Father{
13     
14  }
15  let s=new Son();
16  s.sum()//abc,继承了父类的sum()方法
17  Son.fn()//hello 继承了父类的静态方法fn()
```

**超**

用父类的构造函数直接使用`super()`，并且可以传参；

子类的构造函数中，只有调用了`super`之后才可以使用`this`关键字，否则会报错;

```
 2  class Father{
 3       constructor(){
 4         console.log("bbb");
 5      }
 6  }
 7  class Son extends Father{
 8      constructor(x){
 9         this.x=x;//ReferenceError,报错
10         super();
11         this.x=x;//正确
12      }
13  }
14  let sum=new Son();//bbb
```

。**类的静态静态**

在属性或方法前面使用`static`定义类的静态属性和方法；

所有的静态属性和静态方法都不能通过实例化的对象调用；

需要通过类来调用，静态属性和静态方法是类的专属属性和方法，和实例化对象无关，例如表格和数学方法中的：`Array.from();Math.random（）。`

```
1 class Mold{
 2          static x=0;
 3          y=1;
 4          static fn1(){
 5              console.log("aaa")
 6          }
 7          fn2(){
 8              console.log("bbb");
 9          }
10         }
11      let m=new Mold();
12      console.log(m.x,m.y);//undefined , 1
13      m.fn1(); // TypeError 
14      m.fn2(); // bbb
15      //需要通过类来调用
16      Mold.fn1(); //aaa
17      console.log(Mold.x);//0
```

